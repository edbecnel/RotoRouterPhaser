<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RotoRouter</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: #0f1115; color: #e6e6e6; }
    .app { display: grid; grid-template-columns: 360px 1fr; height: 100%; }
    .sidebar { padding: 14px 16px; border-right: 1px solid #222835; background: #121723; overflow: auto; }
    .sidebar h1 { font-size: 18px; margin: 0 0 8px; }
    .sidebar h2 { font-size: 14px; margin: 16px 0 8px; color: #b7c1ff; }
    .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; flex-wrap: wrap; }
    .row.nowrap { flex-wrap: nowrap; }
    .nowrap { white-space: nowrap; }
    .btn { padding: 8px 10px; background: #1b2233; color: #fff; border: 1px solid #30384f; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .tag { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #2a3249; background: #0f1626; }
    .panel { border: 1px solid #1f2636; padding: 10px; border-radius: 12px; background: #0d1220; }
    .muted { color: #9da6b8; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .small { font-size: 12px; }
    .legend { display: grid; grid-template-columns: auto 1fr; gap: 6px 10px; align-items: center; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; border: 1px solid #fff4; }
    canvas { display: block; }
    .toast { position: fixed; left: 380px; bottom: 16px; background: #182031; border: 1px solid #2b3650; padding: 10px 14px; border-radius: 10px; pointer-events: none; opacity: 0; transition: opacity .18s ease; }
    .toast.show { opacity: 1; }
    label.toggle { display:flex; align-items:center; gap:8px; font-size:12px; user-select:none; }
    .warn {
      color: #c00;       /* red text */
      font-weight: 600;  /* bold */
    }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>RotoRouter</h1>
      <div class="panel">
        <div class="row"><span class="tag" id="turnTag">Turn: —</span><span class="tag" id="phaseTag">Phase: —</span></div>
        <div class="row small muted" id="status">New Game → Draw → Place. First placement is your corner.</div>
      </div>

      <h2>Setup</h2>
      <div class="grid">
        <label class="small muted">Board Size
          <select id="boardSize">
            <option value="9">9×9</option>
            <option value="7">7×7</option>
          </select>
        </label>
      </div>
      <div class="row"><button class="btn" id="newGameBtn">New Game</button></div>

      <h2>Actions</h2>
      <div class="panel">
        <div class="row"><b>Track</b></div>
        <div class="row">
          <button class="btn" id="drawBtn">Draw</button>
          <span id="drawnCard" class="tag">Card: —</span>
          <span id="drawTag" class="tag">Draw: Ready</span>
        </div>
        <div class="row">
          <button class="btn" id="placeBtn">Place</button>
          <button class="btn" id="bottomBtn">Bottom</button>
        </div>
        <div class="row small muted nowrap"><span>Hover shows a <b>ghost</b>. Click to place. Rotate with Q/E.</span></div>
        <hr style="border-color:#1f2636"/>
        <div class="row"><b>Token</b></div>
        <div class="row">
          <button class="btn" id="tokenBtn">Token Action</button>
          <span id="tokenTag" class="tag">Token: Ready</span>
          <span id="skippedTag" class="tag">Skipped: 0/3</span>
          <span id="elbowSkippedTag" class="tag">Elbows Skipped: 0/3</span>
          <span id="tokenCount" class="tag">Token: 0/3</span>
          <span id="scoreTag" class="tag">Score: 0/3</span>
        </div>
        <div class="row small muted">Move along <b>any connected pipes</b> (opponent tracks allowed once networks connect). One token action/turn. Max 3 tokens/player.</div>
        <label class="toggle"><input type="checkbox" id="vizEdges"> Show connection edges</label>
        <hr style="border-color:#1f2636"/>
        <div class="row"><b>Rotation</b></div>
        <div class="row">
          <button class="btn" id="rollBtn">Roll Die</button>
          <span id="dieFace" class="tag">Die: —</span>
          <button class="btn" id="applyBtn" disabled>Apply</button>
          <span id="rollTag" class="tag">Roll: Ready</span>
        </div>
        <div class="row small muted">Meshed gears: neighbors alternate opposite direction. One roll per turn.</div>
        <hr style="border-color:#1f2636"/>
        <div class="row"><button class="btn" id="endTurnBtn">End Turn</button>
        <button id="overrideBtn" style="display:none;">Override</button></div>

        <hr style="border-color:#1f2636"/>
        <div class="row"><b>Undo / Redo</b></div>
        <div class="row">
          <button class="btn" id="undoGlobalBtn" disabled>Undo (Global)</button>
          <button class="btn" id="redoGlobalBtn" disabled>Redo (Global)</button>
        </div>
        <div class="row">
          <button class="btn" id="undoTurnBtn" disabled>Undo (Turn)</button>
          <button class="btn" id="redoTurnBtn" disabled>Redo (Turn)</button>
        </div>

        <h2>Save / Load</h2>
        <div class="panel">
          <div class="row">
            <button class="btn" id="saveBtn">Save Game</button>
            <button class="btn" id="loadBtn">Load Game</button>
            <input type="file" id="loadFile" accept="application/json" style="display:none" />
          </div>
          <div class="row small muted">
            Saves to a local JSON file. Load restores the full game later.
          </div>
        </div>
      </div>

      <h2>Corners</h2>
      <div class="panel">
        <table class="scoreTable" id="cornerScoreTable" style="width:100%; border-collapse:collapse;">
          <thead>
            <tr>
              <th style="text-align:left;">Color</th>
              <th style="text-align:left;">Quadrant</th>
              <th style="text-align:right;">Score</th>
            </tr>
          </thead>
          <tbody>
            <tr data-pid="0">
              <td><span class="dot" style="background:#ff6b6b"></span> Red</td>
              <td id="quad-0">—</td>
              <td id="score-0" style="text-align:right;">0/3</td>
            </tr>
            <tr data-pid="1">
              <td><span class="dot" style="background:#6bff95"></span> Green</td>
              <td id="quad-1">—</td>
              <td id="score-1" style="text-align:right;">0/3</td>
            </tr>
            <tr data-pid="2">
              <td><span class="dot" style="background:#6bd9ff"></span> Blue</td>
              <td id="quad-2">—</td>
              <td id="score-2" style="text-align:right;">0/3</td>
            </tr>
            <tr data-pid="3">
              <td><span class="dot" style="background:#ffef6b"></span> Yellow</td>
              <td id="quad-3">—</td>
              <td id="score-3" style="text-align:right;">0/3</td>
            </tr>
          </tbody>
        </table>
      </div>
    </aside>
    <main id="game"><canvas id="board"></canvas></main>
  </div>
  <div id="toast" class="toast"></div>

<script>
(function(){
  // Toast with adjustable duration (defaults to ~3.5s) and proper clearing
  let _toastTimer=null;
  const toast=(m, ms=3500)=>{
    const el=document.getElementById('toast');
    el.textContent=m;
    el.classList.add('show');
    if(_toastTimer) clearTimeout(_toastTimer);
    _toastTimer=setTimeout(()=>el.classList.remove('show'), ms);
  };  
  const setStatus=(t)=>{ document.getElementById('status').innerHTML=t; };
  const tag = (id)=>document.getElementById(id);
  const turnTag=()=>tag('turnTag');
  const phaseTag=()=>tag('phaseTag');
  const drawnTag=()=>tag('drawnCard');
  const drawTag=()=>tag('drawTag');
  const dieTag=()=>tag('dieFace');
  const rollTag=()=>tag('rollTag');
  const tokenTag=()=>tag('tokenTag');
  const tokenCount=()=>tag('tokenCount');
  const btn=(id)=>document.getElementById(id);

  // Colors & constants
  const COLORS={ bg:'#0b0f18', grid:'#263145', gear:'#202a3d', track:'#6d7aa6', block:'#434b63', slot:'#a8b7ff', hilite:'#9efff4', tokenR:'#ff6b6b', tokenG:'#6bff95', tokenB:'#6bd9ff', tokenY:'#ffef6b', edge:'#f4b86a', hint:'#c7f0ff' };
  const TrackCard={ Straight:'Straight', Elbow:'Elbow', Cross:'Cross', RStraight:'RS', RElbow:'RE', RCross:'RC' };
  const DIE_FACES=['X','X','X','CW90','CW90','CCW90','CCW90','DEG180'];
  const TOKENS_MAX=3;
  const PLAYERS=[
    { id:0, name:'Red', color: COLORS.tokenR, pocket:'NW' },
    { id:1, name:'Green', color: COLORS.tokenG, pocket:'NE' },
    { id:2, name:'Blue', color: COLORS.tokenB, pocket:'SE' },
    { id:3, name:'Yellow', color: COLORS.tokenY, pocket:'SW' },
  ];

  // ==== GEAR SVG (mesh-ready: alternate 0° / 90°) ====
  const GEAR_SRC = 'gear-grayblue.svg';     // file should sit beside RotoRouter.html
  const gearImg = new Image();
  let gearReady = false;
  // Optional: set decoding to sync to improve first-paint, browsers may ignore
  if ('decoding' in gearImg) gearImg.decoding = 'sync';
  gearImg.onload = () => { gearReady = true; render(); };
  gearImg.onerror = () => { console.warn('Could not load gear SVG:', GEAR_SRC); };
  gearImg.src = GEAR_SRC;
  // How tightly the gear outer diameter should fit the cell (1.00 = full cell)
  // For tight teeth meshing, keep at 1.00. If you want a tiny gap, try 0.98.
  const GEAR_OUTER_FIT = 1.00;   // -> try 0.98 if you prefer a hairline gap
  // ==== GEAR SPIN (animated) ====
  // Toggle overall gear animation
  const GEAR_SPIN_ENABLED = true;

  // Spin speed in revolutions per minute (positive = clockwise for even parity cells)
  const GEAR_SPIN_RPM = 6;   // try 3–12 to taste

  // ==== UNDO / REDO CONFIG ====
  // Master switch and per-scope toggles (code-only; no UI)
  const UNDO_CONFIG = {
    enabled: true,     // turn Undo/Redo on/off entirely
    global:  true,     // allow Global undo/redo
    turn:    true      // allow Player-turn-scoped undo/redo
  };


  // Openings — Elbow base = EAST+NORTH (NE), Straight is horizontal base
  const OPENINGS={
    Straight: [[1,0],[-1,0]],
    Elbow: [[1,0],[0,-1]],
    Cross: [[1,0],[-1,0],[0,1],[0,-1]]
  };
  function rotDir([dx,dy],deg){ const t=((deg%360)+360)%360; if(t===0) return [dx,dy]; if(t===90) return [-dy,dx]; if(t===180) return [-dx,-dy]; if(t===270) return [dy,-dx]; return [dx,dy]; }
  function rotatedOpenings(cell){
    if(!cell.track || cell.track==='Block') return [];
    return OPENINGS[cell.track].map(([dx,dy])=>rotDir([dx,dy], cell.rot));
  }
  function hasReciprocal(aCell, bCell, dx, dy){
    const aOk = rotatedOpenings(aCell).some(([rx,ry])=>rx===dx && ry===dy);
    if(!aOk) return false;
    const bOk = rotatedOpenings(bCell).some(([rx,ry])=>rx===-dx && ry===-dy);
    return bOk;
  }
  
  // Utilities & state
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function makeDeck(size){
    const cfgMap = {
      7: { Straight:10, Elbow:6, RStraight:3, RElbow:2, Cross:2, RCross:1 },
      9: { Straight:13, Elbow:8, RStraight:4, RElbow:3, Cross:2, RCross:2 },
    };
    const cfg = cfgMap[size] || (size <= 7 ? cfgMap[7] : cfgMap[9]);
    return {
      draw: shuffle([
        ...Array(cfg.Straight).fill(TrackCard.Straight),
        ...Array(cfg.Elbow).fill(TrackCard.Elbow),
        ...Array(cfg.RStraight).fill(TrackCard.RStraight),
        ...Array(cfg.RElbow).fill(TrackCard.RElbow),
        ...Array(cfg.Cross).fill(TrackCard.Cross),
        ...Array(cfg.RCross).fill(TrackCard.RCross),
      ]),
      discard: []
    };
  }
  function makeBoard(N){ const b=[]; for(let y=0;y<N;y++){ const r=[]; for(let x=0;x<N;x++){ r.push({track:null,rot:0,owner:null,token:null}); } b.push(r);} return b; }
  function initGearOffsets(N){
    state.gearOffset = Array.from({length:N}, () => Array(N).fill(0));
  }

  const UI = {
    boardSize:()=>document.getElementById('boardSize'),
    template:()=>document.getElementById('template'),
    canvas:()=>document.getElementById('board'),
    vizEdges:()=>document.getElementById('vizEdges'),
  };

  const state={ N:9, cell:64, pad:20, board:makeBoard(9),
    players:PLAYERS.map(p=>({...p, deck:makeDeck(), drawn:null, tokens:0, drawLocked:false, drawUsed:false, tokenUsed:false, rollUsed:false, skipCount: 0, elbowSkipCount: 0, forceElbow: false })),
    cornerLockTurns: PLAYERS.map(()=>0),
    current:0, phase:'idle', subphase:null, highlight:[], hover:null, forcePlace:false, previewRot:0, die:null, tokenSelect:null,
    turnAdvancing:false,
    deadFixDoneThisTurn: false,
    rotAnims: [],  // active rotation tweens (on placed tiles)
    ghostRotAnim: null,   // {from,to,t0,dur} while rotating the ghost
    _animating: false,     // RAF loop guard
    gearSpinAnim: null,   // { base: +90|-90|180, t0, dur } active only during Apply tween
    gearOffset: null,     // per-cell persistent gear angle offset (degrees, 0..359)
    // Undo/Redo stacks
    history: [],        // Global undo stack (array of snapshots)
    redo:    [],        // Global redo stack
    turnHistory: [],    // Per-turn undo stack (current player's turn)
    turnRedo:   []      // Per-turn redo stack
  };
  const canvas=UI.canvas(); const ctx=canvas.getContext('2d');

  // ==== UNDO / REDO HELPERS ====
  function pushHistory(label){
    if (!UNDO_CONFIG.enabled) return;
    const snap = snapshotState();
    snap.__turnId = state.current;      // tag snapshot with current player's turn id
    snap.__undo_label = label || '';
    // Global
    if (UNDO_CONFIG.global){
      state.history.push(snap);
      state.redo.length = 0; // new action invalidates redo
    }
    // Turn-scoped
    if (UNDO_CONFIG.turn){
      state.turnHistory.push(snap);
      state.turnRedo.length = 0;
    }
    updateUndoButtons();
  }

  function applySnapshotFromHistory(snap, label, op){
    // op is 'undo' or 'redo'
    applySnapshot(snap, { fromHistory: true, status: label || null, op });
  }

  function updateUndoButtons(){
    // Called inside updateHUD() as well, but safe to call anytime
    const gCanUndo = UNDO_CONFIG.enabled && UNDO_CONFIG.global && state.history.length > 0;
    const gCanRedo = UNDO_CONFIG.enabled && UNDO_CONFIG.global && state.redo.length > 0;

    const tCanUndo = UNDO_CONFIG.enabled && UNDO_CONFIG.turn && state.turnHistory.length > 1; // need ≥1 action beyond baseline
    const tCanRedo = UNDO_CONFIG.enabled && UNDO_CONFIG.turn && state.turnRedo.length > 0;

    const bU = document.getElementById('undoGlobalBtn');
    const bR = document.getElementById('redoGlobalBtn');
    const bTU= document.getElementById('undoTurnBtn');
    const bTR= document.getElementById('redoTurnBtn');

    if (bU) bU.disabled  = !gCanUndo;
    if (bR) bR.disabled  = !gCanRedo;
    if (bTU) bTU.disabled = !tCanUndo;
    if (bTR) bTR.disabled = !tCanRedo;
  }

  // Global Undo/Redo (mirrors into Turn stacks so buttons stay in sync)
  function undoGlobal(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.global) return;
    if (state.history.length === 0) return;

    const cur = snapshotState();            // current state → global redo
    const prev = state.history.pop();       // previous snapshot to apply
    state.redo.push(cur);

    // Mirror into Turn stacks
    if (UNDO_CONFIG.turn) {
      const curTurnId  = state.current;
      const stepTurnId = (prev && prev.__turnId != null) ? prev.__turnId : curTurnId;

      if (stepTurnId === curTurnId) {
        // Undoing a step from THIS turn → pop one from per-turn history
        if (state.turnHistory.length > 1) {
          state.turnRedo.push(cur);
          state.turnHistory.pop();
        }
      } else {
        // Undoing into a different turn → collapse to baseline for clarity
        state.turnHistory = state.turnHistory.slice(0, 1);
        state.turnRedo.length = 0;
      }
    }

    applySnapshotFromHistory(prev, 'Undid (Global).', 'undo');
    toast('Undo (Global)');
    updateUndoButtons();
  }

  function redoGlobal(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.global) return;
    if (state.redo.length === 0) return;

    const cur  = snapshotState();       // current state → global history
    const next = state.redo.pop();      // snapshot to reapply
    state.history.push(cur);

    // Mirror into Turn stacks
    if (UNDO_CONFIG.turn) {
      const curTurnId  = state.current;
      const stepTurnId = (next && next.__turnId != null) ? next.__turnId : curTurnId;

      if (stepTurnId === curTurnId) {
        // Redoing a step that belongs to THIS turn
        state.turnHistory.push(cur);
        if (state.turnRedo.length > 0) state.turnRedo.pop();
      } else {
        // Redoing into a different turn → keep per-turn at baseline
        state.turnHistory = state.turnHistory.slice(0, 1);
        state.turnRedo.length = 0;
      }
    }

    applySnapshotFromHistory(next, 'Redid (Global).', 'redo');
    toast('Redo (Global)');
    updateUndoButtons();
  }

  // Turn-scoped Undo/Redo (only within the *current* player's turn)
  function undoTurn(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.turn) return;
    // Need at least baseline + 1 action
    if (state.turnHistory.length <= 1) return;

    // Current snapshot becomes redo entry
    const cur = snapshotState();

    // Pop the target "previous" snapshot from turnHistory and apply it
    const prev = state.turnHistory.pop();

    // Mirror the move to Global stacks so buttons/behavior stay in sync
    if (UNDO_CONFIG.global && state.history.length > 0) {
      // push current to global redo, drop one from global history
      state.redo.push(cur);
      state.history.pop();
    }

    // Turn redo receives current
    state.turnRedo.push(cur);

    applySnapshotFromHistory(prev, 'Undid (Turn).', 'undo');
    toast('Undo (Turn)');
    updateUndoButtons();
  }

  function redoTurn(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.turn) return;
    if (state.turnRedo.length === 0) return;

    const cur = snapshotState();
    const next = state.turnRedo.pop();

    // Mirror to Global stacks
    if (UNDO_CONFIG.global) {
      // current becomes a new step in global history
      state.history.push(cur);
      // consume one from global redo if available
      if (state.redo.length > 0) state.redo.pop();
    }

    // Turn history receives current
    state.turnHistory.push(cur);

    applySnapshotFromHistory(next, 'Redid (Turn).', 'redo');
    toast('Redo (Turn)');
    updateUndoButtons();
  }

  // Reset per-turn history at the start of each player's turn.
  function resetTurnHistory(){
    state.turnHistory = [];
    state.turnRedo    = [];
    // Push a baseline so "first action" undo target exists,
    // but keep the button disabled until an action actually happens.
    if (UNDO_CONFIG.enabled && UNDO_CONFIG.turn){
      state.turnHistory.push(snapshotState());
      state.turnRedo.length = 0;
    }
    updateUndoButtons();
  }

  // ===== SAVE / LOAD =====

  // Build a plain JSON-safe snapshot of the full game state.
  function snapshotState() {
    // Convert Sets to arrays, drop transient/animation fields
    const players = state.players.map(p => ({
      id: p.id,
      name: p.name,
      color: p.color,
      pocket: p.pocket,
      deck: {
        draw: [...(p.deck?.draw || [])],
        discard: [...(p.deck?.discard || [])],
      },
      drawn: p.drawn ?? null,
      tokens: p.tokens|0,
      drawLocked: !!p.drawLocked,
      drawUsed: !!p.drawUsed,
      tokenUsed: !!p.tokenUsed,
      rollUsed: !!p.rollUsed,
      skipCount: p.skipCount|0,
      elbowSkipCount: p.elbowSkipCount|0,
      forceElbow: !!p.forceElbow,
      reached: p.reached ? Array.from(p.reached) : [], // names of corners reached
    }));

    // Deep copy board (tracks, rotations, owners, tokens)
    const board = [];
    for (let y=0; y<state.N; y++) {
      const row = [];
      for (let x=0; x<state.N; x++) {
        const c = state.board[y][x] || {};
        row.push({
          track: c.track ?? null,
          rot: c.rot|0,
          owner: (c.owner==null? null : c.owner|0),
          token: (c.token==null? null : c.token|0),
        });
      }
      board.push(row);
    }

    // Deep copy per-cell gear offsets so Undo/Redo can restore visual orientation
    const gearOffset = (state.gearOffset && state.gearOffset.length === state.N)
      ? state.gearOffset.map(row => row.slice())
      : null;    

    return {
      __rr_version: 1,
      savedAt: new Date().toISOString(),
      N: state.N,
      current: state.current|0,
      players,
      board,
      gearOffset,  // ← include in snapshot (also helps Save/Load stay visually consistent)
      // Corner/seal bookkeeping
      cornerLockTurns: Array.isArray(state.cornerLockTurns) ? [...state.cornerLockTurns] : null,
      cornerSealed: Array.isArray(state.cornerSealed) ? [...state.cornerSealed] : null,
      deadFixDoneThisTurn: !!state.deadFixDoneThisTurn,   // ← top-level, not per-player
      // We intentionally DO NOT persist: phase, subphase, highlights, die, animations, hover, etc.
    };
  }

  // Download a JSON file (no server needed)
  function downloadJSON(obj, filename) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      document.body.removeChild(a);
    }, 0);
  }

  function saveGame() {
    const snap = snapshotState();
    const name = `RotoRouter_${snap.N}x${snap.N}_${snap.savedAt.replace(/[:.]/g,'-')}.json`;
    downloadJSON(snap, name);
    toast('Game saved.');
  }

  // Apply a snapshot back into our live state (safe restore)
  function applySnapshot(snap, opts) {
    // Basic validation
    if (!snap || typeof snap !== 'object' || snap.__rr_version == null) {
      throw new Error('Not a valid RotoRouter save file.');
    }
    if (!Number.isInteger(snap.N) || !Array.isArray(snap.board) || !Array.isArray(snap.players)) {
      throw new Error('Save is missing required fields.');
    }
    // Clear stacks only on real loads, not when applying from history
    if (!opts || !opts.fromHistory) {
      state.history = []; state.redo = [];
      state.turnHistory = []; state.turnRedo = [];
    }
    // Resize board if needed & sync dropdown
    state.N = snap.N;
    const sizeSel = UI.boardSize();
    if (sizeSel) {
      const opt = [...sizeSel.options].find(o => parseInt(o.value,10) === state.N);
      if (opt) sizeSel.value = String(state.N);
    }

    // Restore board
    state.board = makeBoard(state.N);
    initGearOffsets(state.N); // <- add this
    for (let y=0; y<state.N; y++) {
      for (let x=0; x<state.N; x++) {
        const s = (snap.board[y] && snap.board[y][x]) || {};
        state.board[y][x] = {
          track: s.track ?? null,
          rot: (s.rot|0) % 360,
          owner: (s.owner==null? null : s.owner|0),
          token: (s.token==null? null : s.token|0),
        };
      }
    }

    // Restore per-cell gear angles if present in the snapshot (Undo/Redo & Save/Load)
    if (Array.isArray(snap.gearOffset)) {
      state.gearOffset = Array.from({length: state.N}, (_, y) =>
        Array.from({length: state.N}, (_, x) => {
          const v = (snap.gearOffset[y] && snap.gearOffset[y][x]);
          return Number.isFinite(v) ? ((((v % 360) + 360) % 360)|0) : 0;
        })
      );
    } // else keep the zero-initialized offsets from initGearOffsets(N)    

    // Restore players (keep order aligned with PLAYERS by id)
    state.players = PLAYERS.map((baseP) => {
      const from = snap.players.find(pp => pp.id === baseP.id) || {};
      return {
        id: baseP.id,
        name: baseP.name,
        color: baseP.color,
        pocket: baseP.pocket,
        deck: {
          draw: [...(from.deck?.draw || [])],
          discard: [...(from.deck?.discard || [])],
        },
        drawn: from.drawn ?? null,
        tokens: from.tokens|0,
        drawLocked: !!from.drawLocked,
        drawUsed: !!from.drawUsed,
        tokenUsed: !!from.tokenUsed,
        rollUsed: !!from.rollUsed,
        skipCount: from.skipCount|0,
        elbowSkipCount: from.elbowSkipCount|0,
        forceElbow: !!from.forceElbow,
        reached: new Set(from.reached || []),
      };
    });

    // Turn + corner bookkeeping
    state.current = (snap.current|0) % state.players.length;
    state.cornerLockTurns = Array.isArray(snap.cornerLockTurns)
      ? snap.cornerLockTurns.slice(0, PLAYERS.length)
      : PLAYERS.map(()=>0);
    state.cornerSealed = Array.isArray(snap.cornerSealed)
      ? snap.cornerSealed.slice(0, PLAYERS.length)
      : PLAYERS.map(()=>false);

    // Reset transients/animations/UI-phase safely
    state.phase = 'idle';
    state.subphase = null;
    state.highlight = [];
    state.hover = null;
    state.forcePlace = false;
    state.previewRot = 0;
    state.die = null;
    state.tokenSelect = null;
    state.rotateFocus = null;
    state.turnAdvancing = false;
    state.rotAnims = [];
    state.ghostRotAnim = null;
    state.deadFixDoneThisTurn = !!snap.deadFixDoneThisTurn;   // default false if absent

    // Recompute saturation immediately after restore
    refreshBoardSaturation();

    // Recompute any topology-derived hints (e.g., seals)
    if (typeof onTopologyChanged === 'function') onTopologyChanged();

    // Resize canvas for the (possibly) new N and redraw
    resize();
    updateHUD();

    if (opts && opts.fromHistory) {
      // After UNDO/REDO, re-enter fix phases (Corner Fix then Dead-Straight Fix) if eligible
      maybeEnterFixPhasesAfterHistory(opts.op);

      // If we are not in a fix subphase, show the provided status (e.g., “Redid (Global)”).
      if (state.phase !== 'cornerFix' && state.phase !== 'deadFix' && opts.status) {
        setStatus(opts.status);
      }
      render();
      return;
    }

    // ---- real file load path ----
    setStatus('Game loaded.');
    render();
    startTurn();
    return;
  }

  function loadFromFile(file) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const snap = JSON.parse(reader.result);
        applySnapshot(snap);
        toast('Save loaded successfully.');
      } catch (err) {
        console.error(err);
        toast('Failed to load: ' + err.message);
        setStatus('Load error: ' + err.message);
      }
    };
    reader.readAsText(file);
  }


  function resize(){
    const rightW = window.innerWidth - 360; const h = window.innerHeight;
    const size = Math.min(rightW, h) * 0.95;
    state.cell = Math.floor(size / state.N);
    state.pad = Math.floor((Math.min(rightW, h) - state.cell*state.N)/2);
    canvas.width = rightW; canvas.height = h;
    render();
  }
  window.addEventListener('resize', resize);

  function currentPlayer(){ return state.players[state.current]; }
  
function opponentCornerAt(x,y,pid){
  for(const q of PLAYERS){
    if(q.id===pid) continue;
    const c = cornerFor(q.id);
    if(c.x===x && c.y===y) return q.id;
  }
  return null;
}

function cornerFor(pid){
    const N=state.N; const p=PLAYERS[pid].pocket;
    if(p==='NW') return {x:0,y:0}; if(p==='NE') return {x:N-1,y:0}; if(p==='SE') return {x:N-1,y:N-1}; return {x:0,y:N-1};
  }
  function owned(pid){ const out=[]; for(let y=0;y<state.N;y++) for(let x=0;x<state.N;x++){ const c=state.board[y][x]; if(c.track && c.owner===pid) out.push({x,y}); } return out; }
  function within(x,y){ return x>=0 && y>=0 && x<state.N && y<state.N; }

  // ---- Dead-Straight detection helpers (STRICT: "trapped straight") ----
  function isStraightHorizontal(cell){
    return !!cell && cell.track === 'Straight' && ((cell.rot|0) % 180 === 0); // 0 or 180
  }
  function isStraightVertical(cell){
    return !!cell && cell.track === 'Straight' && ((cell.rot|0) % 180 !== 0); // 90 or 270
  }

  // STRICT + BORDER rule:
  // A Straight at (x,y) is “trapped” iff:
  // • Every *present* orthogonal neighbor is a Straight oriented perpendicular to the center, AND
  // • At least 3 neighbors are present (so corners with only 2 neighbors never qualify).
  // This covers:
  //   – Inner cells: need all 4 neighbors, all perpendicular (classic case).
  //   – Border cells: 3 in-bounds neighbors, all perpendicular ⇒ trapped.
  //   – Corner cells: only 2 neighbors ⇒ never trapped.
  function isTrappedStraight(x, y) {
    const c = state.board[y][x];
    if (!c || c.track !== 'Straight') return false;

    const centerIsH = isStraightHorizontal(c);

    // Describe the 4 orthogonal neighbors with bounds checks
    const neigh = [
      { nx: x - 1, ny: y,     need: centerIsH ? isStraightVertical : isStraightHorizontal }, // L
      { nx: x + 1, ny: y,     need: centerIsH ? isStraightVertical : isStraightHorizontal }, // R
      { nx: x,     ny: y - 1, need: centerIsH ? isStraightVertical : isStraightHorizontal }, // U
      { nx: x,     ny: y + 1, need: centerIsH ? isStraightVertical : isStraightHorizontal }, // D
    ];

    let present = 0;

    for (const n of neigh) {
      if (!within(n.nx, n.ny)) continue;           // out-of-bounds neighbor simply doesn't exist
      present++;
      const cell = state.board[n.ny][n.nx];
      if (!n.need(cell)) return false;             // present neighbor must be a Straight, perpendicular
    }

    // Require at least 3 present neighbors to count as trapped.
    // This allows border (3-side) traps and inner (4-side) traps, but excludes corners (2).
    return present >= 3;
  }

  function findAllTrappedStraights(){
    const out = [];
    for (let y=0; y<state.N; y++){
      for (let x=0; x<state.N; x++){
        if (isTrappedStraight(x,y)) out.push({x,y});
      }
    }
    return out;
  }

    // --- replace the entire maybeResumeDeadFixAfterHistory() with this unified helper ---
  function maybeEnterFixPhasesAfterHistory(op){
    if (state.turnAdvancing) return;
    if (state.phase !== 'idle') return;

    const P = currentPlayer();

    // Corner Fix has priority over Dead-Straight Fix
    if (typeof isCornerSealed === 'function' && isCornerSealed(P.id)) {
      startCornerFixCross(P.id);
      return;
    }

    // Dead-Straight Fix (only if not already consumed this turn)
    if (!state.deadFixDoneThisTurn && typeof findAllTrappedStraights === 'function') {
      const trapped = findAllTrappedStraights();
      if (trapped && trapped.length){
        state.phase    = 'deadFix';
        state.subphase = 'pickDeadStraight';
        state.highlight = trapped;
        const msg = 'Dead-Straight Fix: replace ONE highlighted Straight with a Cross (free).';
        setStatus(msg);
        render();
        updateHUD();
        return;
      }
    }
  }

  function isBoardFullyTracked(){
    for (let y=0; y<state.N; y++){
      for (let x=0; x<state.N; x++){
        const c = state.board[y][x];
        if (!c.track) return false;
      }
    }
    return true;
  }

  // Keep a cached flag on state
  state.boardSaturated = false;
  function refreshBoardSaturation(){
    const was = !!state.boardSaturated;
    state.boardSaturated = isBoardFullyTracked();
    if (!was && state.boardSaturated){
      setStatus('Board is full of tracks — drawing/placing tracks is now disabled. Tokens and rotations still allowed.');
      toast('Board fully tracked: track placement locked.');
    }
  }

  // Count tokens for a player
  function countTokens(pid){
    let n=0;
    for(let y=0;y<state.N;y++) for(let x=0;x<state.N;x++){ if(state.board[y][x].token===pid) n++; }
    return n;
  }
  function allTokensOf(pid){
    const arr=[];
    for(let y=0;y<state.N;y++) for(let x=0;x<state.N;x++){ if(state.board[y][x].token===pid) arr.push({x,y}); }
    return arr;
  }

  // BFS for token moves — move across ANY connected owner
  function reachableFrom(start, pid){
    // BFS over pipe connectivity only. Ownership never gates traversal.
    // Non-corner tokens allow PASS-THROUGH (cannot stop there).
    // Opponent-on-own-corner remains a valid scoring TERMINAL.
    const vis = new Set();
    const q = [start];
    const out = [];
    const key = (x,y)=>x+','+y;
    vis.add(key(start.x,start.y));
    while(q.length){
      const {x,y} = q.shift();
      const here = state.board[y][x];
      if(!here.track || here.track==='Block') continue;
      for(const [dx,dy] of rotatedOpenings(here)){
        const nx = x+dx, ny = y+dy;
        if(!within(nx,ny)) continue;
        const there = state.board[ny][nx];
        if(!there.track || there.track==='Block') continue;
        if(!hasReciprocal(here, there, dx, dy)) continue; // pipes must connect both ways
        const k = key(nx,ny);
        if(vis.has(k)) continue;

        // If it's an opponent's own corner AND their token is on it -> terminal scoring stop
        const oppId = opponentCornerAt(nx,ny,pid);
        const ownerOnOwnCorner = (oppId!=null && there.token===oppId);
        if (ownerOnOwnCorner){
          vis.add(k);
          out.push({x:nx,y:ny});      // can stop here
          continue;                   // but do not traverse beyond the scoring corner
        }

        vis.add(k);
        q.push({x:nx,y:ny});          // always traverse
        if (there.token==null){       // only empty cells are legal destinations
          out.push({x:nx,y:ny});
        }
      }
    }
    return out;
  }
  
  // Game flow
  function newGame(){
    state.N = parseInt(UI.boardSize().value,10);
    state.board = makeBoard(state.N);
    initGearOffsets(state.N); // <- add this
    state.players = PLAYERS.map(p=>({...p, deck:makeDeck(state.N), drawn:null, tokens:0, drawLocked:false, drawUsed:false, tokenUsed:false, rollUsed:false, skipCount: 0, elbowSkipCount: 0, forceElbow: false }));
    state.cornerLockTurns = PLAYERS.map(() => 0);
    state.cornerSealed    = PLAYERS.map(() => false);
    state.current = 0;

    // Reset undo/redo
    state.history = []; state.redo = [];
    state.turnHistory = []; state.turnRedo = [];

    // Now start the turn; this will push the baseline snapshot
    startTurn();
    updateUndoButtons();

    setStatus('New Game → Draw → Place. First placement is your corner.');
    state.rotAnims = [];
    state.ghostRotAnim = null;
    state._animating = false;
    if (Array.isArray(state.players)) for (const pl of state.players) pl.tokens = 0;
    refreshBoardSaturation();
  }

  function startTurn(){
    const P=currentPlayer();
    resetTurnHistory();
    P.drawLocked=false; P.drawUsed=false; P.tokenUsed=false; P.rollUsed=false;

    state.deadFixDoneThisTurn = false;
    state.phase='idle'; state.subphase=null; state.highlight=[]; state.hover=null; state.previewRot=0; state.die=null; state.tokenSelect=null; state.rotateFocus=null;
    checkForcePlace();
    // Ensure counter exists on first load (startTurn runs before newGame)
    if (!state.cornerLockTurns) state.cornerLockTurns = PLAYERS.map(()=>0);    

    // Corner lock tracker — trigger only when the corner is *truly* locally sealed:
    // corner has a track, both neighbors have tracks, and no single-tile rotation (corner or either neighbor)
    // can create a reciprocal connection into the board.
    const owner = currentPlayer();
    if (isCornerSealed(owner.id)) {
      state.cornerLockTurns[owner.id] = (state.cornerLockTurns[owner.id] || 0) + 1;
    } else {
      state.cornerLockTurns[owner.id] = 0;
    }
    // Immediate Corner Fix if THIS owner's corner is sealed (detected on last topology change)
    if (isCornerSealed(P.id)) {
      startCornerFixCross(P.id);
      return; // fix subphase renders/locks HUD
    }
    // --- Dead-Straight Fix (STRICT: trapped straight) ---
    if (state.phase !== 'cornerFix'){ // don't collide with Corner Fix UI
      const trapped = findAllTrappedStraights();
      if (trapped.length && !state.deadFixDoneThisTurn) {
        state.phase    = 'deadFix';
        state.subphase = 'pickDeadStraight';
        state.highlight = trapped;

        const msg = 'Dead-Straight Fix: replace ONE highlighted Straight with a Cross (free).';
        setStatus(msg);
        toast(msg);

        render();
        updateHUD();
        return; // wait for the click on one of the highlighted cells
      }
    }
    // --- end Dead-Straight Fix ---
    // --- end Dead-Straight Fix ---        
    updateHUD();
  }

  function endTurnImmediate(){
    pushHistory('End Turn');

    // If the ending player is still holding a track card, count as a skip
    const endingP = state.players[state.current];
    if (endingP.drawn && isTrackCard(endingP.drawn)) {
      endingP.skipCount++;
    }

    // If they are holding an Elbow, count an elbow-skip too
    if (endingP.drawn === TrackCard.Elbow) {
      endingP.elbowSkipCount++;
      checkForceElbow(endingP);
    }    

    state.current=(state.current+1)%state.players.length;
    startTurn();
    // Don't overwrite Corner or Dead-Straight Fix prompts after startTurn()
    if (state.phase !== 'cornerFix' && state.phase !== 'deadFix') {
      setStatus('Turn passed.');
    }
    state.turnAdvancing=false;
  }

  function endTurn(){
    if(state.turnAdvancing) return;
    state.turnAdvancing=true;
    setTimeout(endTurnImmediate, 120);
  }

  // Draw (1/turn)
  function drawCard(){
    pushHistory('Draw');

    if (state.boardSaturated){ setStatus('Board is full of tracks — drawing is disabled.'); toast('Draw disabled (board full)'); return; }
    const P=currentPlayer();
    if(P.drawLocked && !state.forcePlace){ setStatus('You bottomed this turn; drawing is locked until End Turn.'); return; }
    if(P.drawUsed   && !state.forcePlace){ setStatus('You have already drawn this turn. End Turn to draw again next turn.'); return; }

    if(P.drawn){ setStatus('Already holding a card. Place or Bottom.'); return; }
    if(P.deck.draw.length===0 && P.deck.discard.length>0){ P.deck.draw=shuffle(P.deck.discard.splice(0)); }
    if(P.deck.draw.length===0){ setStatus('Deck empty.'); return; }
    P.drawn=P.deck.draw.shift();
    // While forced, we don't mark Draw as "Used" so the button stays enabled until a placement happens.
    P.drawUsed = state.forcePlace ? false : true;    
    updateHUD();
    if (P.forceElbow && P.drawn === TrackCard.Elbow) {
      setStatus('Elbows Skipped reached 3/3 — you must place this Elbow now.');
    } else {
      setStatus(`${P.name} drew ${P.drawn}. Click Place.`);
    }
  }

  // Placement includes adjacency to player's tokens (even if token is on opponent tile)
  
function connectedTrackFromCorner(pid){
  const start = cornerFor(pid);
  const key = (x,y)=>x+','+y;
  const vis = new Set();
  const comp = [];
  const q = [];
  if (!within(start.x,start.y)) return comp;
  const startCell = state.board[start.y][start.x];
  if (!startCell.track){ return comp; } // No network yet if no track at corner
  q.push({x:start.x,y:start.y}); vis.add(key(start.x,start.y)); comp.push({x:start.x,y:start.y});
  while(q.length){
    const {x,y} = q.shift();
    const here = state.board[y][x];
    if(!here.track || here.track==='Block') continue;
    const opens = rotatedOpenings(here);
    for(const [dx,dy] of opens){
      const nx=x+dx, ny=y+dy; if(!within(nx,ny)) continue;
      const there = state.board[ny][nx];
      if(!there.track || there.track==='Block') continue;
      // openings must match in opposite direction
      const reciprocal = [-dx,-dy];
      const hasBack = rotatedOpenings(there).some(([adx,ady])=>adx===reciprocal[0] && ady===reciprocal[1]);
      if(!hasBack) continue;
      const k = key(nx,ny);
      if(!vis.has(k)){ vis.add(k); q.push({x:nx,y:ny}); comp.push({x:nx,y:ny}); }
    }
  }
  return comp;
}

// Start: Code to prevent "corner-lockout"
function cornerNeighbors(pid){ // returns [{x,y} corner, {x,y} n1, {x,y} n2]
  const c = cornerFor(pid);
  if (PLAYERS[pid].pocket === 'NW') return [c, {x:1,y:0},{x:0,y:1}];
  if (PLAYERS[pid].pocket === 'NE') return [c, {x:state.N-2,y:0},{x:state.N-1,y:1}];
  if (PLAYERS[pid].pocket === 'SE') return [c, {x:state.N-2,y:state.N-1},{x:state.N-1,y:state.N-2}];
  // SW
  return [c, {x:1,y:state.N-1},{x:0,y:state.N-2}];
}

// --- Corner seal detector (local, rotation-cost aware) ---
// A corner is considered sealed iff BOTH adjacent neighbors exist AND, for each neighbor,
// the minimal number of tiles you'd need to rotate (corner and/or that neighbor) to create
// a reciprocal connection is > 1. In other words: there is NO one-tile fix.
const RR_ROTATIONS = [0,90,180,270];
function rotatedOpeningsType(type, rot){ return OPENINGS[type].map(([dx,dy])=>rotDir([dx,dy], rot)); }
function hasReciprocalTypes(typeA, rotA, typeB, rotB, dx, dy){
  const aOK = rotatedOpeningsType(typeA, rotA).some(([rx,ry])=>rx===dx && ry===dy);
  if(!aOK) return false;
  const bOK = rotatedOpeningsType(typeB, rotB).some(([rx,ry])=>rx===-dx && ry===-dy);
  return bOK;
}
function minRotationsToConnect(cornerCell, nbrCell, dx, dy){
  if(!cornerCell?.track || !nbrCell?.track) return Infinity;
  let best = Infinity;
  for (const rc of RR_ROTATIONS){
    for (const rn of RR_ROTATIONS){
      if (hasReciprocalTypes(cornerCell.track, rc, nbrCell.track, rn, dx, dy)){
        const cost = (rc===cornerCell.rot?0:1) + (rn===nbrCell.rot?0:1); // tile-count cost
        if (cost < best) best = cost;
      }
    }
  }
  return best;
}

function isCornerSealed(pid){
  const [co, n1, n2] = cornerNeighbors(pid);
  const corner = state.board[co.y][co.x];
  const a = state.board[n1.y][n1.x];
  const b = state.board[n2.y][n2.x];
  if (!corner.track) return false;
  if (!(a.track && b.track)) return false; // evaluate only once both neighbors exist

  // Only the explicit "perpendicular straights jam" counts as sealed.
  // Corner must be a Straight, and both adjacent tiles must be Straights, and
  // both must be perpendicular to the corner's orientation.
  if (corner.track !== 'Straight') return false;
  if (!(a.track === 'Straight' && b.track === 'Straight')) return false;
  const isH = (rot) => ((rot % 180) === 0);
  const cornerIsHorizontal = isH(corner.rot);
  const aIsHorizontal      = isH(a.rot);
  const bIsHorizontal      = isH(b.rot);
  // Horizontal corner jammed by two verticals, or vertical corner jammed by two horizontals
  return (cornerIsHorizontal && !aIsHorizontal && !bIsHorizontal) ||
         (!cornerIsHorizontal && aIsHorizontal && bIsHorizontal);
}

function startCornerFixCross(ownerId){
  state.phase = 'cornerFix';
  state.fixOwner  = ownerId;
  state.fixCorner = cornerFor(ownerId); // {x,y}
  state.highlight = [state.fixCorner];
  state.rotateFocus = null; state.previewRot = 0;
  // Show a persistent RED warning while the fix is pending
  setStatus('<span class="warn">Your corner is sealed. Click on your corner track to replace it with a cross track.</span>');
  updateHUD();
}
// Recompute corner seals after any topology change and toast when a new seal appears
function onTopologyChanged(){
  if (!state.cornerSealed) state.cornerSealed = PLAYERS.map(()=>false);
  const prev = state.cornerSealed.slice();
  const now  = PLAYERS.map(p=>isCornerSealed(p.id));
  state.cornerSealed = now;
  for (let pid=0; pid<PLAYERS.length; pid++){
    if (now[pid] && !prev[pid]){
      // Keep toast visible long enough to read
      toast(PLAYERS[pid].name + " corner sealed — corner will be auto-fixed on their next turn.", 4500);      
    }
  }
  refreshBoardSaturation();
}

// Correctly compute placement highlight positions applying these rules:
// (1) Corner-connected network (net): ownership-agnostic, so if you connect into an opponent’s tracks, their connected network is usable too.
// (2) Owned tiles (myOwned): so you can still build from your isolated islands.
// (3) Tokens (myTokens): already supported.
// (4) RS/RE special: allows selecting any existing Straight/Elbow of the correct type for rotation.
function computePlaceHighlights(){
  const pid = currentPlayer().id;
  const myOwned = owned(pid);
  const net = connectedTrackFromCorner(pid);
  const myTokens = allTokensOf(pid);
  const adj = new Map();

  /* RSRE HIGHLIGHTS */
  const D = currentPlayer().drawn;
  const base = baseDrawnType(D);
  if (D===TrackCard.RStraight || D===TrackCard.RElbow){
    for(let yy=0; yy<state.N; yy++){
      for(let xx=0; xx<state.N; xx++){
        const c = state.board[yy][xx];
        if(c.track===base && c.track!=='Block'){
          adj.set(xx+','+yy, {x:xx,y:yy});
        }
      }
    }
  }

  // RC (Replaceable Cross): any existing track is a valid target
  if (D===TrackCard.RCross){
    for(let yy=0; yy<state.N; yy++){
      for(let xx=0; xx<state.N; xx++){
        const c = state.board[yy][xx];
        //if(c.track==='Cross'){ adj.set(xx+','+yy, {x:xx,y:yy}); }
        if(c.track){ adj.set(xx+','+yy, {x:xx,y:yy}); }
      }
    }
    // Also allow RC to be PLACED on your own empty corner (not just replace)
    const co = cornerFor(pid);
    const cCell = state.board[co.y][co.x];
    if(!cCell.track && cCell.token==null){
      adj.set(co.x+','+co.y, {x:co.x, y:co.y});
    }
    // And allow RC to be PLACED on any empty cell orthogonally adjacent to YOUR corner
    // when your corner already has a track (regardless of who owns that track).
    if (cCell.track){
      const neigh = [
        {x:co.x+1, y:co.y},
        {x:co.x-1, y:co.y},
        {x:co.x,   y:co.y+1},
        {x:co.x,   y:co.y-1},
      ];
      for (const n of neigh){
        if(!within(n.x,n.y)) continue;
        const cc = state.board[n.y][n.x];
        if(!cc.track && cc.token==null){
          adj.set(n.x+','+n.y, {x:n.x, y:n.y});
        }
      }
    }
  }
  // Adjacent to tracks connected to my corner (ownership-agnostic)
  for(const p of net){
    [[p.x+1,p.y],[p.x-1,p.y],[p.x,p.y+1],[p.x,p.y-1]].forEach(([x,y])=>{
      if(!within(x,y)) return;
      const c = state.board[y][x];
      if(!c.track && c.token==null) adj.set(x+','+y,{x,y});
    });
  }

  // Adjacent to ANY of my owned tracks (not just corner-connected)
  for(const p of myOwned){
    [[p.x+1,p.y],[p.x-1,p.y],[p.x,p.y+1],[p.x,p.y-1]].forEach(([x,y])=>{
      if(!within(x,y)) return;
      const c = state.board[y][x];
      if(!c.track && c.token==null) adj.set(x+','+y,{x,y});
    });
  }

  // Adjacent to any of my tokens
  for(const t of myTokens){
    [[t.x+1,t.y],[t.x-1,t.y],[t.x,t.y+1],[t.x,t.y-1]].forEach(([x,y])=>{
      if(!within(x,y)) return;
      const c = state.board[y][x];
      if(!c.track && c.token==null) adj.set(x+','+y,{x,y});
    });
  }

  // If this is truly the first placement AND there are no RS/RE/RC or adjacency options,
  // restrict to the player's own corner; otherwise show whatever we gathered above.
  if (myOwned.length===0 && myTokens.length===0 && net.length===0 && adj.size===0){
    const c = cornerFor(pid);
    const cell = state.board[c.y][c.x];
    state.highlight = (!cell.track && !cell.token) ? [c] : [];
  } else {
    state.highlight = Array.from(adj.values());
  }
}

function baseDrawnType(card){
  if(card===TrackCard.RStraight) return TrackCard.Straight;
  if(card===TrackCard.RElbow)   return TrackCard.Elbow;
  if(card===TrackCard.RCross)   return TrackCard.Cross;
  return card;
}

function isTrackCard(card){
  return [TrackCard.Straight, TrackCard.Elbow, TrackCard.Cross,
          TrackCard.RStraight, TrackCard.RElbow, TrackCard.RCross].includes(card);
}

function checkForcePlace(){
  // === FORCE-DRAW RULE (anchor: RR_FORCE_DRAW) ===
  const P = currentPlayer();
  state.forcePlace = (!state.boardSaturated) && (P.skipCount >= 3);
  // If forced and no card in hand, allow drawing even if bottom locked
  if (state.forcePlace && !P.drawn) {
    P.drawLocked = false;   // unloack Draw
    P.drawUsed   = false;   // ← keep Draw "Ready" (not "Used")
  }
}

function checkForceElbow(P){
  // Set a persistent flag once the player has skipped 3 elbows.
  P.forceElbow = (!state.boardSaturated) && (P.elbowSkipCount >= 3);
}

  function placeMode(){
    if (state.boardSaturated){ setStatus('Board is full of tracks — placement disabled.'); toast('Place disabled (board full)'); return; }
    const P=currentPlayer();
    if(!P.drawn){ setStatus('Draw a card first.'); return; }
    state.phase='place'; state.subphase=null; computePlaceHighlights(); updateHUD(); setStatus('Placement: hover to preview, click to confirm. Rotate with Q/E.');
  }

  function bottomCard(){
    if (state.boardSaturated){ setStatus('Board is full of tracks — bottoming is disabled.'); toast('Bottom disabled (board full)'); return; }
    const P=currentPlayer();
    if(!P.drawn){ setStatus('Nothing to bottom.'); return; }
    pushHistory('Bottom');
    const bottomed = P.drawn;            // capture BEFORE clearing
    P.deck.draw.push(bottomed);          // push once
    P.drawn = null;                      // now clear the hand
    P.drawLocked = true;
    P.skipCount++;                   // ← increment on “bottom”
    if (bottomed === TrackCard.Elbow) {
      P.elbowSkipCount++;
      checkForceElbow(P);
    }

    state.phase='idle'; state.highlight=[]; state.hover=null;
    checkForcePlace();
    updateHUD();
    setStatus(state.forcePlace
      ? 'Maximum track cards skipped — you must Draw and Place.'
      : (P.forceElbow ? 'Bottomed. Elbows Skipped incremented (3/3: next Elbow must be placed).' 
                      : 'Bottomed. Drawing is locked until End Turn.'));    
    maybeAutoAdvance();
  }

  // Token flow (select-first; corner placement allowed if < TOKENS_MAX)
  function tokenMode(){
    const P=currentPlayer();
    if(P.tokenUsed){ setStatus('Token action already used this turn.'); return; }
    state.phase = 'token'; state.subphase='select'; state.highlight=[]; state.hover=null; state.tokenSelect=null;

    const myTokens = allTokensOf(P.id);
    const options = [...myTokens];
    const corner = cornerFor(P.id);
    const cCell = state.board[corner.y][corner.x];
    const myCount = countTokens(P.id);
    if(myCount < TOKENS_MAX && cCell.track && cCell.token==null){
      options.push(corner);
    }
    state.highlight = options;
    if(options.length===0){
      // No tokens on board and no corner placement available — do NOT auto-advance.
      setStatus('No tokens to apply an action to. Place a token at your corner first or Draw/Place tracks.');
      toast('No tokens to act on');
      // Keep Token Action available: exit token mode without consuming the action.
      state.phase='idle'; state.subphase=null; state.tokenSelect=null; state.highlight=[]; state.hover=null;
      render(); updateHUD();
      return;
    } 
    setStatus('Token: click a token to move OR click your corner to place a new token (may traverse opponents via connected pipes).');
    updateHUD();
  }

  // Rotation: meshed gears + hints (direction-correct; visible on all cells)
  function rollDie(){
    const P=currentPlayer();
    if(P.rollUsed){ setStatus('You have already rolled this turn.'); return; }
    pushHistory('Roll');
    const r = Math.floor(Math.random()*DIE_FACES.length); state.die = DIE_FACES[r];
    P.rollUsed = true;
    dieTag().textContent='Die: '+state.die; rollTag().textContent='Roll: Used';
    setStatus('Die rolled: '+state.die+'. Hints show per-cell rotation. Click Apply to rotate.');
    btn('applyBtn').disabled = (state.die==='X');
    render();
  }
  function thetaFor(face){ if(face==='CW90') return 90; if(face==='CCW90') return -90; if(face==='DEG180') return 180; return 0; }
  function mod360(a){ return (((a%360)+360)%360); }

  // === Rotation animation helpers (anchor: RR_ROTATE_ANIMS) ===
  // Define these BEFORE render() and applyRotation() (consts are not hoisted)
  const easeInOutQuad = t => (t<0.5 ? 2*t*t : -1 + (4 - 2*t) * t);
  function shortestArc(from,to){ // both degrees [0,360)
    let d = ((to - from + 540) % 360) - 180; // in (-180,180]
    return d;
  }

  function startRotateAnim(x,y, fromDeg, toDeg, dur=500){
    state.rotAnims.push({ x, y, from:fromDeg, to:toDeg, t0: performance.now(), dur });
    ensureAnimLoop();
  }

  // Drive frames while any animation is active (tile tweens or ghost tween)
  function hasActiveAnim(){
     return (state.rotAnims && state.rotAnims.length>0) || !!state.ghostRotAnim || !!state.gearSpinAnim;
  }
  function ensureAnimLoop(){
    if (state._animating) return;
    state._animating = true;
    const step = () => {
      if (hasActiveAnim()){
        render();
        requestAnimationFrame(step);
      } else {
        state._animating = false;
      }
    };
    requestAnimationFrame(step);
  }

  // Current animated angle for the ghost (falls back to previewRot)
  function ghostAngle(){
    const a = state.ghostRotAnim;
    if(!a) return state.previewRot || 0;
    const now = performance.now();
    const u = Math.min(1, (now - a.t0) / a.dur);
    const k = easeInOutQuad(u);
    const ang = a.from + shortestArc(a.from, a.to) * k;
    if (u >= 1) state.ghostRotAnim = null;   // auto-clear when finished
    return mod360(ang);
  }

  function startGearSpinPulse(baseDeg, dur){
    // baseDeg is the die’s base rotation: +90 (CW90), -90 (CCW90), or +180 (DEG180)
    state.gearSpinAnim = { base: baseDeg, t0: performance.now(), dur };
    ensureAnimLoop(); // reuse the existing RAF driver
  }

  function applyRotation(){
    if(!state.die || state.die==='X') return;
    pushHistory('Apply Rotation');
    const base = thetaFor(state.die);
    const APPLY_DUR = 650;                // keep in one place so tiles & gears match
    startGearSpinPulse(base, APPLY_DUR);  // spin gears only during this Apply tween

    let rotated=0;
    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
      const cell = state.board[y][x];
      const sign = ((x + y) % 2 === 0) ? 1 : -1;

      // 1) Commit the new gear offset for EVERY cell (track or not).
      if (state.gearOffset && state.gearOffset[y]) {
        const pending = sign * base; // same parity as tiles
        state.gearOffset[y][x] = mod360((state.gearOffset[y][x] || 0) + pending);
      }

      // 2) Only rotate/tween tiles that actually have tracks.
      if(!cell.track || cell.track==='Block') continue;
      const fromRot = cell.rot;
      const toRot   = mod360(cell.rot + sign*base);
      startRotateAnim(x,y, fromRot, toRot, APPLY_DUR);
      cell.rot = toRot; // commit; tween overlays visually
      rotated++;
      }
    }

    state.die=null; dieTag().textContent='Die: —'; btn('applyBtn').disabled = true;
    setStatus('Meshed rotation applied to '+rotated+' track cell(s).');
    onTopologyChanged();
    render();
    maybeAutoAdvance();
  }

  // Auto-advance heuristic
  function maybeAutoAdvance(){
    const P=currentPlayer();
    if(!P.drawUsed && !P.drawLocked && !P.drawn) return;
    if(P.drawn) return;
    if(!P.tokenUsed){
      const myTokens = allTokensOf(P.id);
      const corner = cornerFor(P.id);
      const cCell = state.board[corner.y][corner.x];
      const myCount = countTokens(P.id);
      let hasOption = false;
      if(myCount < TOKENS_MAX && cCell.track && cCell.token==null){ hasOption = true; }
      if(!hasOption){
        for(const t of myTokens){
          if(reachableFrom(t, P.id).length>0){ hasOption=true; break; }
        }
      }
      if(hasOption) return;
    }
    if(!P.rollUsed) return;
    setStatus('No actions remaining. Auto-advancing turn…');
    endTurn();
  }

  // Canvas interactions
  function toCell(px,py){
    const x = Math.floor((px - state.pad) / state.cell);
    const y = Math.floor((py - state.pad) / state.cell);
    return {x,y};
  }

  const canvasEl=UI.canvas();
  canvasEl.addEventListener('mousemove', (e)=>{
    const rect=canvasEl.getBoundingClientRect(); const {x,y}=toCell(e.clientX-rect.left, e.clientY-rect.top);
    if(x<0||y<0||x>=state.N||y>=state.N){ state.hover=null; render(); return; }
    state.hover={x,y};
    render();
  });
  canvasEl.addEventListener('click', (e)=>{
    if(state.turnAdvancing) return;
    const rect=canvasEl.getBoundingClientRect(); const {x,y}=toCell(e.clientX-rect.left, e.clientY-rect.top);
    if(x<0||y<0||x>=state.N||y>=state.N) return;

    // ----- Corner Fix: replace owner's corner with Cross (free) -----
    if (state.phase === 'cornerFix'){
      const P = currentPlayer();
      const c = state.fixCorner;             // set by startCornerFixCross(ownerId)
      if (!(c && x===c.x && y===c.y)){
        toast('Click your corner to apply the fix.');
        return;
      }
      const cell = state.board[y][x];
      pushHistory('Corner Fix');
      cell.track = 'Cross';
      cell.owner = P.id;
      cell.rot   = 0;                        // Cross is symmetric
      state.phase='idle'; state.highlight=[]; state.hover=null;
      state.fixOwner=null; state.fixCorner=null;
      if (typeof onTopologyChanged === 'function') onTopologyChanged();
      render(); updateHUD(); setStatus('Corner fixed: Cross placed.');
      return;
    }
    
    // Dead-Straight Fix click (one free replacement per turn)
    if (state.phase === 'deadFix' && state.subphase === 'pickDeadStraight'){
      const hit = state.highlight && state.highlight.some(h => h.x===x && h.y===y);
      if (hit){
        const cell = state.board[y][x];

        // Replace the Straight with a Cross; keep owner & token intact
        pushHistory('Dead-Straight Fix');
        state.deadFixDoneThisTurn = true;
        cell.track = 'Cross';
        cell.rot   = 0;   // Cross is symmetric
        // owner, token remain unchanged

        toast('Dead-Straight fixed: placed Cross.');

        // Clear subphase; resume normal turn
        state.phase = 'idle';
        state.subphase = null;
        state.highlight = [];
        state.hover = null;

        if (typeof onTopologyChanged === 'function') onTopologyChanged();
        render();
        updateHUD();
        setStatus('Dead-Straight fixed. Continue your turn.');
      }
      return; // consume click during deadFix phase
    }

    // PLACE phase
    if(state.phase==='place')
    {
      const P=currentPlayer(); 
      const cell=state.board[y][x];      

      // RS/RE: COMMIT rotation FIRST if we're clicking the selected tile
      if (state.subphase==='rotateExisting'
         && state.rotateFocus
         && state.rotateFocus.x===x
         && state.rotateFocus.y===y) {
        // Commit the preview orientation (no re-animate; user already saw the ghost at final angle)
        const toRot   = mod360((state.previewRot ?? cell.rot));
        cell.rot = toRot;
        P.deck.discard.push(P.drawn); P.drawn = null;
        P.skipCount = 0;
        state.forcePlace = false;     // placing satisfies the force rule
        state.subphase = null; state.rotateFocus = null; state.previewRot = 0;
        pulse(x,y);
        state.ghostRotAnim = null;
        state.phase='idle'; state.highlight=[]; state.hover=null;
        onTopologyChanged();
        render(); updateHUD(); setStatus('Rotation applied.'); maybeAutoAdvance();
        return;
      }      

      // === RS/RE: ENTER rotateExisting BEFORE legal-cell gating ===
      // Allow rotating ANY existing tile of the same base type (even on first turn).
      if (cell.track && (P.drawn===TrackCard.RStraight || P.drawn===TrackCard.RElbow)) {
        const base = baseDrawnType(P.drawn);
        if (cell.track === base) {
          state.subphase='rotateExisting';
          state.rotateFocus = {x,y, original: cell.rot};
          state.previewRot  = cell.rot;
          state.hover       = {x,y};
          state.highlight   = [{x,y}];   // show selection
          setStatus('Rotating '+base+': use Q/E to rotate; click again to confirm.');
          render(); updateHUD();
          return;
        }
      }
      // (commit handled above)
      // For everything else, we still require the cell to be legal
      const legal = state.highlight.some(h=>h.x===x&&h.y===y);
      if(!legal){ toast('Not a legal cell'); return; }

      // RC: Replaceable Cross — claim any existing track type on click
      if (P.drawn===TrackCard.RCross && cell.track){
        // (Rotation is irrelevant for Cross; keep current orientation or normalize to 0 if you prefer.)
        pushHistory('Place/Replace');
        cell.track = 'Cross';
        cell.owner = P.id;
        cell.rot = 0; // optional, Cross is symmetric
        // cell.rot = 0; // optional: normalize
        P.deck.discard.push(P.drawn); P.drawn = null;
        P.skipCount = 0;
        state.forcePlace = false;   // placing satisfies the force rule
        pulse(x,y);
        state.ghostRotAnim = null;
        state.phase='idle'; state.highlight=[]; state.hover=null; state.previewRot=0;
        onTopologyChanged();
        render(); updateHUD(); setStatus('Track replaced with Cross (ownership changed).'); maybeAutoAdvance();
        return;
      }

      // (RS/RE enter block moved above legal check)
      if(cell.track){ toast('Cell occupied'); return; }
      if(state.rotateFocus){ const rf=state.rotateFocus; const cc=state.board[rf.y][rf.x]; cc.rot=rf.original; state.rotateFocus=null; state.subphase=null; }
          const placedType = baseDrawnType(P.drawn);
          pushHistory('Place/Replace');
          cell.track=placedType; cell.rot=state.previewRot; cell.owner=P.id;
          P.deck.discard.push(P.drawn); P.drawn=null;
          P.skipCount = 0;
          state.forcePlace = false;   // placing satisfies the force rule
          if (placedType === TrackCard.Elbow) {
            P.elbowSkipCount = 0;
            P.forceElbow = false;
          }
          pulse(x,y);
          state.ghostRotAnim = null;  // clear any in-progress ghost tween
          state.phase='idle'; state.highlight=[]; state.hover=null; onTopologyChanged(); updateHUD(); setStatus('Placed. You cannot draw again this turn.');
          maybeAutoAdvance();
          return;
    }

    // TOKEN phase
    if(state.phase==='token'){
      const P=currentPlayer();
      if(state.subphase==='select'){
        const isMine = state.board[y][x].token===P.id;
        if(isMine){
          const from = {x,y};
          const moves = reachableFrom(from, P.id);
          if (moves.length===0) {
            // Stay on this player's turn: warn, and keep selection active.
            setStatus('That token is stuck (no connected destinations). Choose a different token or click End Turn.');
            toast('Token cannot move');

            // Re-highlight only tokens that CAN move (plus corner, if eligible).
            const movable = allTokensOf(P.id).filter(t => reachableFrom(t, P.id).length > 0);
            const corner = cornerFor(P.id);
            const cCell  = state.board[corner.y][corner.x];
            const canPlace = countTokens(P.id) < TOKENS_MAX && cCell.track && cCell.token == null;

            state.tokenSelect = null;               // remain in subphase='select'
            state.highlight   = canPlace ? [...movable, corner] : movable;
            render();
            return;
          }          
          state.tokenSelect = from; state.highlight = moves; state.subphase='target';
          setStatus('Token: choose a connected destination (pipes may traverse opponents).'); render(); return;
        }
        const corner = cornerFor(P.id);
        if(corner.x===x && corner.y===y){
          const cCell = state.board[corner.y][corner.x];
          const myCount = countTokens(P.id);
          if(myCount >= TOKENS_MAX){ toast('You already have the maximum of 3 tokens.'); return; }
          if(!(cCell.track && (cCell.token==null))){ toast('Corner must have a track and be open.'); return; }
          pushHistory('Token: place');
          cCell.token = P.id; state.players[P.id].tokens = myCount+1;
          P.tokenUsed = true; tokenTag().textContent='Token: Used'; btn('tokenBtn').disabled = true;
          state.phase='idle'; state.subphase=null; state.highlight=[]; state.tokenSelect=null; setStatus('New token placed at your corner.'); render(); updateHUD();
          maybeAutoAdvance();
          return;
        }
        toast('Select your token to move, or your open corner to place a new one.');
      } else if(state.subphase==='target'){
        const legal = state.highlight.some(h=>h.x===x&&h.y===y);
        if(!legal){ toast('Pick a connected destination.'); return; }
        const from = state.tokenSelect;
        // Scoring: if placed onto an opponent's corner, increment score and remove the token
        (() => {
              const P = currentPlayer();
              const oppId = opponentCornerAt(x,y,P.id);
              const destHasOwner = (oppId != null && state.board[y][x].token === oppId);
              pushHistory('Token: move');
              // Remove token from source
              state.board[from.y][from.x].token = null;
              // Only place our token if destination doesn’t already hold its owner’s token
              if (!destHasOwner) state.board[y][x].token = P.id;
              // Scoring: arrival on an opponent corner
              if (oppId != null){
                if (!P.reached) P.reached = new Set();
                const oppName = PLAYERS[oppId].name;
                P.reached.add(oppName);
                // If we placed our token, remove it after scoring; otherwise leave owner token as-is
                if (!destHasOwner) state.board[y][x].token = null;
                setStatus(P.name + ' scored at ' + oppName + "'s corner!");
              } else {
                setStatus('Token moved.');
              }
        })();

        currentPlayer().tokenUsed = true; tokenTag().textContent='Token: Used'; btn('tokenBtn').disabled = true;
              state.phase='idle'; state.subphase=null; state.highlight=[]; state.tokenSelect=null; render(); updateHUD();
              maybeAutoAdvance();
              return;
      }
    }
  });

  // === ROTATE PREVIEW KEYS (anchor: RR_ROTATE_KEYS) ===
  window.addEventListener('keydown', (e)=>{
    if (state.phase !== 'place') return;
    const k = e.key.toLowerCase();
    if (k !== 'q' && k !== 'e') return;

    // Where is the mouse?
    const h = state.hover;
    const hoveringEmpty = !!(h && within(h.x, h.y) && (()=>{
      const c = state.board[h.y][h.x];
      return !c.track && c.token == null;
    })());

    // Allow rotation if:
    // 1) We are actively rotating an existing tile (RS/RE after click), OR
    // 2) We are hovering an EMPTY cell (previewing a new placement)
    if (!(state.subphase === 'rotateExisting' || hoveringEmpty)) {
      // Optional: UI nudge when RS/RE is drawn and you're over an occupied cell
      // const d = currentPlayer().drawn;
      // if (d===TrackCard.RStraight || d===TrackCard.RElbow) setStatus('Click a track to rotate');
      return;
    }

    const stepDeg = (k==='q' ? -90 : 90);      // Q=CCW, E=CW
    const from = ghostAngle();                 // current animated angle (if mid-tween)
    const to   = mod360(from + stepDeg);
    state.previewRot   = to;                   // target angle
    state.ghostRotAnim = { from, to, t0: performance.now(), dur: 400 };
    ensureAnimLoop();
    render();                                  // draw first frame immediately    
  });  

  // Wire buttons
  btn('newGameBtn').addEventListener('click', newGame);
  btn('drawBtn').addEventListener('click', drawCard);
  btn('placeBtn').addEventListener('click', placeMode);
  btn('bottomBtn').addEventListener('click', bottomCard);
  const endTurnBtn = document.getElementById('endTurnBtn');
  endTurnBtn.addEventListener('click', endTurn);
  const overrideBtn = document.getElementById('overrideBtn');
  overrideBtn.addEventListener('click', ()=>{
    state.forcePlace = false;
    endTurnBtn.disabled = false;
    overrideBtn.style.display = 'none';
    toast('Override used: End Turn enabled.');
  });
  btn('tokenBtn').addEventListener('click', tokenMode);
  btn('rollBtn').addEventListener('click', rollDie);
  btn('applyBtn').addEventListener('click', applyRotation);
  UI.vizEdges().addEventListener('change', render);

  btn('saveBtn').addEventListener('click', saveGame);
  btn('loadBtn').addEventListener('click', () => document.getElementById('loadFile').click());
  document.getElementById('loadFile').addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) loadFromFile(f);
    e.target.value = ''; // reset so the same file can be chosen again later
  });

  // Undo/Redo buttons
  document.getElementById('undoGlobalBtn').addEventListener('click', undoGlobal);
  document.getElementById('redoGlobalBtn').addEventListener('click', redoGlobal);
  document.getElementById('undoTurnBtn').addEventListener('click', undoTurn);
  document.getElementById('redoTurnBtn').addEventListener('click', redoTurn);

  function renderCornerScoreTable(){
    const tb = document.querySelector('#cornerScoreTable tbody');
    if (!tb || !state || !state.players) return;

    const N = state.N;

    // Map pocket -> text with coordinates based on current board size
    const quadText = (pocket) => {
      switch (pocket) {
        case 'NW': return 'NW (0,0)';
        case 'NE': return `NE (${N-1},0)`;
        case 'SE': return `SE (${N-1},${N-1})`;
        case 'SW': return `SW (0,${N-1})`;
        default:   return pocket || '—';
      }
    };

    for (const p of state.players) {
      const pid = p.id;
      // reached is stored as Set of player names (e.g., 'Red', 'Green')
      const reachedSet = p.reached
        ? (Array.isArray(p.reached) ? new Set(p.reached) : p.reached)
        : new Set();

      // Show same bracket letters as the top Score tag: [R, G, ...]
      const letters = reachedSet.size
        ? Array.from(reachedSet).map(n => String(n)[0]).join(', ')
        : '';

      const scoreStr = `${reachedSet.size}/3${letters ? ` [${letters}]` : ''}`;

      const qEl = document.getElementById(`quad-${pid}`);
      const sEl = document.getElementById(`score-${pid}`);
      if (qEl) qEl.textContent = quadText(p.pocket);
      if (sEl) sEl.textContent = scoreStr;
    }
  }

    // Start/stop a requestAnimationFrame loop that advances the global gear angle
  function startGearSpin(){
    if (!GEAR_SPIN_ENABLED) return;
    if (state._spinRAF) cancelAnimationFrame(state._spinRAF);
    state._lastSpinT = performance.now();

    const step = (t) => {
      const dt = t - state._lastSpinT;                // milliseconds
      state._lastSpinT = t;

      // degrees per millisecond = RPM * 360 / 60000
      const degPerMs = (GEAR_SPIN_RPM * 360) / 60000;
      state.gearSpinDeg = (state.gearSpinDeg + degPerMs * dt) % 360;

      // Repaint only if the image is ready (avoids useless work before onload)
      if (gearReady) render();

      state._spinRAF = requestAnimationFrame(step);
    };
    state._spinRAF = requestAnimationFrame(step);
  }

  function stopGearSpin(){
    if (state._spinRAF) cancelAnimationFrame(state._spinRAF);
    state._spinRAF = null;
  }

  function updateHUD(){
    renderCornerScoreTable();

    const P=currentPlayer();

    if (state.phase === 'deadFix'){
      // Keep the messaging visible while the selection is up
      drawTag().textContent = state.boardSaturated
        ? 'Draw: Locked (Dead-Straight Fix)'
        : 'Draw: Ready (Dead-Straight Fix)';
      setStatus('Dead-Straight Fix: replace ONE highlighted Straight with a Cross (free).');
      render();
      updateUndoButtons();
      return; // ← prevent later HUD paths from overwriting this status
    }

    if (state.boardSaturated){
      // Tags
      drawTag().textContent = state.phase === 'deadFix'
        ? 'Draw: Locked (Dead-Straight Fix)'
        : 'Draw: Locked (Board Full)';

      // Basic tags that should still reflect current state
      turnTag().textContent  = 'Turn: ' + currentPlayer().name + ' (' + currentPlayer().pocket + ')';
      phaseTag().textContent = 'Phase: ' + state.phase;
      dieTag().textContent   = 'Die: ' + (state.die || '—');
      rollTag().textContent  = 'Roll: ' + (currentPlayer().rollUsed ? 'Used' : 'Ready');
      tokenTag().textContent = 'Token: ' + (currentPlayer().tokenUsed ? 'Used' : 'Ready');

      // Score tag MUST keep updating even when board is full
      (function(){
        const el = document.getElementById('scoreTag');
        if(!el) return;
        const P = currentPlayer();
        const reached = P.reached ? P.reached : new Set();
        const list = (reached && reached.size) ? Array.from(reached).map(n=>n[0]).join(', ') : '';
        el.textContent = 'Score: ' + (reached ? reached.size : 0) + '/3' + (list ? (' ['+list+']') : '');
      })();

      // Buttons
      btn('drawBtn').disabled   = true;
      btn('placeBtn').disabled  = true;
      btn('bottomBtn').disabled = true;
      endTurnBtn.disabled = false;
      overrideBtn.style.display = 'none';
      btn('tokenBtn').disabled = !!currentPlayer().tokenUsed;
      btn('rollBtn').disabled  = !!currentPlayer().rollUsed;
      btn('applyBtn').disabled = !(state.die && state.die!=='X');

      render();
      updateUndoButtons();

      return; // keep the early-out
    }

    // Corner Fix HUD lock: show a RED warning and disable all actions until the free Cross is applied
    if (state.phase === 'cornerFix'){
      // Make sure the tags reflect the current subphase
      turnTag().textContent='Turn: '+P.name+' ('+P.pocket+')';
      phaseTag().textContent='Phase: cornerFix';
      setStatus('<span class="warn">Your corner is sealed. Click on your corner track to replace it with a cross track.</span>');
      drawTag().textContent = 'Draw: Locked (Corner Fix)';
      btn('drawBtn').disabled   = true;
      btn('placeBtn').disabled  = true;
      btn('bottomBtn').disabled = true;
      btn('tokenBtn').disabled  = true;
      btn('rollBtn').disabled   = true;
      btn('applyBtn').disabled  = true;
      endTurnBtn.disabled = true;
      overrideBtn.style.display = 'none';

      render();
      updateUndoButtons();

      return;
    }

    if (P.drawn && (P.drawn===TrackCard.Straight || P.drawn===TrackCard.Elbow ||
        P.drawn===TrackCard.Cross || P.drawn===TrackCard.RStraight ||
        P.drawn===TrackCard.RElbow || P.drawn===TrackCard.RCross)) {
      setStatus(`Skipped: ${P.skipCount}/3`);
    }

    turnTag().textContent='Turn: '+P.name+' ('+P.pocket+')';
    phaseTag().textContent='Phase: '+state.phase;
    drawnTag().textContent='Card: '+(P.drawn || '—');
    dieTag().textContent='Die: '+(state.die || '—');
    drawTag().textContent = 'Draw: ' + (
      (state.forcePlace && !P.drawn) ? 'Ready (Forced)' :
      (P.drawLocked ? 'Locked' : (P.drawUsed ? 'Used' : 'Ready'))
    );    
    rollTag().textContent='Roll: '+(P.rollUsed ? 'Used' : 'Ready');
    // Deterministic draw gating; allow draw during forced-draw even if previously locked/used
    const _forcedDrawOK = state.forcePlace && !P.drawn;
    btn('drawBtn').disabled = !!P.drawn || ((P.drawLocked || P.drawUsed) && !_forcedDrawOK);    // Enable Place only when a track card is in hand
    btn('placeBtn').disabled = !P.drawn;    

    // Disable Bottom when there's nothing to bottom, or when maximum-skips forces a draw/place
    btn('bottomBtn').disabled = !P.drawn || state.forcePlace;    
    btn('applyBtn').disabled = !(state.die && state.die!=='X');
    btn('tokenBtn').disabled = !!P.tokenUsed;
    btn('rollBtn').disabled = !!P.rollUsed;

    // If the player has hit the elbow threshold and is currently holding an Elbow, force placement:
    if (P.forceElbow && P.drawn === TrackCard.Elbow) {
      btn('bottomBtn').disabled = true;
      endTurnBtn.disabled = true;
      overrideBtn.style.display = 'none'; // no bypass for elbow forcing
      setStatus('Elbows Skipped: 3/3 — you must place this Elbow now.');
    }

    tokenTag().textContent = 'Token: ' + (P.tokenUsed ? 'Used' : 'Ready');
    document.getElementById('tokenCount').textContent = 'Token: ' + ((state.players[P.id] && state.players[P.id].tokens) ? state.players[P.id].tokens : 0) + '/' + TOKENS_MAX;

    (function(){
      const el = document.getElementById('skippedTag');
      if(!el){ return; }
      const P = currentPlayer();
      const skipCount = (P && P.skipCount) ? P.skipCount : 0;
      el.textContent = 'Skipped: ' + skipCount + '/3';
      // Visual warning when max skips reached
      if (skipCount >= 3) {
        el.classList.add('warn');   // <- requires CSS for .warn
        el.textContent += '  ⚠ Maximum skipped';
      } else {
        el.classList.remove('warn');
      }
      // Enforce End Turn restriction when skipCount ≥ 3
      if (state.forcePlace) {
        endTurnBtn.disabled = true;
        // overrideBtn.style.display = 'inline-block';
        // Only show Override if there IS a track in hand; otherwise force Draw first
        overrideBtn.style.display = P.drawn ? 'inline-block' : 'none';

        if (!P.drawn) {
          setStatus('Maximum track cards skipped — you must Draw and Place before ending your turn (or use Override).');
        } else {
          setStatus('Maximum track cards skipped — you must Place your drawn track (or use Override).');
        }
      } else {
        endTurnBtn.disabled = false;
        overrideBtn.style.display = 'none';
      }
    })();

    (function(){
      const el = document.getElementById('elbowSkippedTag');
      if(!el){ return; }
      const P = currentPlayer();
      const ecount = (P && P.elbowSkipCount) ? P.elbowSkipCount : 0;
      el.textContent = 'Elbows Skipped: ' + ecount + '/3';
      if (ecount >= 3) {
        el.classList.add('warn');
        el.textContent += '  ⚠ Next Elbow must be placed';
      } else {
        el.classList.remove('warn');
      }
    })();    

    (function(){
      const el = document.getElementById('scoreTag');
      if(!el){ return; }
      const reached = P.reached ? P.reached : new Set();
      const list = (reached && reached.size) ? Array.from(reached).map(n=>n[0]).join(', ') : '';
      el.textContent = 'Score: ' + (reached ? reached.size : 0) + '/3' + (list?(' ['+list+']'):'');
    })();
    render();
  }

  function render(){
    const N=state.N, cell=state.cell, pad=state.pad;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle=COLORS.bg; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.translate(pad,pad);
    const size=cell*N;
    const now = performance.now();
    state._frameNow = now;  // unify timing across all per-frame animations
    // grid
    ctx.strokeStyle=COLORS.grid; ctx.lineWidth=1;
    ctx.strokeRect(0,0,size,size);
    for(let i=1;i<N;i++){ ctx.beginPath(); ctx.moveTo(i*cell,0); ctx.lineTo(i*cell,size); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,i*cell); ctx.lineTo(size,i*cell); ctx.stroke(); }
    // gears (background)
    for(let y=0;y<N;y++) for(let x=0;x<N;x++){ drawGear(x,y); }
    // corner color badges
    drawCornerBadges();

    // tracks (with rotation tween overlay)
    // prune finished tweens
    state.rotAnims = state.rotAnims.filter(a => (now - a.t0) <= (a.dur + 24));
    const rotMap = new Map();
    for(const a of state.rotAnims){
      const u = Math.min(1, (now - a.t0)/a.dur);
      const k = easeInOutQuad(u);
      const rot = a.from + shortestArc(a.from, a.to) * k;
      rotMap.set(a.x+','+a.y, rot);
    }
    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
        const c=state.board[y][x]; if(!c.track) continue;
        const key = x+','+y;
        if(rotMap.has(key)){
          drawTrack(c.track, ((rotMap.get(key)%360)+360)%360, x,y, 1);
        }else{
          drawTrack(c.track, c.rot, x,y, 1);
        }
      }
    }    

    // tokens
    for(let y=0;y<N;y++) for(let x=0;x<N;x++){ const c=state.board[y][x]; if(c.token!=null) drawToken(c.token,x,y); }
    // connection edges
    if(UI.vizEdges().checked){ drawEdges(); }
    // rotation hints
    if(state.die && state.die!=='X'){ drawRotationHints(); }
    // center marker
    const cc=Math.floor(N/2); const cx=cc*cell+cell/2, cy=cc*cell+cell/2;
    ctx.strokeStyle=COLORS.hilite; ctx.globalAlpha=0.5; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy, cell*0.42, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
    // turn corner highlight
    drawTurnCornerHighlight();
    // placement highlights
    ctx.strokeStyle=COLORS.hilite; ctx.lineWidth=3;
    state.highlight.forEach(p=>{ ctx.strokeRect(p.x*cell+3, p.y*cell+3, cell-6, cell-6); });
    // stronger "active" outline while rotating an existing tile with RS/RE
    if(state.phase==='place' && state.subphase==='rotateExisting' && state.rotateFocus){
      const rf = state.rotateFocus;
      ctx.save();
      ctx.lineWidth = 5;
      ctx.setLineDash([6,4]);
      ctx.strokeStyle = '#ffcc00';
      ctx.strokeRect(rf.x*cell+2, rf.y*cell+2, cell-4, cell-4);
      ctx.restore();
    }    
    // ghost
    const P=currentPlayer();
    if(state.phase==='place' && state.subphase==='rotateExisting' && state.rotateFocus) {
      const rf = state.rotateFocus; const c = state.board[rf.y][rf.x];
      drawTrack(c.track, ghostAngle(), rf.x, rf.y, 0.9);    
    }
    else if(state.phase==='place' && state.hover && P.drawn){
      const {x,y}=state.hover;
      const legal = state.highlight.some(h=>h.x===x && h.y===y);
      // Follow-cursor ghost everywhere; greenish when legal, faint red tint when illegal
      drawTrack(baseDrawnType(P.drawn), ghostAngle(), x, y, legal ? 0.55 : 0.35);
      if(!legal){
        ctx.save();
        ctx.strokeStyle = '#e03';
        ctx.lineWidth = 3;
        ctx.setLineDash([6,4]);
        ctx.strokeRect(x*cell+4, y*cell+4, cell-8, cell-8);
        ctx.restore();
      }
    }
    // Token ghost (during Token actions) — same visual rules
    else if(state.phase==='token' && state.hover){
      const {x,y}=state.hover;
      let legal=false;
      if(state.subphase==='target'){
        legal = state.highlight.some(h=>h.x===x && h.y===y);
      }else if(state.subphase==='select'){
        const P=currentPlayer();
        const corner = cornerFor(P.id);
        const cCell  = state.board[corner.y][corner.x];
        const myCount = countTokens(P.id);
        legal = (x===corner.x && y===corner.y && myCount < TOKENS_MAX && cCell.track && cCell.token==null);
      }
      drawToken(currentPlayer().id, x, y, legal ? 0.55 : 0.35);
      if(!legal){
        ctx.save();
        ctx.strokeStyle = '#e03';
        ctx.lineWidth = 3;
        ctx.setLineDash([6,4]);
        ctx.strokeRect(x*cell+4, y*cell+4, cell-8, cell-8);
        ctx.restore();
      }
    }
    // --- end-of-frame cleanup for gear tween ---
    if (state.gearSpinAnim) {
      const a = state.gearSpinAnim;
      if ((performance.now() - a.t0) >= a.dur) {
        state.gearSpinAnim = null;
      }
    }
    // Outer restore for the whole frame   
    ctx.restore();
  }

  // === CORNER COLOR BADGES (anchor: RR_CORNER_BADGES) ===
  // Draw a small right-triangle in each player's corner using their color.
  function drawCornerBadges(){
    const cell = state.cell;
    const m = 3;                                // inset margin
    const t = Math.max(8, Math.floor(cell * 0.25)); // triangle leg length
    ctx.save();
    ctx.globalAlpha = 0.85;
    for (const P of PLAYERS){
      const c = cornerFor(P.id);
      const px = c.x * cell, py = c.y * cell;
      ctx.beginPath();
      switch (P.pocket){
        case 'NW':
          ctx.moveTo(px + m,         py + m);
          ctx.lineTo(px + m + t,     py + m);
          ctx.lineTo(px + m,         py + m + t);
          break;
        case 'NE':
          ctx.moveTo(px + cell - m,      py + m);
          ctx.lineTo(px + cell - m - t,  py + m);
          ctx.lineTo(px + cell - m,      py + m + t);
          break;
        case 'SE':
          ctx.moveTo(px + cell - m,      py + cell - m);
          ctx.lineTo(px + cell - m - t,  py + cell - m);
          ctx.lineTo(px + cell - m,      py + cell - m - t);
          break;
        // 'SW'
        default:
          ctx.moveTo(px + m,         py + cell - m);
          ctx.lineTo(px + m + t,     py + cell - m);
          ctx.lineTo(px + m,         py + cell - m - t);
          break;
      }
      ctx.closePath();
      ctx.fillStyle = P.color;
      ctx.fill();
    }
    ctx.restore();
  }

  function drawTurnCornerHighlight(){
    const P=currentPlayer();
    const corner = cornerFor(P.id);
    const cell=state.cell;
    ctx.save();
    ctx.lineWidth = 4;
    ctx.strokeStyle = P.color;
    ctx.globalAlpha = 0.95;
    ctx.strokeRect(corner.x*cell+2, corner.y*cell+2, cell-4, cell-4);
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = P.color;
    ctx.fillRect(corner.x*cell+3, corner.y*cell+3, cell-6, cell-6);
    ctx.restore();
  }

  function drawEdges(){
    const cell=state.cell;
    ctx.save();
    ctx.strokeStyle=COLORS.edge;
    ctx.lineWidth=2;
    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
        const a=state.board[y][x];
        if(!a.track || a.track==='Block') continue;
        for(const [dx,dy] of rotatedOpenings(a)){
          const nx=x+dx, ny=y+dy; if(!within(nx,ny)) continue;
          const b=state.board[ny][nx];
          if(!b.track || b.track==='Block') continue;
          if(hasReciprocal(a,b,dx,dy)){
            const x1=(x+0.5)*cell, y1=(y+0.5)*cell;
            const x2=(nx+0.5)*cell, y2=(ny+0.5)*cell;
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
          }
        }
      }
    }
    ctx.restore();
  }

  // function drawGear(x,y){
  //   const cell=state.cell;
  //   const cx=x*cell+cell/2, cy=y*cell+cell/2;
  //   ctx.strokeStyle=COLORS.grid; ctx.lineWidth=1; ctx.strokeRect(x*cell, y*cell, cell, cell);
  //   ctx.strokeStyle=COLORS.grid; ctx.lineWidth=2;
  //   ctx.beginPath(); ctx.arc(cx, cy, cell/2-4, 0, Math.PI*2); ctx.stroke();
  //   ctx.fillStyle='#202a3d';
  //   ctx.beginPath(); ctx.arc(cx, cy, cell/2-7, 0, Math.PI*2); ctx.fill();
  // }

  // Draw a background gear from the external SVG.
  // Alternates orientation by cell parity: even -> 0°, odd -> 90°.
  function drawGear(x, y){
    const cell = state.cell;
    const cx   = x*cell + cell/2;
    const cy   = y*cell + cell/2;

    // Draw a faint cell border (keeps your existing grid vibe)
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth   = 1;
    ctx.strokeRect(x*cell, y*cell, cell, cell);

    // If the SVG isn’t ready, keep the old fallback so nothing looks broken
    if (!gearReady || !gearImg.naturalWidth || !gearImg.naturalHeight){
      ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(cx, cy, cell/2-4, 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle = '#202a3d';
      ctx.beginPath(); ctx.arc(cx, cy, cell/2-7, 0, Math.PI*2); ctx.fill();
      return;
    }

    // Target outer diameter (so neighboring centers = outer diameter => visual meshing)
    const targetOuter = cell * GEAR_OUTER_FIT;

    // Scale uniformly based on the smaller natural dimension of the SVG
    const natW = gearImg.naturalWidth;
    const natH = gearImg.naturalHeight;
    const natMin = Math.min(natW, natH);
    const k = targetOuter / natMin;

    // Base mesh orientation (0°/90°) + persistent per-cell offset + transient tween to it
    const baseDeg = ((x + y) % 2 === 0) ? 0 : 90;
    const offset  = (state.gearOffset && state.gearOffset[y] && state.gearOffset[y][x]) || 0;

    let animAdj = 0; // delta applied on top of the committed offset (old→new interpolation)
    const a = state.gearSpinAnim;
    if (a) {
      const now = state._frameNow || performance.now();
      const u   = Math.min(1, (now - a.t0) / a.dur);
      const k   = easeInOutQuad(u);            // same easing as tile tween
      const pending = ((x + y) % 2 === 0) ? (+a.base) : (-a.base); // signed per-cell delta
      // Show: newOffset - pending*(1-k)  →  starts at old, lands at new without snapping
      animAdj = -pending * (1 - k);
    }
    const rotDeg = baseDeg + offset + animAdj;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotDeg * Math.PI / 180);
    ctx.globalAlpha = 1.0; // feel free to drop to ~0.9 if you want tracks to pop more

    // Render with uniform scale; keep the original aspect ratio
    const drawW = natW * k;
    const drawH = natH * k;
    ctx.drawImage(gearImg, -drawW/2, -drawH/2, drawW, drawH);
    ctx.restore();
  }

  function drawTrack(type, rot, x,y, alpha){
    const cell=state.cell; const cx=x*cell+cell/2, cy=y*cell+cell/2; const r=cell/2-8;
    ctx.save(); ctx.globalAlpha=alpha; ctx.translate(cx,cy); ctx.rotate(rot*Math.PI/180);
    if(type==='Block'){
      ctx.fillStyle='#434b63'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=COLORS.grid; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
    } else {
      ctx.fillStyle=COLORS.track; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=COLORS.slot; ctx.lineWidth=6;
      if(type==='Straight'){ ctx.beginPath(); ctx.moveTo(-r*0.85,0); ctx.lineTo(r*0.85,0); ctx.stroke(); }
      if(type==='Elbow'){ ctx.beginPath(); ctx.moveTo(0,-r*0.85); ctx.lineTo(0,0); ctx.lineTo(r*0.85,0); ctx.stroke(); }
      if(type==='Cross'){
        ctx.beginPath(); ctx.moveTo(-r*0.85,0); ctx.lineTo(r*0.85,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,-r*0.85); ctx.lineTo(0,r*0.85); ctx.stroke();
      }
    }
    ctx.restore();
  }

  // --- Rotation hints overlay (direction-correct; visible on all cells) ---
  function drawRotationHints(){
    const base = thetaFor(state.die);
    if(base===0) return;
    ctx.save();
    ctx.lineWidth = 3;

    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
        const cellData = state.board[y][x];
        const sign = ((x + y) % 2 === 0) ? 1 : -1;
        const theta = sign * base;
        const cx = x*state.cell + state.cell/2;
        const cy = y*state.cell + state.cell/2;
        const r = state.cell*0.28;
        const sweep = Math.abs(theta) * Math.PI / 180;
        const cw = theta > 0;
        const isTrack = !!cellData.track && cellData.track!=='Block';
        ctx.globalAlpha = isTrack ? 0.58 : 0.22;
        ctx.strokeStyle = COLORS.hint;
        drawArrowArcDir(cx, cy, r, sweep, cw);
      }
    }
    ctx.restore();
  }

  function drawArrowArcDir(cx, cy, r, sweep, cw){
    const start = -Math.PI/2;
    const end = cw ? (start + sweep) : (start - sweep);
    const anticlockwise = !cw;
    ctx.beginPath();
    ctx.arc(cx, cy, r, start, end, anticlockwise);
    ctx.stroke();
    // Arrowhead at end
    const ax = cx + r*Math.cos(end);
    const ay = cy + r*Math.sin(end);
    const t = end + (cw ? Math.PI/2 : -Math.PI/2);
    const len = 8;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - len*Math.cos(t - 0.4), ay - len*Math.sin(t - 0.4));
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - len*Math.cos(t + 0.4), ay - len*Math.sin(t + 0.4));
    ctx.stroke();
  }

  function drawToken(pid,x,y, alphaOverride){
    const color = PLAYERS[pid].color; const cell=state.cell;
    const cx=x*cell+cell/2, cy=y*cell+cell/2; const r=cell/2-12;
    const a = (alphaOverride==null ? 0.75 : alphaOverride);
    ctx.fillStyle=color; ctx.globalAlpha=a; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
  }

  function pulse(x,y){
    const cell=state.cell; const pad=state.pad; const cx=pad+(x+0.5)*cell, cy=pad+(y+0.5)*cell; const r0=6, r1=26;
    const start=performance.now();
    function step(t){
      const k=Math.min(1,(t-start)/280);
      ctx.save();
      ctx.strokeStyle=COLORS.hilite; ctx.lineWidth=3; ctx.globalAlpha=1-k;
      ctx.beginPath(); ctx.arc(cx, cy, r0 + (r1-r0)*k, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
      if(k<1){ requestAnimationFrame(step); } else { render(); }
    }
    requestAnimationFrame(step);
  }

  // initial
  resize();
  startTurn();
  setStatus('New Game → Draw → Place. First placement is your corner.');
})();</script>
<script>
document.addEventListener('DOMContentLoaded', function(){
  try { if (typeof newGame === 'function') newGame(); } catch(e){ console.error(e); }
});
</script>
</body>
</html>