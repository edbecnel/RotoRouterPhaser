<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RotoRouter</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: #0f1115; color: #e6e6e6; }
    .app { display: grid; grid-template-columns: 360px 1fr; height: 100%; }
    .sidebar { padding: 14px 16px; border-right: 1px solid #222835; background: #121723; overflow: auto; }
    .sidebar h1 { font-size: 18px; margin: 0 0 8px; }
    .sidebar h2 { font-size: 14px; margin: 16px 0 8px; color: #b7c1ff; }
    .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; flex-wrap: wrap; }
    .row.nowrap { flex-wrap: nowrap; }
    .nowrap { white-space: nowrap; }
    .btn { padding: 8px 10px; background: #1b2233; color: #fff; border: 1px solid #30384f; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .tag { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #2a3249; background: #0f1626; }
    .panel { border: 1px solid #1f2636; padding: 10px; border-radius: 12px; background: #0d1220; }
    .muted { color: #9da6b8; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .small { font-size: 12px; }
    .legend { display: grid; grid-template-columns: auto 1fr; gap: 6px 10px; align-items: center; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; border: 1px solid #fff4; }
    .inactiveRow { opacity: .4; filter: grayscale(.2); }
    /* Prevent standings entries from breaking across lines */
    .standLine { white-space: nowrap; }
    .standText { margin-left: 6px; }
    /* AI badge pill */
    .aiBadge{
      display:inline-block;
      font-size:11px;
      line-height:1;
      padding:3px 6px;
      margin-left:6px;
      border-radius:10px;
      background:#222;
      color:#fff;
    }
    /* Keep the Corners table lines on one row */
    .scoreTable td { white-space: nowrap; }
    /* Prevent odd breaks inside bolded labels in the status line */
    #status b { white-space: nowrap; }
    @media (prefers-color-scheme: dark){
      .aiBadge{ background:#4b5563; color:#fff; }
    }
    canvas { display: block; }
    .toast { position: fixed; left: 380px; bottom: 16px; background: #182031; border: 1px solid #2b3650; padding: 10px 14px; border-radius: 10px; pointer-events: none; opacity: 0; transition: opacity .18s ease; }
    .toast.show { opacity: 1; }
    label.toggle { display:flex; align-items:center; gap:8px; font-size:12px; user-select:none; }
    .warn {
      color: #c00;       /* red text */
      font-weight: 600;  /* bold */
    }
    .ok { color:#28d07a; font-weight:700; }
    .caution { color:#ffd166; font-weight:700; } /* yellow status text */
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>RotoRouter</h1>
      <div class="panel">
        <div class="row"><span class="tag" id="turnTag">Turn: —</span><span class="tag" id="phaseTag">Phase: —</span></div>
        <div class="row small muted" id="status">New Game → Draw → Place. First placement is your corner.</div>
      </div>
      <h2>Standings</h2>
      <div class="panel small" id="standingsPanel">
        <div id="standingsTop" class="row small"></div>
      </div>
      <h2>Setup</h2>
      <div class="grid">
        <label class="small muted">Board Size
          <select id="boardSize">
            <option value="9">9×9</option>
            <option value="7">7×7</option>
          </select>
        </label>
      </div>
      <div class="row">
        <button class="btn" id="newGameBtn">New Game</button>
        <button class="btn" id="returnMenuBtn">Main Menu</button>
        <!-- Shown only when a single AI player remains; resumes play once -->
        <button class="btn" id="continueBtn" style="display:none;">Continue</button>        
      </div>
      <h2>Actions</h2>
      <div class="panel">
        <div class="row"><b>Track</b></div>
        <div class="row">
          <button class="btn" id="drawBtn">Draw</button>
          <span id="drawnCard" class="tag">Card: —</span>
          <span id="drawTag" class="tag">Draw: Ready</span>
        </div>
        <div class="row">
          <button class="btn" id="placeBtn">Place</button>
          <button class="btn" id="bottomBtn">Bottom</button>
        </div>
        <div class="row">
          <button class="btn" id="rotateCCWBtn">⟲ CCW</button>
          <button class="btn" id="rotateCWBtn">⟳ CW</button>
          <span id="rotateTag" class="tag">Rotate: —</span>
        </div>
        <div class="row small muted">
          <span>On touch devices: tap a legal cell to enter <b>rotation mode</b>, use the buttons (or Q/E) to rotate, then tap again to place.</span>
        </div>
        <div class="row small muted">
          <span>Hover shows a <b>ghost</b>. Tap/click a legal cell to rotate it first, then tap/click again to place. Rotate with Q/E or the buttons.</span>
        </div>
        <hr style="border-color:#1f2636"/>
        <div class="row"><b>Token</b></div>
        <div class="row">
          <button class="btn" id="tokenBtn">Token Action</button>
          <!-- In the Tokens row, right after the Token Action button -->
          <button class="btn" id="toggleTokensBtn" title="Hide/Unhide all tokens (H/U)">Hide</button>
          <span id="tokenTag" class="tag">Token: Ready</span>
          <span id="skippedTag" class="tag">Skipped: 0/3</span>
          <span id="elbowSkippedTag" class="tag">Elbows Skipped: 0/3</span>
          <span id="tokenCount" class="tag">Token: 0/3</span>
          <span id="scoreTag" class="tag">Score: 0/3</span>
        </div>
        <div class="row small muted">Move along <b>any connected pipes</b> (opponent tracks allowed once networks connect). One token action/turn. Max 3 tokens/player.</div>
        <label class="toggle"><input type="checkbox" id="vizEdges"> Show connection edges</label>
        <hr style="border-color:#1f2636"/>
        <div class="row"><b>Rotation</b></div>
        <div class="row">
          <button class="btn" id="rollBtn">Roll Die</button>
          <span id="dieFace" class="tag">Die: —</span>
          <button class="btn" id="applyBtn" disabled>Apply</button>
          <span id="rollTag" class="tag">Roll: Ready</span>
        </div>
        <div class="row small muted">Meshed gears: neighbors alternate opposite direction. One roll per turn.</div>
        <hr style="border-color:#1f2636"/>
        <div class="row"><button class="btn" id="endTurnBtn">End Turn</button>
        <button id="overrideBtn" style="display:none;">Override</button></div>

        <hr style="border-color:#1f2636"/>
        <div class="row"><b>Undo / Redo</b></div>
        <div class="row">
          <button class="btn" id="undoGlobalBtn" disabled>Undo (Global)</button>
          <button class="btn" id="redoGlobalBtn" disabled>Redo (Global)</button>
        </div>
        <div class="row">
          <button class="btn" id="undoTurnBtn" disabled>Undo (Turn)</button>
          <button class="btn" id="redoTurnBtn" disabled>Redo (Turn)</button>
        </div>

        <h2>Save / Load</h2>
        <div class="panel">
          <div class="row">
            <button class="btn" id="saveBtn">Save Game</button>
            <button class="btn" id="loadBtn">Load Game</button>
            <input type="file" id="loadFile" accept="application/json" style="display:none" />
          </div>
          <div class="row small muted">
            Saves to a local JSON file. Load restores the full game later.
          </div>
        </div>
      </div>

      <h2>Corners</h2>
      <div class="panel">
        <table class="scoreTable" id="cornerScoreTable" style="width:100%; border-collapse:collapse;">
          <thead>
            <tr>
              <th style="text-align:left;">Place</th>
              <th style="text-align:left;">Color</th>
              <th style="text-align:left;">Quadrant</th>
              <th style="text-align:right;">Score</th>
            </tr>
          </thead>
          <tbody>
            <tr data-pid="0">
              <td id="place-0">—</td>
              <td><span class="dot" style="background:#ff6b6b"></span> <span id="pname-0">Red</span><span id="aibadge-0" class="aiBadge" style="display:none;">AI</span></td>
              <td id="quad-0">—</td>
              <td id="score-0" style="text-align:right;">0/3</td>
            </tr>
            <tr data-pid="1">
              <td id="place-1">—</td>
              <td><span class="dot" style="background:#6bff95"></span> <span id="pname-1">Green</span><span id="aibadge-1" class="aiBadge" style="display:none;">AI</span></td>
              <td id="quad-1">—</td>
              <td id="score-1" style="text-align:right;">0/3</td>
            </tr>
            <tr data-pid="2">
              <td id="place-2">—</td>
              <td><span class="dot" style="background:#6bd9ff"></span> <span id="pname-2">Blue</span><span id="aibadge-2" class="aiBadge" style="display:none;">AI</span></td>
              <td id="quad-2">—</td>
              <td id="score-2" style="text-align:right;">0/3</td>
            </tr>
            <tr data-pid="3">
              <td id="place-3">—</td>
              <td><span class="dot" style="background:#ffef6b"></span> <span id="pname-3">Yellow</span><span id="aibadge-3" class="aiBadge" style="display:none;">AI</span></td>
              <td id="quad-3">—</td>
              <td id="score-3" style="text-align:right;">0/3</td>
            </tr>
          </tbody>
        </table>
      </div>
    </aside>
    <main id="game"><canvas id="board"></canvas></main>
  </div>
  <div id="toast" class="toast"></div>
<script>

function loadSetupFromStorage(){
  try {
    const s = JSON.parse(localStorage.getItem('rr.setup') || 'null');
    if (!s) return null;
    // normalize expected shape
    return {
      boardSize: (Number.isFinite(s.boardSize) ? s.boardSize : 9),
      players: Array.isArray(s.players) ? s.players.map((p,i)=>({
        id: i,
        name: (p && p.name) ? String(p.name) : ['Red','Green','Blue','Yellow'][i],
        ai: !!(p && p.ai),
        active: (p && typeof p.active === 'boolean') ? !!p.active : (i < 2) // default Red/Green active
      })) : null
    };
  } catch(e){ console.warn('setup load failed', e); return null; }
}

(function(){
  // Toast with adjustable duration (defaults to ~3.5s) and proper clearing
  let _toastTimer=null;
  const toast=(m, ms=3500)=>{
    const el=document.getElementById('toast');
    el.textContent=m;
    el.classList.add('show');
    if(_toastTimer) clearTimeout(_toastTimer);
    _toastTimer=setTimeout(()=>el.classList.remove('show'), ms);
  };
  const aiSleepTime = 200;
  const aiSleepTime2 = 300;
  const setStatus=(t)=>{ document.getElementById('status').innerHTML=t; };
  const tag = (id)=>document.getElementById(id);
  const turnTag=()=>tag('turnTag');
  const phaseTag=()=>tag('phaseTag');
  const drawnTag=()=>tag('drawnCard');
  const drawTag=()=>tag('drawTag');
  const dieTag=()=>tag('dieFace');
  const rollTag=()=>tag('rollTag');
  const tokenTag=()=>tag('tokenTag');
  const tokenCount=()=>tag('tokenCount');
  const btn=(id)=>document.getElementById(id);

  // === Solo-AI pause UI ===
  function showSoloAIPrompt(){
    const b = btn('continueBtn');
    if (b){ b.style.display='inline-block'; b.disabled=false; }
    state.pausedForSoloAI = true;
    // Keep the comma attached to "New Game" and prefer non-breaking in the label
    setStatus(
      '<span class="caution">There is only one AI player left. If you wish to stop now, click <b>New&nbsp;Game,</b> or press <b>Continue</b> to proceed.</span>'
    );
  }
  function hideSoloAIPrompt(){
    const b = btn('continueBtn');
    if (b){ b.style.display='none'; }
    state.pausedForSoloAI = false;
  }

  // --- Token visibility toggle (UI helper) ---
  function setTokensHidden(on){
    state.tokensHidden = !!on;
    state.tokensHiddenFor = state.tokensHidden ? currentPlayer().id : null;
    updateHUD();
    render();
  }
  function ensureTokensVisible(){
    if (state.tokensHidden){
      state.tokensHidden = false;
      state.tokensHiddenFor = null;
      updateHUD();
      render();
    }
  }

  // Count unfinished players (excludes finished and those totally out of tokens)
  function countIncomplete(){ 
    let ai=0, human=0;
    for (const p of state.players){
      if (!p) continue;
      const finished = playerHasFinished(p);
      const out = ((p.tokensRemoved|0) >= TOKENS_MAX) && (countTokens(p.id)===0);
      if (finished || out) continue;
      if (p.ai) ai++; else human++;
    }
    return {ai, human};
  }
  function onlyOneAILeft(){ 
    const {ai, human} = countIncomplete(); 
    return ai===1 && human===0; 
  }

  // Wire the Continue button (run the current AI turn once, then hide)
  (function(){
    const b = btn('continueBtn');
    if (!b) return;
    b.addEventListener('click', ()=>{
      hideSoloAIPrompt();
      state.soloAIResumed = true; // ← prevent future pauses while one AI remains
      const P = currentPlayer && currentPlayer();
      if (P && P.ai && !state.aiBusy){
        if (state.aiTimer) { try{ clearTimeout(state.aiTimer);}catch(e){} state.aiTimer=null; }
        state.aiTimer = setTimeout(()=>{
          if (!state.aiBusy && (currentPlayer()===P)) aiTakeTurn();
        }, 80);
      }
    });
  })();

  // Accurate standings: compute per-player reached count and render with proper ordinals.
  function renderStandingsAccurate(){
    const players = state.players || [];
    const target = Math.max(1, players.length - 1); // corners to reach
    const countReachedFor = (p)=>{
      const r = p && p.reached;
      if (r instanceof Set) return r.size;
      if (Array.isArray(r)) return r.length;
      // fallback if some code recorded an integer
      return Number(p && p.score) || 0;
    };
    const ordinal = (n)=>{ const s=["th","st","nd","rd"], v=n%100; return n+(s[(v-20)%10]||s[v]||s[0]); };
    // rank by reached corners desc; stable within ties
    const ranked = players.map(p=>({p, sc: countReachedFor(p)}))
                          .sort((a,b)=> b.sc - a.sc);
    const host = document.getElementById('standingsList')
             || document.getElementById('standings')
             || document.querySelector('.standings');
    if (!host) return;
    host.innerHTML = ranked.map((row, i)=>{
      const p = row.p, sc = row.sc;
      const aiTag = p.ai ? ' <span class="muted">AI</span>' : '';
      return `<div class="stand-row"><span class="dot" style="background:${p.color}"></span> ${ordinal(i+1)} ${p.name} <span class="muted">(${sc}/${target})</span>${aiTag}</div>`;
    }).join('');
  }
  
  // Decide whether AI should even consider using a die roll (rotation) this turn.
  // Conservative rules:
  // - Never roll while still holding/handling a track card (finish placement/bottoming first).
  // - Never roll if a legal token action already exists.
  // - Optionally honor a rotation embargo counter if present.
  function shouldConsiderDieRoll(P){
    if (!P) return false;
    // If a track card is in hand, prioritize resolving it (place or bottom), not rotating.
    if (P.drawn) return false;
    // Optional: respect any embargo counters if present in the save/state.
    if ((P.rotationEmbargoTurns|0) > 0) return false;
    // If recent rotations repeatedly failed to unlock movement, skip more rotations.
    if ((P._failedRotationTurns|0) >= 2) return false;
    // If we’ve been stalled for a couple of turns, prefer scouting moves over more rotations.
    if ((P._aiStalledTurns|0) >= 2) return false;    
    // If we already have a legal token action, there's no need to roll.
    try{
      if (typeof aiChooseTokenAction === 'function' && aiChooseTokenAction(P.id)) return false;
    }catch(_){}
    // Otherwise, rolling may help break a stall.
    return true;
  }  

  // === AI thinking UI/lock ===
  // Locks sidebar buttons & canvas input while current player (AI) is acting.
  // Also annotates the Turn tag with "(AI thinking…)" for observability.
  function setAIThinking(on){
    state.lockInput = !!on;
    const cur = currentPlayer && currentPlayer();
    const isAI = !!(cur && cur.ai);
    // Disable most sidebar buttons while AI is acting (leave Save/Load/Menu usable)
    try{
      document.querySelectorAll('.sidebar button').forEach(b=>{
        const id = b.id || '';
        const allow = (id==='saveBtn' || id==='loadBtn' || id==='returnMenuBtn' || id==='loadFile');
        b.disabled = !!on && isAI ? !allow : b.disabled && false; // re-enable when we unlock
      });
    } catch(_) {}
    // Annotate Turn tag without fighting updateHUD too much
    const t = turnTag && turnTag();
    if (t && cur){
      const base = `Turn: ${cur.name}${cur.ai ? ' (AI)' : ''}`;
      t.textContent = on && isAI ? base.replace(' (AI)', ' (AI thinking…)') : base;
    }
  }

  // Keyboard guard so humans can't accidentally fire shortcuts during an AI turn
  window.addEventListener('keydown', (e)=>{
    try{
      const cur = currentPlayer && currentPlayer();
      if (state.lockInput && cur && cur.ai){ e.stopPropagation(); e.preventDefault(); }
    }catch(_){}
  }, true);

  window.addEventListener('keydown', (e) => {
    // Ignore when typing in inputs
    const ae = document.activeElement;
    if (ae && /input|textarea|select/i.test(ae.tagName)) return;

    const P = currentPlayer();
    if (!P || P.ai) return;        // human only
    if (state.aiBusy) return;      // not during AI animations/turns

    if (e.key === 'h' || e.key === 'H') {
      setTokensHidden(true);
      e.preventDefault();
    } else if (e.key === 'u' || e.key === 'U') {
      setTokensHidden(false);
      e.preventDefault();
    }
  });
 

  // Keep “Skipped” HUD tags in sync with the current player's counters
  function refreshSkipTags(){
    const P = currentPlayer && currentPlayer();
    if (!P) return;
    const s = document.getElementById('skippedTag');
    const e = document.getElementById('elbowSkippedTag');
    if (s) {
      s.textContent = `Skipped: ${P.skipCount|0}/3`;
      // Optional: show red only when general skip force is active next turn
      if ((P.skipCount|0) >= 3) s.classList.add('warn'); else s.classList.remove('warn');
    }
    if (e) {
      e.textContent = `Elbows Skipped: ${P.elbowSkipCount|0}/3`;
      // Red only while at/over the elbow force threshold
      if ((P.elbowSkipCount|0) >= 3) e.classList.add('warn'); else e.classList.remove('warn');
    }
  }

  // Colors & constants
  const COLORS={ bg:'#0b0f18', grid:'#263145', gear:'#202a3d', track:'#6d7aa6', block:'#434b63', slot:'#a8b7ff', hilite:'#9efff4', tokenR:'#ff6b6b', tokenG:'#6bff95', tokenB:'#6bd9ff', tokenY:'#ffef6b', edge:'#f4b86a', hint:'#c7f0ff' };
  const TrackCard={
    Straight:'Straight', Elbow:'Elbow', Cross:'Cross', T:'T',
    RStraight:'RS', RElbow:'RE', RCross:'RC', RT:'RT'
  };
  const DIE_FACES=['X','X','X','CW90','CW90','CCW90','CCW90','DEG180'];
  // === Animation timing knobs ===
  const RR_APPLY_TWEEN_MS = 650;    // duration for the big "Apply" rotation tween (tiles + gears)
  const PREVIEW_ROT_TWEEN_MS = 400; // duration for RR keys initiated track placement ghost preview rotation
  const TOKENS_MAX=3;
  const PLAYERS=[
    { id:0, name:'Red', color: COLORS.tokenR, pocket:'NW' },
    { id:1, name:'Green', color: COLORS.tokenG, pocket:'NE' },
    { id:2, name:'Blue', color: COLORS.tokenB, pocket:'SE' },
    { id:3, name:'Yellow', color: COLORS.tokenY, pocket:'SW' },
  ];

  // ==== GEAR SVG (mesh-ready: alternate 0° / 90°) ====
  const GEAR_SRC = 'gear-grayblue-03.svg';     // file should sit beside RotoRouter.html
  const gearImg = new Image();
  let gearReady = false;
  // Optional: set decoding to sync to improve first-paint, browsers may ignore
  if ('decoding' in gearImg) gearImg.decoding = 'sync';
  gearImg.onload = () => { gearReady = true; render(); };
  gearImg.onerror = () => { console.warn('Could not load gear SVG:', GEAR_SRC); };
  gearImg.src = `${GEAR_SRC}?v=2025-10-02`;
  // How tightly the gear outer diameter should fit the cell (1.00 = full cell)
  // For tight teeth meshing, keep at 1.00. If you want a tiny gap, try 0.98.
  const GEAR_OUTER_FIT = 1.00;   // -> try 0.98 if you prefer a hairline gap
  // ==== GEAR SPIN (animated) ====
  // Toggle overall gear animation
  const GEAR_SPIN_ENABLED = true;

  // Spin speed in revolutions per minute (positive = clockwise for even parity cells)
  const GEAR_SPIN_RPM = 6;   // try 3–12 to taste

  // ==== UNDO / REDO CONFIG ====
  // Master switch and per-scope toggles (code-only; no UI)
  const UNDO_CONFIG = {
    enabled: true,     // turn Undo/Redo on/off entirely
    global:  true,     // allow Global undo/redo
    turn:    true      // allow Player-turn-scoped undo/redo
  };

  // Openings — Elbow base = EAST+NORTH (NE), Straight is horizontal base
  const OPENINGS={
    Straight: [[1,0],[-1,0]],            // base: horizontal
    Elbow:    [[1,0],[0,-1]],            // base: TURNS from East to North
    Cross:    [[1,0],[-1,0],[0,1],[0,-1]],
    T:        [[1,0],[-1,0],[0,-1]]      // base: ┴  (open E, W, N; closed S) — rotation adds others
  };

  function rotDir([dx,dy],deg){
    const t = snap90(deg);
    if(t===0)   return [dx,dy];
    if(t===90)  return [-dy,dx];
    if(t===180) return [-dx,-dy];
    if(t===270) return [dy,-dx];
    return [dx,dy];
  }

  function rotatedOpenings(cell){
    if(!cell.track || cell.track==='Block') return [];
    const r = snap90(cell.rot|0);
    return OPENINGS[cell.track].map(([dx,dy])=>rotDir([dx,dy], r));
  }
  function hasReciprocal(aCell, bCell, dx, dy){
    const aOk = rotatedOpenings(aCell).some(([rx,ry])=>rx===dx && ry===dy);
    if(!aOk) return false;
    const bOk = rotatedOpenings(bCell).some(([rx,ry])=>rx===-dx && ry===-dy);
    return bOk;
  }
  
  // Utilities & state
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  
  // ======== AI: lightweight heuristics (v0) ========

  // Manhattan distance
  function manhattan(a, b){ return Math.abs(a.x-b.x) + Math.abs(a.y-b.y); }

  // Return list of legal empty targets for the current player's *drawn* card
  // (does NOT mutate highlight or phase).
  function aiListLegalTargets(pid){
    const P = state.players[pid];
    if (!P || !P.drawn) return [];
    const prev = { phase: state.phase, subphase: state.subphase, highlight: state.highlight.slice() };
    try {
      state.phase='place'; state.subphase=null; state.highlight=[];
      computePlaceHighlights();                   // populates state.highlight for P.drawn
      return (state.highlight || []).slice();
    } finally {
      state.phase = prev.phase; state.subphase = prev.subphase; state.highlight = prev.highlight;
    }
  }

  // Score a placement cell for new pieces: prefer center & cells that touch our current network footprint
  function aiScorePlacementCell(pid, x, y){
    const N = state.N;
    const center = { x: (N-1)/2, y: (N-1)/2 };
    const towardsCenter = -manhattan({x,y}, center); // closer to center is better
    // Slight bonus if adjacent to anything we own (helps extend)
    let adjOwned = 0;
    [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
      const nx=x+dx, ny=y+dy;
      if (!within(nx,ny)) return;
      const c = state.board[ny][nx];
      if (c.track && c.owner===pid) adjOwned += 1;
    });
    return towardsCenter + adjOwned*2;
  }

  // Rich scorer for rotating an existing tile (RS/RE/RT).
  function aiScoreRotationAt(x, y, rot, pid){
    const cell = state.board[y][x];
    if(!cell || !cell.track || cell.track==='Block') return -Infinity;

    // Primary: reciprocal connections (degree)
    let degree = 0;
    const opens = rotatedOpeningsType(cell.track, rot);
    for (const [dx,dy] of opens){
      const nx = x+dx, ny = y+dy;
      if (!within(nx,ny)) continue;
      const n = state.board[ny][nx];
      if (!n || !n.track || n.track==='Block') continue;
      if (hasReciprocalTypes(cell.track, rot, n.track, n.rot, dx, dy)) degree++;
    }

    // Off-board openings are bad (harder near corners).
    const offboard   = aiCountOffboardOpenings(cell.track, rot, x, y);
    const firstPlace = false; // not a new placement; use the lighter penalty
    const offPenalty = firstPlace ? (offboard * 60) : (offboard * 25);

    // Inward-friendly empty neighbors
    const inward = aiCountInwardOpenings(cell.track, rot, x, y);

    // Outward vs. retreat relative to the owner's corner & the board center
    const owner = state.board[y][x].owner ?? pid; // prefer tile owner; fall back to acting player
    const outwardBias = aiOutwardBias(cell.track, rot, owner, x, y);
    const retreatPen  = aiBackTowardCornerPenalty(cell.track, rot, owner, x, y);

    // Path-to-opponent-corner bonus if this rotation helps create a path
    const pathBonus = aiHasPathToOppCornerWithHypothetical(cell.track, rot, x, y, owner) ? 50 : 0;

    return (degree * 12)
        + pathBonus
        - offPenalty
        + (inward * 2)
        + (outwardBias * 6)
        - retreatPen;
  }

  // For RS/RE/RT on an existing tile: prefer rotations that strictly improve score.
  // If no rotation improves (or all zero-offboard options are worse), recommend "no-op".
  function aiBestRotationFor(x, y, pid){
    const cell = state.board[y][x];
    if(!cell || !cell.track || cell.track==='Block'){
      return { rot: snap90(cell?.rot ?? 0), score: -Infinity, curScore: -Infinity, improve: -Infinity };
    }
    const baseRot   = snap90(cell.rot);
    const curScore  = aiScoreRotationAt(x, y, baseRot, pid);

    // If any zero-offboard rotation exists, don't consider offboard ones at all.
    const hasZeroOff = [0,90,180,270].some(r => aiCountOffboardOpenings(cell.track, r, x, y) === 0);
    const candidates = [0,90,180,270].filter(r => !hasZeroOff || aiCountOffboardOpenings(cell.track, r, x, y) === 0);

    let best = { rot: baseRot, score: curScore, curScore, improve: 0 };
    for (const r of candidates){
      const sc = aiScoreRotationAt(x, y, r, pid);
      if (sc > best.score) best = { rot: r, score: sc, curScore, improve: sc - curScore };
    }
    return best;
  }

  // Count openings that go off the board (hard penalty).
  function aiCountOffboardOpenings(type, rot, x, y){
    let off=0;
    const opens = rotatedOpeningsType(type, rot);
    for (const [dx,dy] of opens){
      const nx = x + dx, ny = y + dy;
      if (!within(nx, ny)) off++;
    }
    return off;
  }

  // Count "inward-friendly" openings: in-bounds neighbor that is empty (future-connectable).
  // This gives a small bonus so elbows on borders prefer pointing into playable space.
  function aiCountInwardOpenings(type, rot, x, y){
    let inward=0;
    const opens = rotatedOpeningsType(type, rot);
    for (const [dx,dy] of opens){
      const nx = x + dx, ny = y + dy;
      if (!within(nx, ny)) continue;
      const n = state.board[ny][nx];
      if (!n.track && n.token == null) inward++;
    }
    return inward;
  }

  // Heuristic: local “rotation leverage” if a nearby Elbow/Straight could be turned
  // to add a new reciprocal or aim us toward a target corner in one 90° rotation.
  function aiRotationLeverageAt(x, y, pid, target){
    let bonus = 0;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of dirs){
      const nx = x + dx, ny = y + dy;
      if (!within(nx,ny)) continue;
      const nb = state.board[ny][nx];
      if (!nb || !nb.track) continue;
      if (nb.track !== 'Elbow' && nb.track !== 'Straight') continue;

      const baseRot = snap90(nb.rot);
      let improves = false;
      let aimsBetter = false;
      for (const R of [0,90,180,270]){
        if (R === baseRot) continue;
        // New reciprocal possibility into (x,y)?
        const opens = rotatedOpeningsType(nb.track, R);
        if (opens.some(([odx,ody]) => nx+odx===x && ny+ody===y)) improves = true;
        // Turn neighbor to face toward the target?
        const vx = Math.sign(target.x - nx), vy = Math.sign(target.y - ny);
        if (opens.some(([odx,ody]) => odx===vx && ody===vy)) aimsBetter = true;
        if (improves && aimsBetter) break;
      }
      if (improves)   bonus += 2;
      if (aimsBetter) bonus += 1;
    }
    return bonus; // typical 0..3
  }

  // First placement detector for the given player (no owned tracks and no corner-connected net).
  function aiIsFirstPlacement(pid){
    const myOwned = owned(pid);
    const net = connectedTrackFromCorner(pid);
    const myTokens = allTokensOf(pid);
    return (myOwned.length === 0 && net.length === 0 && myTokens.length === 0);
  }

  // --- Outward / retreat heuristics -------------------------------------------
  // Sign in {-1,0,1}
  function sgn1(n){ return n>0 ? 1 : (n<0 ? -1 : 0); }

  // Vector pointing "outward" = toward the board center from (x,y)
  function outwardVec(pid, x, y){
    const center = { x: (state.N-1)/2, y: (state.N-1)/2 };
    return { vx: sgn1(center.x - x), vy: sgn1(center.y - y) };
  }

  // Favor rotations whose openings point away from our own corner.
  // Weighted stronger when close to the corner (first few rings).
  function aiOutwardBias(type, rot, pid, x, y){
    const {vx, vy} = outwardVec(pid, x, y);
    let s = 0;
    for (const [dx,dy] of rotatedOpeningsType(type, rot)){
      const dot = dx*vx + dy*vy;   // + => outward, - => toward corner
      if (dot > 0) s += 1;
      else if (dot < 0) s -= 1;
    }
    const ring = manhattan({x,y}, cornerFor(pid));        // 0 at corner
    const w = Math.max(0, 4 - Math.min(ring, 4));         // 4..0 weight near corner
    return s * (1 + w);                                   // [-?, +?], higher is better
  }

  // Penalize rotations whose immediate step(s) move closer to our own corner.
  // Stronger near the corner.
  function aiBackTowardCornerPenalty(type, rot, pid, x, y){
    const c = cornerFor(pid);
    const here = manhattan({x,y}, c);
    let towards = 0;
    for (const [dx,dy] of rotatedOpeningsType(type, rot)){
      const nx = x + dx, ny = y + dy;
      if (!within(nx,ny)) continue;                       // offboard handled elsewhere
      const there = manhattan({x:nx, y:ny}, c);
      if (there < here) towards++;                        // this opening steps toward corner
    }
    if (towards === 0) return 0;
    // Weight: harsh near corner, mild farther out
    const w = (here <= 2) ? 22 : (here <= 4 ? 14 : 8);
    return towards * w;                                   // positive penalty
  }

  // Evaluate all legal targets and all 4 rotations; choose cell+rot that maximizes connections,
  // with secondary preferences (center bias, adjacency to own network).
  function aiBestPlacementForDrawn(pid, targets){
    const P = state.players[pid];
    if (!P || !P.drawn || !targets.length) return null;

    // Normalize the drawn card to its base track type (e.g., RS → Straight)
    const card = P.drawn;
    const baseType = baseDrawnType(card);
    const firstPlace = aiIsFirstPlacement(pid);
    const myCorner  = cornerFor(pid);

    // Build a set of cells that admit at least ONE fully reciprocal rotation.
    // (We only keep the cell; the specific rot is re-tested below.)
    const legalCells = new Map(); // key "x,y" -> {x,y}
    for (const t of targets){
      for (const R of [0,90,180,270]){
        if (!aiIsReciprocalAt(baseType, R, t.x, t.y)) continue;
        const br = aiAttachmentBreakdown(baseType, R, t.x, t.y, pid);
        // Require at least one *friendly* attachment, except the first-at-corner seed.
        if (br.friendly > 0 || (firstPlace && t.x===myCorner.x && t.y===myCorner.y)) {
          legalCells.set(`${t.x},${t.y}`, { x: t.x, y: t.y });
          break;
        }
      }
    }
    const legal = Array.from(legalCells.values());
    if (legal.length === 0) return null;

    const N = state.N;
    const center = { x: (N-1)/2, y: (N-1)/2 };

    // Relax off-board penalty on very first placement for non-Elbows
    const firstPlacementRelax = firstPlace && (baseType !== 'Elbow');


    // Track best overall AND best that *connects* (degree>0)
    let best = null;
    let bestConn = null;
    for (const t of legal){
      for (const rot of [0,90,180,270]){
        // Primary score: reciprocal connections to neighbors
        let degree = 0;
        const opens = rotatedOpeningsType(baseType, rot);

        // <<< MOVE THIS UP: compute offboard before any prefilter that uses it
        const offboard = aiCountOffboardOpenings(baseType, rot, t.x, t.y);

        // Strong prefilter: on the very first placement with an Elbow,
        // skip rotations that send ANY opening off-board if there exists another rotation that keeps both in-bounds.
        if (firstPlace && baseType === 'Elbow') {
          const haveAllInBoundsOption =
            [0,90,180,270].some(R => aiCountOffboardOpenings(baseType, R, t.x, t.y) === 0);
          if (haveAllInBoundsOption && offboard > 0) {
            continue; // try a different rotation that keeps both legs in-bounds
          }
        }

        for (const [dx,dy] of opens){
          const nx = t.x + dx, ny = t.y + dy;
          if (!within(nx,ny)) continue;
          const n = state.board[ny][nx];
          if (!n || !n.track) continue;
          if (hasReciprocalTypes(baseType, rot, n.track, n.rot, dx, dy)) degree++;
        }

        // Secondary: prefer center + adjacency to own network
        const centerBonusMax = 2 * Math.floor(N/2);         // 8 on 9×9, 6 on 7×7
        const centerBonus    = centerBonusMax - manhattan({x:t.x, y:t.y}, center); // 0..8 (higher is better)
        let adjOwned = 0;
        [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
          const nx=t.x+dx, ny=t.y+dy;
          if (!within(nx,ny)) return;
          const c = state.board[ny][nx];
          if (c.track && c.owner === pid) adjOwned++;
        });

      // Small bonus for pointing openings toward usable, empty in-bounds cells
      const inward = aiCountInwardOpenings(baseType, rot, t.x, t.y);

      // BIG bonus if this placement/rotation connects (by reciprocal edges) to any opponent corner
      const pathBonus = aiHasPathToOppCornerWithHypothetical(baseType, rot, t.x, t.y, pid) ? 50 : 0;

      // Outward vs. retreat (relative to our own corner)
      const outwardBias = aiOutwardBias(baseType, rot, pid, t.x, t.y);            // + good, - bad
      const retreatPen  = aiBackTowardCornerPenalty(baseType, rot, pid, t.x, t.y); // positive penalty

      // First placement relaxation (except Elbow): allow some off-board on corner starts
      const offPenalty = firstPlacementRelax
        ? (offboard * 10)          // ← much gentler for initial T/S/Cross at corner
        : (firstPlace ? (offboard * 60) : (offboard * 25));

      // Final score — give more weight to *attaching now*
      const score = (degree * 18)     // ↑ from 12 → 18 to favor immediate connections
                  + pathBonus
                  - offPenalty
                  + (inward * 2)
                  + (adjOwned * 2)
                  + centerBonus
                  + (outwardBias * 6)
                  - retreatPen
                  + (firstPlacementRelax ? inward : 0);  // ← tiny extra nudge on turn 1                  

      const cand = { x: t.x, y: t.y, rot, score, degree };
      if (!best || score > best.score) best = cand;
      if (degree > 0 && (!bestConn || score > bestConn.score)) bestConn = cand;
      }
    }

    // Enforce attachment: if nothing attaches, only allow the special
    // "first placement at own corner" case; otherwise bottom.
    let pick = bestConn;
    if (!pick && firstPlace && best && best.x===myCorner.x && best.y===myCorner.y) {
      pick = best; // allow initial corner seed even if degree==0
    }    
    
    // If still no attaching option (and not the special first-corner case), bottom.
    if (!pick) return null;

    // For non-Elbow *first* placements: always place the best legal option.
    // (Avoids skipping a perfectly fine T/S/Cross at the corner.)
    if (pick && firstPlacementRelax) {
      return pick;
    }

    // Keep the safety cutoff for everything else
    if (pick) {
      const bottomThreshold = -40; // uniform & conservative
      if (pick.score < bottomThreshold) return null;
    }
    return pick;
  }

  // AI helper: does this card help connect corners?
  function isConnectorCard(c){
    return c===TrackCard.RT || c===TrackCard.RS || c===TrackCard.RE || c===TrackCard.RC;
  }

  // Simple sleep
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // Animate preview rotation toward target (0/90/180/270) in small steps
  async function animatePreviewRotation(targetDeg, durationMs=420){
    const norm = (n)=>((n%360)+360)%360;
    const stepCount = 6;
    const start = norm(state.previewRot|0);
    const target = norm(targetDeg|0);

    // shortest direction
    let diff = target - start;
    if (diff > 180) diff -= 360;
    if (diff < -180) diff += 360;

    for (let i=1;i<=stepCount;i++){
      const t = i/stepCount;
      state.previewRot = norm(start + diff * t);
      render();
      await sleep(durationMs/stepCount);
    }
    state.previewRot = target;
    render();
  }

  // --- Dev-only finite-value assertion ---------------------------------------
  // Off by default. Enable from console:  window.RR_DEV_ASSERTS = true
  // or set state.debugAsserts = true at runtime.
  function __devAssertFinite(label, ...nums){
    try {
      const on = (typeof window !== 'undefined' && window.RR_DEV_ASSERTS) || (state && state.debugAsserts);
      if (!on) return;
      for (let i=0;i<nums.length;i++){
        const v = nums[i];
        if (!Number.isFinite(v)){
          // Make it noisy in dev, but don’t brick production
          console.warn(`[DEV ASSERT] ${label}: non-finite value at index ${i}`, { value:v, nums, stack:(new Error()).stack });
          throw new Error(`[DEV ASSERT] ${label}: non-finite`);
        }
      }
    } catch(e){
      // Swallow if desired; rethrow to halt AI if you prefer stricter dev behavior.
      // throw e;
    }
  }

  // ... other AI helpers above ...

  // Count reciprocal attachments the new piece would make at (x,y,rot)
  function aiDegreeIfPlaced(type, rot, x, y){
    let degree = 0;
    const opens = rotatedOpeningsType(type, rot);
    for (const [dx,dy] of opens){
      const nx = x+dx, ny = y+dy;
      if (!within(nx,ny)) continue;
      const n = state.board[ny][nx];
      if (!n || !n.track) continue;
      if (hasReciprocalTypes(type, rot, n.track, n.rot, dx, dy)) degree++;
    }
    return degree;
  }

  // Fallback: use the same legality that the UI uses (highlights) and
  // pick the first legal target; rotation is arbitrary for legality.
  function aiFirstLegalPlacementForDrawn(pid){
    const P = currentPlayer();
    if (!P || !P.drawn) return null;
    const targets = aiListLegalTargets(pid);
    if (!targets || targets.length === 0) return null;
    // Choose the first target that has at least one reciprocal rotation
    for (const t of targets){
      for (const R of [0,90,180,270]){
        if (aiIsReciprocalAt(baseDrawnType(P.drawn), R, t.x, t.y)) {
          return { at:{ x: t.x, y: t.y }, rot: R };
        }
      }
    }
    return null;
  }

  // AI-only: check that a new placement at (x,y,rot) would be fully reciprocal
  // with all adjacent tracks (no dangling half-connections against neighbors).
  function aiIsReciprocalAt(track, rot, x, y){
    if (!within(x,y)) return false;
    // Our openings at this rotation
    const ours = rotatedOpeningsType(track, snap90(rot)); // e.g., [[1,0],[-1,0]...]
    const needBack = new Set(ours.map(([dx,dy]) => `${dx},${dy}`));
    // Check 4 neighbors
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of dirs){
      const nx = x+dx, ny = y+dy;
      if (!within(nx,ny)) continue;
      const nb = state.board[ny][nx];
      if (!nb || !nb.track) continue;
      // Neighbor openings
      const nbOpens = rotatedOpeningsType(nb.track, snap90(nb.rot));
      const nbSet = new Set(nbOpens.map(([odx,ody]) => `${odx},${ody}`));
      // If we open toward neighbor, neighbor must open back toward us
      if (needBack.has(`${dx},${dy}`)){
        if (!nbSet.has(`${-dx},${-dy}`)) return false;
      }
      // If neighbor opens toward us, we must open back toward neighbor
      if (nbSet.has(`${-dx},${-dy}`)){
        if (!needBack.has(`${dx},${dy}`)) return false;
      }
    }
    return true;
  }

  // Token: find a scoring move if one exists; else step closer to any opponent corner.
  // Will not "ping-pong" between two tiles; if no strictly-progressing move exists,
  // returns null so the caller can try rotations (die) before card actions.
  function aiChooseTokenAction(pid){
    // First look for any token with a path to a scoring corner
    const myTokens = allTokensOf(pid);
    // remember where we've been this turn to avoid endless ping-pong
    state.aiVisitedThisTurn ||= new Set();
    // All opponent corner coords (reuse throughout the function)
    const oppCorners = opponentCorners(pid);
    const P = state.players[pid];

    // Only target corners that have not been reached yet
    const unreachedCorners = oppCorners.filter(oc => {
      const owner = PLAYERS.find(pl => cornerFor(pl.id).x === oc.x && cornerFor(pl.id).y === oc.y);
      const rset  = P.reached ? (P.reached instanceof Set ? P.reached : new Set(P.reached)) : new Set();
      return !rset.has(owner?.name);
    });

    // Fallback: if all corners reached (shouldn’t happen but safe)
    const targetCorners = unreachedCorners.length ? unreachedCorners : oppCorners;

    let best = null;

    for (const t of myTokens) {
      const moves = reachableFrom(t, pid);
      if (!moves.length) continue;

      // 1) Still prefer an immediate score if available
      const scorer = moves.find(m => opponentCornerAt(m.x, m.y, pid) != null);
      if (scorer) return { type:'move', from:t, to:scorer };

      // 2) Otherwise, pick a move that *progresses* toward any un-reached corner.
      //    Prefer strictly closer moves; if none exist, DO NOT move (let caller try a rotation).
      //    Also avoid immediately returning to the previous hop (anti ping-pong).
      const allOCs = opponentCorners(pid);
      const reachedSet = (P.reached instanceof Set ? P.reached : (P.reached ? new Set(P.reached) : new Set()));
      const unreachedOCs = allOCs.filter(oc => {
        const name = PLAYERS.find(p => cornerFor(p.id).x===oc.x && cornerFor(p.id).y===oc.y)?.name;
        return !reachedSet.has(name);
      });
      const lastTarget = (unreachedOCs.length === 1) ? unreachedOCs[0] : null;
      const targets = unreachedOCs.length ? unreachedOCs : allOCs;
      const d0 = Math.min(...targets.map(oc => manhattan(t, oc)));
      __devAssertFinite('ai.tokenTargeting.d0', d0);

      // Where did we just land last time? (so we don’t bounce right back)
      const lastKey = state.aiLastHop?.get(pid) || null;
      // What was the last traversed edge? (A→B blocks B→A immediately)
      const lastEdge = state.aiLastEdge?.get(pid) || null;

      let bestScore = Infinity;
      for (const m of moves) {
        const dNear = Math.min(...targets.map(oc => manhattan(m, oc)));
        const dLast = lastTarget ? manhattan(m, lastTarget) : dNear;
        const leverage = aiRotationLeverageAt(
          m.x, m.y, pid, lastTarget || targets[0]
        );
        const mk = `${m.x},${m.y}`;
        const fromK = `${t.x},${t.y}`;
        const revEdge = `${mk}|${fromK}`; // this move would reverse the last edge if equal        
        // Lower score is better: distance minus a small leverage bonus.
        const score = (lastTarget ? dLast * 1.25 : dNear) - 0.5 * leverage;
        __devAssertFinite('ai.tokenTargeting.loop', dNear, dLast, leverage, score);
        // Require strict improvement in distance to a target corner (no equal-distance hops).
        // Also forbid hopping back to the last cell we came from this game turn (anti ping-pong).
        const isBacktrackCell = (lastKey && mk === lastKey);
        const isReverseEdge   = (lastEdge && lastEdge === revEdge);
        const isAcceptable = (dNear < d0) && !isBacktrackCell && !isReverseEdge;
        if (isAcceptable && score < bestScore) { bestScore = score; best = m; }
      }

      if (best) return { type:'move', from:t, to:best };
    }

    // If we can place a new token at our corner, do that early if we have few tokens on board
    const corner = cornerFor(pid);
    const cCell  = state.board[corner.y][corner.x];
    const onBoard = countTokens(pid);
    const reached = P.reached ? (P.reached instanceof Set ? P.reached.size : new Set(P.reached).size) : 0;
    const lifetimePlaced = Math.min(TOKENS_MAX, (P.tokensRemoved|0) + onBoard);
    const canPlaceNew = (lifetimePlaced < TOKENS_MAX) && cCell.track && cCell.token==null;
    // Prefer to ramp to at least 2 tokens on board when the corner is free
    if (canPlaceNew && onBoard < 2) return { type:'place', at: corner };
    // Otherwise: if no strictly improving move exists, do NOT move.
    // Returning null lets the caller try a rotation (die) to unlock paths.

    // If we couldn’t move any token, consider placing a new one (even if we already have some)
    if (canPlaceNew) return { type:'place', at: corner };

    // --- NEW: detect complete stall ---
    const allCorners = opponentCorners(pid);
    const unreached = allCorners.filter(oc => {
      const name = PLAYERS.find(p => cornerFor(p.id).x===oc.x && cornerFor(p.id).y===oc.y)?.name;
      return !P.reached?.has(name);
    });

    // If no reachable improvement and at least one unreached corner exists, flag stall
    if (unreached.length) {
      P._aiStalledTurns = (P._aiStalledTurns || 0) + 1;
    } else {
      P._aiStalledTurns = 0;
    }

    // --- NEW: exploration fallback (avoid endless rotations) -----------------
    // If rotations haven’t helped recently OR we’ve been stalled for a bit,
    // allow a non-strict move that increases future options (branching/leverage),
    // still avoiding ping-pong (no immediate backtrack or edge reverse).
    if ((P._failedRotationTurns|0) >= 1 || (P._aiStalledTurns|0) >= 2) {
      const allOCs = opponentCorners(pid);
      const reachedSet = P.reached instanceof Set ? P.reached : new Set(P.reached||[]);
      const unreachedOCs = allOCs.filter(oc=>{
        const name = PLAYERS.find(pp=>cornerFor(pp.id).x===oc.x && cornerFor(pp.id).y===oc.y)?.name;
        return !reachedSet.has(name);
      });
      const targets = unreachedOCs.length ? unreachedOCs : allOCs;
      let bestMove = null, bestScore = -Infinity, bestFrom = null;

      const center = { x:(state.N-1)/2, y:(state.N-1)/2 };
      const centerBonus = (p)=> (Math.max(0, 8 - (Math.abs(p.x-center.x)+Math.abs(p.y-center.y))));

      for (const t of myTokens) {
        const moves = reachableFrom(t, pid);
        if (!moves.length) continue;
        const d0 = Math.min(...targets.map(oc => manhattan(t, oc)));
        const lastKey  = state.aiLastHop?.get(pid) || null;
        const lastEdge = state.aiLastEdge?.get(pid) || null;
        const fromK = `${t.x},${t.y}`;

        for (const m of moves) {
          const mk = `${m.x},${m.y}`;
          // Anti ping-pong
          if (lastKey && mk === lastKey) continue;
          if (lastEdge && lastEdge === `${mk}|${fromK}`) continue; // immediate reverse edge

          const dNear   = Math.min(...targets.map(oc => manhattan(m, oc)));
          const worse   = Math.max(0, dNear - d0);      // distance increase (penalize lightly)
          const branch  = (()=>{                        // local branching (reciprocal degree)
            let deg=0;
            const here = state.board[m.y][m.x];
            if (here && here.track) {
              for (const [dx,dy] of rotatedOpenings(here)) {
                const nx=m.x+dx, ny=m.y+dy;
                if (!within(nx,ny)) continue;
                const nb = state.board[ny][nx];
                if (!nb || !nb.track) continue;
                if (hasReciprocal(here, nb, dx, dy)) deg++;
              }
            }
            return deg;
          })();
          const targetHint = (unreachedOCs[0] || targets[0]);
          const leverage = aiRotationLeverageAt(m.x, m.y, pid, targetHint); // future rotate value
          // Score: prefer more branching/leverage, mild preference to center, mild penalty if farther.
          const score = (branch * 1.2) + (leverage * 1.5) + (centerBonus(m) * 0.2) - (worse * 0.8);
          if (score > bestScore) { bestScore = score; bestMove = m; bestFrom = t; }
        }
      }

      if (bestMove) {
        return { type:'move', from: bestFrom, to: bestMove };
      }
    }

    return null; // no-op (no sensible exploration found)
  }

  function makeDeck(size, activeCount=4){
    // Baseline deck per player tuned for a 4-player table (your current numbers)
    const baseBySize = {
      7: { Straight:7,  Elbow:6,  Cross:1,  T:3,
          RStraight:3, RElbow:2, RCross:1, RT:1 },
      9: { Straight:9,  Elbow:8,  Cross:1,  T:3,
          RStraight:4, RElbow:3, RCross:2, RT:2 },
    };
    const base = baseBySize[size] || (size <= 7 ? baseBySize[7] : baseBySize[9]);

    // Scale so that total track across the table ≈ constant vs 4-player baseline.
    // Example: 2 players => per-player deck ~ 2× the 4P baseline.
    const scale = 4 / Math.max(1, activeCount);
    const round = (n) => Math.max(0, Math.round(n));

    // Start with a simple proportional scale
    const cfg = {
      Straight:  round(base.Straight  * scale),
      Elbow:     round(base.Elbow     * scale),
      Cross:     round(base.Cross     * scale),
      T:         round(base.T         * scale),
      RStraight: round(base.RStraight * scale),
      RElbow:    round(base.RElbow    * scale),
      RCross:    round(base.RCross    * scale),
      RT:        round(base.RT        * scale),
    };

    // Connectivity minimums per player, by board size (conservative but small):
    // Ensures enough "spanners" to bridge axes and turn corners when player count is low.
    const minBySize = (sz) => (sz <= 7
      ? { Straight: 7, Elbow: 6, T: 3, Cross: 1 }   // roughly your 7×7 baseline mins
      : { Straight: 9, Elbow: 8, T: 3, Cross: 1 }   // roughly your 9×9 baseline mins
    );
    const mins = minBySize(size);

    // Apply minimums only upward (never reduce scaled values)
    cfg.Straight = Math.max(cfg.Straight, mins.Straight);
    cfg.Elbow    = Math.max(cfg.Elbow,    mins.Elbow);
    cfg.T        = Math.max(cfg.T,        mins.T);
    cfg.Cross    = Math.max(cfg.Cross,    mins.Cross);
    // console.log("cfg.Straight = " + cfg.Straight);
    // console.log("cfg.Elbow = " + cfg.Elbow);
    // console.log("cfg.T = " + cfg.T);
    // console.log("cfg.Cross = " + cfg.Cross);

    // Construct the deck
    const TrackCard = {
      Straight:'Straight', Elbow:'Elbow', Cross:'Cross', T:'T',
      RStraight:'RS', RElbow:'RE', RCross:'RC', RT:'RT'
    };

    return {
      draw: shuffle([
        ...Array(cfg.Straight).fill(TrackCard.Straight),
        ...Array(cfg.Elbow).fill(TrackCard.Elbow),
        ...Array(cfg.Cross).fill(TrackCard.Cross),
        ...Array(cfg.T).fill(TrackCard.T),

        ...Array(cfg.RStraight).fill(TrackCard.RStraight),
        ...Array(cfg.RElbow).fill(TrackCard.RElbow),
        ...Array(cfg.RCross).fill(TrackCard.RCross),
        ...Array(cfg.RT).fill(TrackCard.RT),
      ]),
      discard: []
    };
  }

  function makeBoard(N){ const b=[]; for(let y=0;y<N;y++){ const r=[]; for(let x=0;x<N;x++){ r.push({track:null,rot:0,owner:null,token:null}); } b.push(r);} return b; }
  function initGearOffsets(N){
    state.gearOffset = Array.from({length:N}, () => Array(N).fill(0));
  }

  const UI = {
    boardSize:()=>document.getElementById('boardSize'),
    template:()=>document.getElementById('template'),
    canvas:()=>document.getElementById('board'),
    vizEdges:()=>document.getElementById('vizEdges'),
  };

  const state={ N:9, cell:64, pad:20, board:makeBoard(9),
    // AI turn coordination
    aiBusy:false,           // prevents re-entrancy (double actions)
    aiTimer:null,           // pending setTimeout handle for AI turn    
    players:PLAYERS.map(p=>({...p, deck:makeDeck(), drawn:null, tokens:0, tokensRemoved:0, drawLocked:false, drawUsed:false, tokenUsed:false, rollUsed:false, skipCount: 0, elbowSkipCount: 0, forceElbow: false, active:true })),    cornerLockTurns: PLAYERS.map(()=>0),
    current:0, phase:'idle', subphase:null, highlight:[], hover:null, forcePlace:false, previewRot:0, die:null, tokenSelect:null,
    turnAdvancing:false,
    deadFixDoneThisTurn: false,
    rotAnims: [],  // active rotation tweens (on placed tiles)
    ghostRotAnim: null,   // {from,to,t0,dur} while rotating the ghost
    _animating: false,    // RAF loop guard
    gearSpinAnim: null,   // { base: +90|-90|180, t0, dur } active only during Apply tween
    gearOffset: null,     // per-cell persistent gear angle offset (degrees, 0..359)
    // Undo/Redo stacks
    history: [],        // Global undo stack (array of snapshots)
    redo:    [],        // Global redo stack
    turnHistory: [],    // Per-turn undo stack (current player's turn)
    turnRedo:   [],     // Per-turn redo stack
    pausedForSoloAI: false,
    soloAIResumed: false, // once user clicks Continue, don’t pause again
    forceElbowFor: null,  // If set to a player id, that player must place an Elbow this turn (but only if placement is possible)
    _enforceForcePlaceWindow: false  // gate: only true during startTurn() check
  };

  // AI: remember last landing to prevent ping-pong
  state.aiLastHop = new Map(); // key: pid, val: "x,y"
  // AI: remember the last traversed EDGE A→B to forbid the immediate reverse B→A
  state.aiLastEdge = new Map(); // key: pid, val: "ax,ay|bx,by"

  const canvas=UI.canvas(); const ctx=canvas.getContext('2d');

  // ==== UNDO / REDO HELPERS ====
  function pushHistory(label){
    if (!UNDO_CONFIG.enabled) return;
    const snap = snapshotState();
    snap.__turnId = state.current;      // tag snapshot with current player's turn id
    snap.__undo_label = label || '';
    // Global
    if (UNDO_CONFIG.global){
      state.history.push(snap);
      state.redo.length = 0; // new action invalidates redo
    }
    // Turn-scoped
    if (UNDO_CONFIG.turn){
      state.turnHistory.push(snap);
      state.turnRedo.length = 0;
    }
    updateUndoButtons();
  }

  function applySnapshotFromHistory(snap, label, op){
    // op is 'undo' or 'redo'
    applySnapshot(snap, { fromHistory: true, status: label || null, op });
  }

  function updateUndoButtons(){
    // Called inside updateHUD() as well, but safe to call anytime
    const gCanUndo = UNDO_CONFIG.enabled && UNDO_CONFIG.global && state.history.length > 0;
    const gCanRedo = UNDO_CONFIG.enabled && UNDO_CONFIG.global && state.redo.length > 0;

    const tCanUndo = UNDO_CONFIG.enabled && UNDO_CONFIG.turn && state.turnHistory.length > 1; // need ≥1 action beyond baseline
    const tCanRedo = UNDO_CONFIG.enabled && UNDO_CONFIG.turn && state.turnRedo.length > 0;

    const bU = document.getElementById('undoGlobalBtn');
    const bR = document.getElementById('redoGlobalBtn');
    const bTU= document.getElementById('undoTurnBtn');
    const bTR= document.getElementById('redoTurnBtn');

    if (bU) bU.disabled  = !gCanUndo;
    if (bR) bR.disabled  = !gCanRedo;
    if (bTU) bTU.disabled = !tCanUndo;
    if (bTR) bTR.disabled = !tCanRedo;
  }

  // Global Undo/Redo (mirrors into Turn stacks so buttons stay in sync)
  function undoGlobal(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.global) return;
    if (state.history.length === 0) return;

    const cur = snapshotState();            // current state → global redo
    const prev = state.history.pop();       // previous snapshot to apply
    state.redo.push(cur);

    // Mirror into Turn stacks
    if (UNDO_CONFIG.turn) {
      const curTurnId  = state.current;
      const stepTurnId = (prev && prev.__turnId != null) ? prev.__turnId : curTurnId;

      if (stepTurnId === curTurnId) {
        // Undoing a step from THIS turn → pop one from per-turn history
        if (state.turnHistory.length > 1) {
          state.turnRedo.push(cur);
          state.turnHistory.pop();
        }
      } else {
        // Undoing into a different turn → collapse to baseline for clarity
        state.turnHistory = state.turnHistory.slice(0, 1);
        state.turnRedo.length = 0;
      }
    }

    applySnapshotFromHistory(prev, 'Undid (Global).', 'undo');
    toast('Undo (Global)');
    updateUndoButtons();
  }

  function redoGlobal(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.global) return;
    if (state.redo.length === 0) return;

    const cur  = snapshotState();       // current state → global history
    const next = state.redo.pop();      // snapshot to reapply
    state.history.push(cur);

    // Mirror into Turn stacks
    if (UNDO_CONFIG.turn) {
      const curTurnId  = state.current;
      const stepTurnId = (next && next.__turnId != null) ? next.__turnId : curTurnId;

      if (stepTurnId === curTurnId) {
        // Redoing a step that belongs to THIS turn
        state.turnHistory.push(cur);
        if (state.turnRedo.length > 0) state.turnRedo.pop();
      } else {
        // Redoing into a different turn → keep per-turn at baseline
        state.turnHistory = state.turnHistory.slice(0, 1);
        state.turnRedo.length = 0;
      }
    }

    applySnapshotFromHistory(next, 'Redid (Global).', 'redo');
    toast('Redo (Global)');
    updateUndoButtons();
  }

  // Turn-scoped Undo/Redo (only within the *current* player's turn)
  function undoTurn(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.turn) return;
    // Need at least baseline + 1 action
    if (state.turnHistory.length <= 1) return;

    // Current snapshot becomes redo entry
    const cur = snapshotState();

    // Pop the target "previous" snapshot from turnHistory and apply it
    const prev = state.turnHistory.pop();

    // Mirror the move to Global stacks so buttons/behavior stay in sync
    if (UNDO_CONFIG.global && state.history.length > 0) {
      // push current to global redo, drop one from global history
      state.redo.push(cur);
      state.history.pop();
    }

    // Turn redo receives current
    state.turnRedo.push(cur);

    applySnapshotFromHistory(prev, 'Undid (Turn).', 'undo');
    toast('Undo (Turn)');
    updateUndoButtons();
  }

  function redoTurn(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.turn) return;
    if (state.turnRedo.length === 0) return;

    const cur = snapshotState();
    const next = state.turnRedo.pop();

    // Mirror to Global stacks
    if (UNDO_CONFIG.global) {
      // current becomes a new step in global history
      state.history.push(cur);
      // consume one from global redo if available
      if (state.redo.length > 0) state.redo.pop();
    }

    // Turn history receives current
    state.turnHistory.push(cur);

    applySnapshotFromHistory(next, 'Redid (Turn).', 'redo');
    toast('Redo (Turn)');
    updateUndoButtons();
  }

  // Reset per-turn history at the start of each player's turn.
  function resetTurnHistory(){
    state.turnHistory = [];
    state.turnRedo    = [];
    // Push a baseline so "first action" undo target exists,
    // but keep the button disabled until an action actually happens.
    if (UNDO_CONFIG.enabled && UNDO_CONFIG.turn){
      state.turnHistory.push(snapshotState());
      state.turnRedo.length = 0;
    }
    updateUndoButtons();
  }

  // ===== SAVE / LOAD =====

  // Build a plain JSON-safe snapshot of the full game state.
  function snapshotState() {
    // Convert Sets to arrays, drop transient/animation fields
    const players = state.players.map(p => ({
      id: p.id,
      name: p.name,
      color: p.color,
      pocket: p.pocket,
      active: !!p.active,
      // ⬇⬇⬇ ADD THIS
      ai: !!p.ai,
      deck: {
        draw: [...(p.deck?.draw || [])],
        discard: [...(p.deck?.discard || [])],
      },
      drawn: p.drawn ?? null,
      tokens: p.tokens|0,
      tokensRemoved: p.tokensRemoved|0,
      drawLocked: !!p.drawLocked,
      drawUsed: !!p.drawUsed,
      tokenUsed: !!p.tokenUsed,
      rollUsed: !!p.rollUsed,
      skipCount: p.skipCount|0,
      elbowSkipCount: p.elbowSkipCount|0,
      forceElbow: !!p.forceElbow,
      forcePlaceNext: !!p.forcePlaceNext,
      reached: p.reached ? Array.from(p.reached) : [],
    }));

    // Deep copy board (tracks, rotations, owners, tokens)
    const board = [];
    for (let y=0; y<state.N; y++) {
      const row = [];
      for (let x=0; x<state.N; x++) {
        const c = state.board[y][x] || {};
        row.push({
          track: c.track ?? null,
          rot: c.rot|0,
          owner: (c.owner==null? null : c.owner|0),
          token: (c.token==null? null : c.token|0),
        });
      }
      board.push(row);
    }

    // Deep copy per-cell gear offsets so Undo/Redo can restore visual orientation
    const gearOffset = (state.gearOffset && state.gearOffset.length === state.N)
      ? state.gearOffset.map(row => row.slice())
      : null;    

    return {
      __rr_version: 1,
      savedAt: new Date().toISOString(),
      N: state.N,
      current: state.current|0,
      players,
      board,
      gearOffset,  // ← include in snapshot (also helps Save/Load stay visually consistent)
      // Corner/seal bookkeeping
      cornerLockTurns: Array.isArray(state.cornerLockTurns) ? [...state.cornerLockTurns] : null,
      cornerSealed: Array.isArray(state.cornerSealed) ? [...state.cornerSealed] : null,
      deadFixDoneThisTurn: !!state.deadFixDoneThisTurn,   // ← top-level, not per-player
      finishOrder: Array.isArray(state.finishOrder) ? state.finishOrder.slice() : [],
      // We intentionally DO NOT persist: phase, subphase, highlights, die, animations, hover, etc.
    };
  }

  // Download a JSON file (no server needed)
  function downloadJSON(obj, filename) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      document.body.removeChild(a);
    }, 0);
  }

  function saveGame() {
    const snap = snapshotState();
    const name = `RotoRouter_${snap.N}x${snap.N}_${snap.savedAt.replace(/[:.]/g,'-')}.json`;
    downloadJSON(snap, name);
    toast('Game saved.');
  }

  // Apply a snapshot back into our live state (safe restore)
  function applySnapshot(snap, opts) {
    // Basic validation
    if (!snap || typeof snap !== 'object' || snap.__rr_version == null) {
      throw new Error('Not a valid RotoRouter save file.');
    }
    // Cancel any pending AI turn from a previous state (prevents double-execution after Undo/Redo)
    if (state.aiTimer) { try { clearTimeout(state.aiTimer); } catch(e) {} state.aiTimer = null; }
    state.aiBusy = false;    
    if (!Number.isInteger(snap.N) || !Array.isArray(snap.board) || !Array.isArray(snap.players)) {
      throw new Error('Save is missing required fields.');
    }
    // Clear stacks only on real loads, not when applying from history
    if (!opts || !opts.fromHistory) {
      state.history = []; state.redo = [];
      state.turnHistory = []; state.turnRedo = [];
    }
    // Resize board if needed & sync dropdown
    state.N = snap.N;
    const sizeSel = UI.boardSize();
    if (sizeSel) {
      const opt = [...sizeSel.options].find(o => parseInt(o.value,10) === state.N);
      if (opt) sizeSel.value = String(state.N);
    }

    // Restore board
    state.board = makeBoard(state.N);
    initGearOffsets(state.N); // <- add this
    for (let y=0; y<state.N; y++) {
      for (let x=0; x<state.N; x++) {
        const s = (snap.board[y] && snap.board[y][x]) || {};
        state.board[y][x] = {
          track: s.track ?? null,
          rot: snap90(s.rot|0),
          owner: (s.owner==null? null : s.owner|0),
          token: (s.token==null? null : s.token|0),
        };
      }
    }

    // Restore per-cell gear angles if present in the snapshot (Undo/Redo & Save/Load)
    if (Array.isArray(snap.gearOffset)) {
      state.gearOffset = Array.from({length: state.N}, (_, y) =>
        Array.from({length: state.N}, (_, x) => {
          const v = (snap.gearOffset[y] && snap.gearOffset[y][x]);
          return Number.isFinite(v) ? ((((v % 360) + 360) % 360)|0) : 0;
        })
      );
    } // else keep the zero-initialized offsets from initGearOffsets(N)    

    // (place near other local helpers/reads at the top of applySnapshot)
    const setupFromStorage = loadSetupFromStorage(); // may be null
    // Restore finish order (unique placements)
    state.finishOrder = Array.isArray(snap.finishOrder)
      ? snap.finishOrder.map(v => (v|0)).filter(v => Number.isInteger(v))
      : [];    

    // Restore players (keep order aligned with PLAYERS by id)
    state.players = PLAYERS.map((baseP) => {
      const from = snap.players.find(pp => pp.id === baseP.id) || {};
      return {
        id: baseP.id,
        name: (typeof from.name === 'string' && from.name.trim()) ? from.name : baseP.name,
        color: baseP.color,
        pocket: baseP.pocket,
        ai:
          (typeof from.ai === 'boolean') ? !!from.ai :
          (typeof baseP.ai === 'boolean') ? !!baseP.ai :
          !!(setupFromStorage && setupFromStorage.players && setupFromStorage.players[baseP.id] && setupFromStorage.players[baseP.id].ai),
        active: (typeof from.active === 'boolean') ? !!from.active : true,
        deck: {
          draw: [...(from.deck?.draw || [])],
          discard: [...(from.deck?.discard || [])],
        },
        drawn: from.drawn ?? null,
        tokens: from.tokens|0,
        tokensRemoved: from.tokensRemoved|0,
        drawLocked: !!from.drawLocked,
        drawUsed: !!from.drawUsed,
        tokenUsed: !!from.tokenUsed,
        rollUsed: !!from.rollUsed,
        skipCount: from.skipCount|0,
        elbowSkipCount: from.elbowSkipCount|0,
        forceElbow: !!from.forceElbow,
        forcePlaceNext: !!from.forcePlaceNext,
        reached: new Set(from.reached || []),
      };
    });
    // --- Waive forces/reset counters ONLY on real file load, NOT on Undo/Redo ---
    if (!opts || !opts.fromHistory) {
      state.forcePlace = false;
      state.forceElbowFor = null;
      state.players.forEach(p => {
        p.skipCount = 0;
        p.elbowSkipCount = 0;
      });
    }

    // AI per-turn/transient memory should start clean after a load
    state.aiVisitedThisTurn = new Set();
    state.aiLastHop = new Map();
    state.aiLastEdge = new Map();

    // --- Robust legacy backfill for token counts ---
    // Newer code treats:
    //   tokensRemoved = lifetime tokens that have been removed from board (scored or otherwise gone)
    //   onBoard       = count of tokens currently on the board
    //   placed        = tokensRemoved + onBoard  (0..TOKENS_MAX)
    // Older saves often had `tokens: 3` for everyone and it did NOT mean "placed".
    for (const p of state.players) {
      const src = snap.players.find(pp => pp.id === p.id) || {};
      const onBoard = countTokens(p.id);
      const reachedLen =
        p.reached instanceof Set ? p.reached.size :
        Array.isArray(src.reached) ? src.reached.length : 0;

      const hasTokensRemoved = Number.isFinite(src.tokensRemoved);
      let tokensRemoved = hasTokensRemoved ? Math.max(0, Math.min(TOKENS_MAX, src.tokensRemoved|0)) : null;

      // Try to interpret legacy `tokens` if present.
      // Case A: it might be "remaining to place" (0..3). If so, remaining + onBoard + removed == TOKENS_MAX.
      let legacyTokens = Number.isFinite(src.tokens) ? Math.max(0, Math.min(TOKENS_MAX, src.tokens|0)) : null;
      let remainingGuess = null;
      if (legacyTokens != null) {
        // Treat as "remaining" if it yields a consistent total ≤ TOKENS_MAX when combined with onBoard and reached/removed.
        // Prefer using explicit tokensRemoved if provided; else fall back to reached count as a proxy for removals.
        const removedGuessFromReached = Math.max(0, Math.min(TOKENS_MAX, reachedLen));
        const removedRef = (tokensRemoved != null) ? tokensRemoved : removedGuessFromReached;
        const total = legacyTokens + onBoard + removedRef;
        if (total === TOKENS_MAX) {
          remainingGuess = legacyTokens;
          if (tokensRemoved == null) tokensRemoved = removedRef;
        }
      }

      // If we still don’t have tokensRemoved, infer from reached (common rule: scoring removes your token).
      if (tokensRemoved == null) tokensRemoved = Math.max(0, Math.min(TOKENS_MAX, reachedLen));

      // If even that yields zero evidence AND nothing is on the board, assume they’re “out” to avoid soft-locks.
      if (tokensRemoved === 0 && onBoard === 0 && legacyTokens == null && reachedLen === 0) {
        tokensRemoved = TOKENS_MAX;
      }

      // Finalize
      p.tokensRemoved = Math.max(0, Math.min(TOKENS_MAX, tokensRemoved));
      // Keep p.tokens coherent going forward: placed = removed + onBoard (cap at TOKENS_MAX).
      p.tokens = Math.max(0, Math.min(TOKENS_MAX, p.tokensRemoved + onBoard));
    }

    // Turn + corner bookkeeping
    state.current = (snap.current|0) % state.players.length;
    state.cornerLockTurns = Array.isArray(snap.cornerLockTurns)
      ? snap.cornerLockTurns.slice(0, PLAYERS.length)
      : PLAYERS.map(()=>0);
    state.cornerSealed = Array.isArray(snap.cornerSealed)
      ? snap.cornerSealed.slice(0, PLAYERS.length)
      : PLAYERS.map(()=>false);

    // Reset transients/animations/UI-phase safely
    state.phase = 'idle';
    state.subphase = null;
    state.highlight = [];
    state.hover = null;
    // Preserve/restore force rules on Undo/Redo; only clear on real file loads.
    if (!opts || !opts.fromHistory) {
      state.forcePlace = false;
    }
    state.previewRot = 0;
    state.die = null;
    state.tokenSelect = null;
    state.rotateFocus = null;
    state.turnAdvancing = false;
    state.rotAnims = [];
    state.ghostRotAnim = null;
    state.deadFixDoneThisTurn = !!snap.deadFixDoneThisTurn;   // default false if absent

    // Ensure AI hop memory is fresh after a load
    state.aiLastHop = new Map();
    state.soloAIResumed = false;  // allow prompt again on a loaded game

    // Backfill finishOrder for legacy/partial saves: include any already-finished players
    state.finishOrder = Array.isArray(state.finishOrder)
      ? state.finishOrder.filter((v, i, a) => a.indexOf(v) === i)
      : [];
    for (const p of state.players) {
      if (playerHasFinished(p) && !state.finishOrder.includes(p.id)) {
        state.finishOrder.push(p.id);
      }
    }

    // Recompute saturation immediately after restore
    refreshBoardSaturation();

    // Recompute any topology-derived hints (e.g., seals)
    if (typeof onTopologyChanged === 'function') onTopologyChanged();

    // Resize canvas for the (possibly) new N and redraw
    resize();
    updateHUD();
    // If this came from history, re-open the short activation window and re-check force.
    if (opts && opts.fromHistory) {
      state._enforceForcePlaceWindow = true;
      checkForcePlace();
      state._enforceForcePlaceWindow = false;
      updateHUD();
    }

    if (opts && opts.fromHistory) {
      // After UNDO/REDO, re-enter fix phases (Corner Fix then Dead-Straight Fix) if eligible
      maybeEnterFixPhasesAfterHistory(opts.op);

      // If we are not in a fix subphase, show the provided status (e.g., “Redid (Global)”).
      if (state.phase !== 'cornerFix' && state.phase !== 'deadFix' && opts.status) {
        setStatus(opts.status);
      }
      render();
      return;
    }

    // ---- real file load path ----
    setStatus('Game loaded.');
    render();
    updatePlacesFromFinishOrder(); // reflect any finishers immediately after load    
    startTurn();
    return;
  }

  function loadFromFile(file) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const snap = JSON.parse(reader.result);
        applySnapshot(snap);
        toast('Save loaded successfully.');
      } catch (err) {
        console.error(err);
        toast('Failed to load: ' + err.message);
        setStatus('Load error: ' + err.message);
      }
    };
    reader.readAsText(file);
  }


  function resize(){
    const rightW = window.innerWidth - 360; const h = window.innerHeight;
    const size = Math.min(rightW, h) * 0.95;
    state.cell = Math.floor(size / state.N);
    state.pad = Math.floor((Math.min(rightW, h) - state.cell*state.N)/2);
    canvas.width = rightW; canvas.height = h;
    render();
  }
  window.addEventListener('resize', resize);

  function currentPlayer(){ return state.players[state.current]; }
  
  function opponentCornerAt(x,y,pid){
    for(const q of PLAYERS){
      if(q.id===pid) continue;
      const c = cornerFor(q.id);
      if(c.x===x && c.y===y) return q.id;
    }
    return null;
  }

  function cornerFor(pid){
    const N=state.N; const p=PLAYERS[pid].pocket;
    if(p==='NW') return {x:0,y:0}; if(p==='NE') return {x:N-1,y:0}; if(p==='SE') return {x:N-1,y:N-1}; return {x:0,y:N-1};
  }

  // Return an array of all opponent-corner coordinates for the given player id.
  function opponentCorners(pid){
    return PLAYERS.filter(p => p.id !== pid)
                  .map(p => cornerFor(p.id));
  }

  function owned(pid){ const out=[]; for(let y=0;y<state.N;y++) for(let x=0;x<state.N;x++){ const c=state.board[y][x]; if(c.track && c.owner===pid) out.push({x,y}); } return out; }
  function within(x,y){ return x>=0 && y>=0 && x<state.N && y<state.N; }

  // ---- Dead-Straight detection helpers (STRICT: "trapped straight") ----
  function isStraightHorizontal(cell){
    return !!cell && cell.track === 'Straight' && (snap90(cell.rot) % 180 === 0);
  }
  function isStraightVertical(cell){
    return !!cell && cell.track === 'Straight' && (snap90(cell.rot) % 180 !== 0);
  }

  // STRICT + BORDER rule:
  // A Straight at (x,y) is “trapped” iff:
  // • Every *present* orthogonal neighbor is a Straight oriented perpendicular to the center, AND
  // • At least 3 neighbors are present (so corners with only 2 neighbors never qualify).
  // This covers:
  //   – Inner cells: need all 4 neighbors, all perpendicular (classic case).
  //   – Border cells: 3 in-bounds neighbors, all perpendicular ⇒ trapped.
  //   – Corner cells: only 2 neighbors ⇒ never trapped.
  function isTrappedStraight(x, y) {
    const c = state.board[y][x];
    if (!c || c.track !== 'Straight') return false;

    const centerIsH = isStraightHorizontal(c);

    // Describe the 4 orthogonal neighbors with bounds checks
    const neigh = [
      { nx: x - 1, ny: y,     need: centerIsH ? isStraightVertical : isStraightHorizontal }, // L
      { nx: x + 1, ny: y,     need: centerIsH ? isStraightVertical : isStraightHorizontal }, // R
      { nx: x,     ny: y - 1, need: centerIsH ? isStraightVertical : isStraightHorizontal }, // U
      { nx: x,     ny: y + 1, need: centerIsH ? isStraightVertical : isStraightHorizontal }, // D
    ];

    let present = 0;

    for (const n of neigh) {
      if (!within(n.nx, n.ny)) continue;           // out-of-bounds neighbor simply doesn't exist
      present++;
      const cell = state.board[n.ny][n.nx];
      if (!n.need(cell)) return false;             // present neighbor must be a Straight, perpendicular
    }

    // Require at least 3 present neighbors to count as trapped.
    // This allows border (3-side) traps and inner (4-side) traps, but excludes corners (2).
    return present >= 3;
  }

  function findAllTrappedStraights(){
    const out = [];
    for (let y=0; y<state.N; y++){
      for (let x=0; x<state.N; x++){
        if (isTrappedStraight(x,y)) out.push({x,y});
      }
    }
    return out;
  }

    // --- replace the entire maybeResumeDeadFixAfterHistory() with this unified helper ---
  function maybeEnterFixPhasesAfterHistory(op){
    if (state.turnAdvancing) return;
    if (state.phase !== 'idle') return;

    const P = currentPlayer();

    // Corner Fix has priority over Dead-Straight Fix
    if (typeof isCornerSealed === 'function' && isCornerSealed(P.id)) {
      startCornerFixCross(P.id);
      return;
    }

    // Dead-Straight Fix (only if not already consumed this turn)
    if (!state.deadFixDoneThisTurn && typeof findAllTrappedStraights === 'function') {
      const trapped = findAllTrappedStraights();
      if (trapped && trapped.length){
        state.phase    = 'deadFix';
        state.subphase = 'pickDeadStraight';
        state.highlight = trapped;
        const msg = 'Dead-Straight Fix: replace ONE highlighted Straight with a Cross (free).';
        setStatus(msg);
        render();
        updateHUD();
        return;
      }
    }
  }

  function isBoardFullyTracked(){
    for (let y=0; y<state.N; y++){
      for (let x=0; x<state.N; x++){
        const c = state.board[y][x];
        if (!c.track) return false;
      }
    }
    return true;
  }

  // Keep a cached flag on state
  state.boardSaturated = false;
  function refreshBoardSaturation(){
    const was = !!state.boardSaturated;
    state.boardSaturated = isBoardFullyTracked();
    if (!was && state.boardSaturated){
      setStatus('Board is full of tracks — normal placement locked. Tokens, rotations, and rotate/replace cards (RS/RE/RC) still allowed.');
      toast('Board fully tracked: track placement locked.');
    }
  }

  // Count tokens for a player
  function countTokens(pid){
    let n=0;
    for(let y=0;y<state.N;y++) for(let x=0;x<state.N;x++){ if(state.board[y][x].token===pid) n++; }
    return n;
  }
  function allTokensOf(pid){
    const arr=[];
    for(let y=0;y<state.N;y++) for(let x=0;x<state.N;x++){ if(state.board[y][x].token===pid) arr.push({x,y}); }
    return arr;
  }

  function playerHasFinished(P){
    if (!P) return false;
    const reached = P.reached
      ? (P.reached instanceof Set ? P.reached : new Set(P.reached))
      : new Set();
    return reached.size >= 3;
  }

  // --- Places UI, driven ONLY by state.finishOrder (stable & persisted) ---
  function ordinal(n){
    const s=["th","st","nd","rd"], v=n%100;
    return n + (s[(v-20)%10] || s[v] || s[0]);
  }
  function updatePlacesFromFinishOrder(){
    const order = Array.isArray(state.finishOrder) ? state.finishOrder.slice() : [];
    for (const p of state.players){
      const cell = document.getElementById('place-' + p.id);
      if (!cell) continue;
      const idx = order.indexOf(p.id);
      cell.textContent = (idx >= 0) ? ordinal(idx+1) : '—';
    }
  }

  // Record the order in which players complete 3/3 corners.
  // (Used to assign unique final places: 1st, 2nd, 3rd, 4th.)
  function recordFinishIfNew(P){
    if (!P) return;
    if (!playerHasFinished(P)) return;
    state.finishOrder = Array.isArray(state.finishOrder) ? state.finishOrder : [];
    if (!state.finishOrder.includes(P.id)) state.finishOrder.push(P.id);
    updatePlacesFromFinishOrder(); // keep the table immediately in sync
  }

  // BFS for token moves — by default do NOT pass through any tokens.
  // If no destinations exist under that rule, do a fallback BFS that allows
  // pass-through over *opponent* tokens (never over your own). Corners can’t
  // be blocked: moving onto an opponent’s corner is always a legal terminal.
  function reachableFrom(start, pid){
    const run = (allowPassThroughOpp=false) => {
      const vis = new Set();
      const q = [start];
      const out = [];
      const key = (x,y)=>x+','+y;
      vis.add(key(start.x,start.y));
      while(q.length){
        const {x,y} = q.shift();
        const here = state.board[y][x];
        if(!here.track || here.track==='Block') continue;
        for(const [dx,dy] of rotatedOpenings(here)){
          const nx = x+dx, ny = y+dy;
          if(!within(nx,ny)) continue;
          const there = state.board[ny][nx];
          if(!there.track || there.track==='Block') continue;
          if(!hasReciprocal(here, there, dx, dy)) continue; // pipes must connect both ways
          const k = key(nx,ny);
          if(vis.has(k)) continue;
          // Identify if the neighbor is an opponent's corner
          const oppId = opponentCornerAt(nx, ny, pid);
          const ownerOnOwnCorner = (oppId != null && there.token === oppId);

          if (oppId != null) {
            // If this opponent's corner has ALREADY been reached by this player,
            // we may PASS THROUGH it (if pipes connect), but we may NOT STOP there again.
            const P = state.players[pid];
            const reachedSet = P?.reached
              ? (P.reached instanceof Set ? P.reached : new Set(P.reached))
              : new Set();
            const oppName = PLAYERS[oppId].name;

            if (reachedSet.has(oppName)) {
              // Allow traversal (enqueue), but do not expose as a destination.
              vis.add(k);
              q.push({ x: nx, y: ny });
              continue;
            }
          }
          // --- NEW: Treat a *fresh* opponent corner as a valid scoring destination ---
          if (oppId != null) {
            const P = state.players[pid];
            const reachedSet = P?.reached
              ? (P.reached instanceof Set ? P.reached : new Set(P.reached))
              : new Set();
            const oppName = PLAYERS[oppId].name;

            if (!reachedSet.has(oppName)) {
              // We reached a new, unscored opponent corner:
              // mark it as a legal destination but do not traverse beyond it.
              out.push({ x: nx, y: ny });
              vis.add(k);
              continue;
            }
          }
          // Corners can't be blocked: moving onto opponent's corner (with their token present)
          // is a legal terminal IF not already scored above.
          if (ownerOnOwnCorner){
            vis.add(k);
            out.push({x:nx,y:ny});
            continue; // do not traverse beyond an opponent's scored corner
          }

          // Token blocking logic
          if (there.token != null){
            // Never pass through your own token
            if (there.token === pid) continue;
            // Pass-through over opponent tokens only if fallback is enabled
            if (!allowPassThroughOpp) continue;
            // Fallback path: traverse through opponent token, but cannot stop on it
            vis.add(k);
            q.push({x:nx,y:ny});
            continue;
          }

          // Empty neighbor: traverse and consider as a legal destination
          vis.add(k);
          q.push({x:nx,y:ny});
          out.push({x:nx,y:ny});
        }
      }
      return out;
    };
    // Phase 1: strict (no pass-through over any tokens)
    const strict = run(false);
    if (strict.length > 0) return strict;
    // Phase 2: fallback only if strictly trapped by *opponents'* tokens
    return run(true);
  }

  // Game flow

  // ======== AI turn driver ========
  async function aiTakeTurn(){
    // Re-entry guard: prevent double actions (especially after Undo/Redo)
    if (state.aiBusy) return;
    state.aiBusy = true;
    // This AI turn is now "owned"; clear the pending timer handle.
    if (state.aiTimer) { try { clearTimeout(state.aiTimer); } catch(e) {} state.aiTimer = null; }
    
    const P = currentPlayer();
    // Lock UI & annotate HUD while this AI is acting
    setAIThinking(true);
    setStatus(`${P.name} (AI) is thinking…`);

    try {

      // EARLY ROTATION GUARD:
      // Do NOT roll the die before drawing/placing at the start of a turn.
      // Only consider a pre-draw rotation if drawing is already consumed/locked this turn,
      // or we are already holding a card (i.e., mid-hand), or the board is saturated.
      if (!P.rollUsed && !P.tokenUsed &&
          (P.drawUsed || P.drawLocked || P.drawn != null || state.boardSaturated)) {
        const probeEarly = aiChooseTokenAction(P.id);
        if (!probeEarly) {
          rollDie();
          await sleep(aiSleepTime2);
          if (state.die && state.die !== 'X') {
            applyRotation();
            await sleep(aiSleepTime2);
          }
        }
      }

      // --- Forced placement turn handling (prevents AI deadlock at 3/3) ---
      if (state.forcePlace && P && P.ai) {
        // 1) Ensure we have a drawn card
        if (!P.drawn) { drawCard(); await sleep(aiSleepTime2); render(); updateHUD(); }
        // 2) If we can place NOW, do it (prefer heuristic; fall back to first legal)
        if (P.drawn && canPlaceDrawnNow(P.id)) {
          // Compute legal targets *now* and pass them into the heuristic
          const targetsNow = aiListLegalTargets(P.id);
          const heur = (typeof aiBestPlacementForDrawn === 'function'
                        ? aiBestPlacementForDrawn(P.id, targetsNow)
                        : null);
          const fb   = aiFirstLegalPlacementForDrawn(P.id);
          // Normalize to a single {x,y,rot} shape
          const pick = heur ? { x: heur.x, y: heur.y, rot: heur.rot }
                            : (fb ? { x: fb.at.x, y: fb.at.y, rot: fb.rot } : null);
          if (pick) {
            // Use the same commit path used elsewhere:
            // placeMode() → set rotateNew focus/rot → placeMode() again to commit.
            placeMode(); // compute highlights
            state.phase = 'place';
            state.subphase = 'rotateNew';
            state.rotateFocus = { x: pick.x, y: pick.y, original: 0 };
            state.previewRot  = pick.rot|0;
            render();
            await sleep(aiSleepTime);
            // Safety: re-check with base type (handles RT/RE/RS normalization).
            const baseType = baseDrawnType(P.drawn);
            if (aiIsReciprocalAt(baseType, pick.rot, pick.x, pick.y)) {
              placeMode(); // confirm placement via rotateNew path
            } else {
              bottomCard(); // conditions changed → don’t force a bad placement
            }          
            await sleep(aiSleepTime);
            // placed
            render(); updateHUD(); refreshSkipTags && refreshSkipTags();
            // Finish the turn normally
            endTurn(); state.aiBusy = false; return;
          }                          
        }
        // 3) If placement truly impossible, *waive* the force to avoid deadlock
        //    (Rules note: you already waive force when impossible for humans)
        if (!P.drawn || !canPlaceDrawnNow(P.id)) {
          state.forcePlace = false;
          P.skipCount = 0;
          setStatus('Forced placement waived (no legal placement available).');
          toast && toast('Force waived: no legal placement');
          // Continue with the rest of the AI turn as a normal (non-forced) turn
        }
      }

      // --- Handle AI stall recovery -----------------------------------------
      if (P._aiStalledTurns && P._aiStalledTurns >= 3) {
        // After 3 non-progress turns, try card cycling
        if (P.drawn && P.deck.draw.length > 0) {
          bottomCard();
          await sleep(aiSleepTime);
          drawCard();
          await sleep(aiSleepTime);
        }
        // Also, always roll the die for a new rotation opportunity
        rollDie();
        await sleep(aiSleepTime2);
        applyRotation();
        await sleep(aiSleepTime2);
        P._aiStalledTurns = 0;  // reset counter after recovery actions
      }
      
      // reset per-turn AI memory
      state.aiVisitedThisTurn = new Set();
      if (!P || !P.ai) return;   // safety

      // Step 1: Draw if needed (forced draw respected by existing logic)
      if (!P.drawn){
        drawCard();
        await sleep(aiSleepTime);
      }

      // Step 2: If holding a card, try to place/rotate it; else continue
      if (P.drawn){
        // --- FORCED ELBOW: must place now if legal --------------------------
        if (state.forceElbowFor === P.id && P.drawn === TrackCard.Elbow && canPlaceElbowNow(P.id)) {
          const targetsNow = aiListLegalTargets(P.id);
          // Prefer the heuristic picker; fall back to first legal that reciprocally attaches
          const pick = (typeof aiBestPlacementForDrawn === 'function')
            ? aiBestPlacementForDrawn(P.id, targetsNow)
            : null;
          const fb   = pick ? null : aiFirstLegalPlacementForDrawn(P.id);
          const chosen = pick
            ? { x: pick.x, y: pick.y, rot: pick.rot }
            : (fb ? { x: fb.at.x, y: fb.at.y, rot: fb.rot } : null);
          if (chosen) {
            placeMode(); // compute highlights
            state.phase = 'place';
            state.subphase = 'rotateNew';
            state.rotateFocus = { x: chosen.x, y: chosen.y, original: 0 };
            state.previewRot  = chosen.rot|0;
            render();
            await sleep(aiSleepTime);
            placeMode(); // commit placement
            // Clear elbow force after successful placement
            P.elbowSkipCount = 0;
            state.forceElbowFor = null;
            await sleep(aiSleepTime);
          } else {
            // If something changed and it’s no longer placeable, waive the force to avoid deadlock
            state.forceElbowFor = null;
          }
        }
        const D = P.drawn;
        // On full board, only rotations/replacements allowed — placeMode() already guards
        const targets = aiListLegalTargets(P.id);
        if (targets.length > 0){
          // If RS/RE/RT on existing tile: pick candidate cell of same base and rotate to best-degree
          if (D===TrackCard.RStraight || D===TrackCard.RElbow || D===TrackCard.RT){
            // Evaluate BOTH options:
            // A) rotate an existing matching tile, B) place a new base piece
            const baseByCard = {
              [TrackCard.RStraight]: 'Straight',
              [TrackCard.RElbow]:    'Elbow',
              [TrackCard.RT]:        'T',
            };
            const baseType = baseByCard[D];

            // Targets for this hand (mix of empties + any rotateExisting cells)
            const targets = aiListLegalTargets(P.id);

            // --- A) Best rotation on an existing matching tile
            let bestRotPick = null; // {x,y,rot,score,improve,curScore}
            for (const t of targets){
              const cell = state.board[t.y][t.x];
              if (!cell || !cell.track) continue;
              if (cell.track !== baseType) continue; // only rotate tiles of the same base type
              const br = aiBestRotationFor(t.x, t.y, P.id);
              // Keep the best-improving candidate but only if it sits in/adjacent to our network
              if (!bestRotPick || br.improve > bestRotPick.improve) {
                bestRotPick = { ...br, x:t.x, y:t.y };
              }
            }

            // --- B) Best new placement (as baseType) using the existing placement scorer
            const bestPlace = aiBestPlacementForDrawn(P.id, targets); // understands RS/RE/RT -> baseType

            // Decision: rotate if it truly improves, else place if possible, else bottom
            const MIN_IMPROVE = 1; // must be strictly better than current orientation
            const placeOK = !!bestPlace;
            // Early-game guard: keep building before fiddling with rotations.
            const netSize = connectedTrackFromCorner(P.id).length;
            const EARLY_NET_MIN = 4;
            // Rotation is allowed only if it improves, is local to our network,
            // and (if early) beats placement by a healthy margin.
            const rotLocal = bestRotPick && isInOrAdjacentToNet(bestRotPick.x, bestRotPick.y, P.id);
            const rotOK =
              bestRotPick &&
              bestRotPick.improve >= MIN_IMPROVE &&
              rotLocal &&
              (
                netSize >= EARLY_NET_MIN
                ? (!placeOK || bestRotPick.score >= bestPlace.score)              // normal comparison later in game
                : (placeOK ? (bestRotPick.score >= bestPlace.score + 8) : true)   // stricter in the opening
              );

            if (rotOK){            
              state.forcePlace = false; // ensure we’re not in forced placement mode
              // Perform rotation with animation
              placeMode();
              state.phase='place'; state.subphase='rotateExisting';
              state.rotateFocus = { x: bestRotPick.x, y: bestRotPick.y, original: state.board[bestRotPick.y][bestRotPick.x].rot };
              state.previewRot  = state.rotateFocus.original;
              render();
              await sleep(aiSleepTime);
              await animatePreviewRotation(bestRotPick.rot, 500);
              // Confirm rotation directly instead of re-entering placement mode
              applyRotation();
              await sleep(aiSleepTime);
            } else if (placeOK){
              // Perform placement with chosen rotation
              placeMode(); // compute highlights
              state.phase='place'; state.subphase='rotateNew';
              state.rotateFocus = { x: bestPlace.x, y: bestPlace.y, original: 0 };
              state.previewRot  = 0;
              render();
              await sleep(aiSleepTime);
              await animatePreviewRotation(bestPlace.rot, 500);
              placeMode(); // confirm placement
              await sleep(aiSleepTime);
            } else {
              bottomCard();
            }
          } else {
            // === Normal track (Straight / Elbow / T / Cross) ===
            // Pick the best legal cell+rotation and place it; if the score is awful, bottom.
            const bestPlace = aiBestPlacementForDrawn(P.id, targets);
            if (bestPlace) {
              placeMode(); // compute highlights
              state.phase='place'; state.subphase='rotateNew';
              state.rotateFocus = { x: bestPlace.x, y: bestPlace.y, original: 0 };
              state.previewRot  = 0;
              render();
              await animatePreviewRotation(bestPlace.rot, 500);
              // Safety: refuse to commit if the chosen rotation is not fully reciprocal now.
              {
                const baseType = baseDrawnType(P.drawn);
                if (!aiIsReciprocalAt(baseType, bestPlace.rot, bestPlace.x, bestPlace.y)) {
                  // If it somehow became illegal (e.g., after an Undo/Fix), cycle instead of misplacing.
                  bottomCard();
                } else {
                  // Snap preview to the intended rotation and commit via the usual path.
                  state.previewRot = bestPlace.rot|0;
                  placeMode(); // confirm placement via rotateNew path
                }
              }
              await sleep(aiSleepTime);
            } else {
              bottomCard(); // scorer said “not worth placing”
            }
          }        
        } else {
          // No legal placement → bottom the card (existing penalties/waivers apply)
          bottomCard();
        }
      }

      // Step 3: Token action (only if still available and something sensible exists)
      // If the move would not strictly improve distance, we skip it so we can rotate instead.
      if (!P.tokenUsed){
        const action = aiChooseTokenAction(P.id);
        if (action){
          // Enter token mode and perform the action
          tokenMode(); // highlights tokens/corner
          await sleep(aiSleepTime);
          if (action.type === 'place'){
            // Click corner
            const c = action.at;
            // Reuse the handler path (simulate click)
            const wasPhase = state.phase; // token
            state.subphase='select';
            const rect = { x:c.x, y:c.y };
            // Directly perform place by emulating the click branch
            const cCell = state.board[c.y][c.x];
            if (cCell.track && cCell.token == null){
              pushHistory('Token: place');
              cCell.token = P.id;
              state.players[P.id].tokens = (countTokens(P.id)|0);
              P.tokenUsed = true;
              tokenTag().textContent='Token: Used';
              btn('tokenBtn').disabled = true;
              state.phase='idle'; state.subphase=null; state.highlight=[]; state.tokenSelect=null;
              setStatus('AI placed a new token.');
              render(); updateHUD();
            }
          } else if (action.type === 'move'){
            // Select token, then choose destination
            tokenMode();
            state.subphase='select';
            state.tokenSelect = {x: action.from.x, y: action.from.y};
            const moves = reachableFrom(action.from, P.id);
            state.highlight = moves;
            // Emulate click on target branch
            const oppId = opponentCornerAt(action.to.x, action.to.y, P.id);
            pushHistory('Token: move');
            // clear source
            state.board[action.from.y][action.from.x].token = null;
            if (oppId != null){
              if (!P.reached) P.reached = new Set();
              const oppName = PLAYERS[oppId].name;
              P.reached.add(oppName);
              recordFinishIfNew(P); // <-- pass the scoring PLAYER, not the opponent's name
              if (state.board[action.to.y][action.to.x].token === P.id) {
                state.board[action.to.y][action.to.x].token = null;
              }
              P.tokensRemoved = Math.min(TOKENS_MAX, (P.tokensRemoved|0) + 1);
              setStatus(P.name + ' (AI) scored at ' + oppName + "'s corner!");
            } else {
              state.board[action.to.y][action.to.x].token = P.id;
              setStatus('AI moved a token.');
            }
            P.tokenUsed = true;
            tokenTag().textContent='Token: Used';
            btn('tokenBtn').disabled = true;
            state.phase='idle'; state.subphase=null; state.highlight=[]; state.tokenSelect=null;

            // remember landing to prevent bounce loops across turns
            if (!state.aiVisitedThisTurn) state.aiVisitedThisTurn = new Set();
            state.aiVisitedThisTurn.add(`${action.to.x},${action.to.y}`);
            if (!state.aiLastHop) state.aiLastHop = new Map();
            state.aiLastHop.set(P.id, `${action.to.x},${action.to.y}`);
            // also remember the traversed edge A→B to forbid immediate reverse B→A next turn
            if (!state.aiLastEdge) state.aiLastEdge = new Map();
            state.aiLastEdge.set(P.id, `${action.from.x},${action.from.y}|${action.to.x},${action.to.y}`);

            render(); updateHUD();
          }
        }
      }

      // Last chance: if we still haven't used the token and we haven't rolled yet,
      // try one die roll to open paths, then re-evaluate token action.
      if (!P.tokenUsed && !P.rollUsed) {
        const probe = aiChooseTokenAction(P.id);
        if (!probe) {
          rollDie(); await sleep(aiSleepTime);
          if (state.die && state.die !== 'X') {
            applyRotation();                    // uses your existing animations
            await sleep(aiSleepTime2);
            const again = aiChooseTokenAction(P.id);
            if (again) {
              tokenMode(); await sleep(aiSleepTime);
              if (again.type === 'place') {
                const c = again.at;
                const cCell = state.board[c.y][c.x];
                if (cCell.track && cCell.token == null) {
                  pushHistory('Token: place');
                  cCell.token = P.id;
                  currentPlayer().tokenUsed = true;
                }
              } else if (again.type === 'move') {
                pushHistory('Token: move');
                state.board[again.from.y][again.from.x].token = null;

                const oppId = opponentCornerAt(again.to.x, again.to.y, P.id);
                if (oppId != null) {
                  currentPlayer().reached ||= new Set();
                  currentPlayer().reached.add(PLAYERS[oppId].name);
                  recordFinishIfNew(currentPlayer());
                  currentPlayer().tokensRemoved = Math.min(TOKENS_MAX, (currentPlayer().tokensRemoved|0) + 1);
                } else {
                  state.board[again.to.y][again.to.x].token = P.id;
                }
                currentPlayer().tokenUsed = true;
              }
              // clean up token subphase HUD
              state.phase='idle'; state.subphase=null; state.highlight=[]; state.tokenSelect=null;
              if (!state.aiLastHop) state.aiLastHop = new Map();
              state.aiLastHop.set(currentPlayer().id, `${again.to.x},${again.to.y}`);

              render(); updateHUD();
            }
          }
        }
      }
      // Step 4: (very conservative) die roll for rotation
      await sleep(aiSleepTime);
      if (!P.rollUsed && !P.tokenUsed && shouldConsiderDieRoll(P)) {
        // --- Step 4: if we still have a drawn card, prefer to place/bottom.
        // (…omitted for brevity…)
        // If no drawn card / nothing to do, consider a die rotation —
        // but only if recent rotations actually helped.
        const probe = aiChooseTokenAction(P.id);
        if (!probe) {
          // Small per-player "rotation budget": aborted if past failures.
          // Reset whenever we make progress (placement or token move).
          P._failedRotationTurns = (P._failedRotationTurns|0);
          if (P._failedRotationTurns >= 2) {
            setStatus(`${P.name}: skipping die — recent rotations didn’t help`);
          } else {
            rollDie(); await sleep(aiSleepTime);
            if (state.die && state.die !== 'X') {
              applyRotation(); await sleep(aiSleepTime2);
              // Re-evaluate token action after rotation
              const again = aiChooseTokenAction(P.id);
              // If rotation did not unlock any move, count it as a failure.
              if (!again) {
                P._failedRotationTurns++;
              }
              // If it *did* unlock movement, we’ll reset the counter below.
              if (again) {
                tokenMode(); await sleep(aiSleepTime);
                if (again.type === 'move') {
                  P._failedRotationTurns = 0;
                  pushHistory('Token: move');
                  state.board[again.from.y][again.from.x].token = null;
                  const oppId = opponentCornerAt(again.to.x, again.to.y, P.id);
                  if (oppId != null) {
                    currentPlayer().reached ||= new Set();
                    currentPlayer().reached.add(PLAYERS[oppId].name);
                    recordFinishIfNew(currentPlayer());
                    currentPlayer().tokensRemoved = Math.min(TOKENS_MAX, (currentPlayer().tokensRemoved|0)+1);
                  } else {
                    state.board[again.to.y][again.to.x].token = P.id;
                  }
                  currentPlayer().tokenUsed = true;
                  if (!state.aiVisitedThisTurn) state.aiVisitedThisTurn = new Set();
                  state.aiVisitedThisTurn.add(`${again.to.x},${again.to.y}`);
                  if (!state.aiLastHop) state.aiLastHop = new Map();
                  state.aiLastHop.set(currentPlayer().id, `${again.to.x},${again.to.y}`);
                }
                state.phase='idle'; state.subphase=null; render(); updateHUD();
              }
            }
          }
        }
      }

      // --- Step 5: waive impossible force placement and end turn ---
      if (state.forcePlace) {
        const tgs = aiListLegalTargets(P.id);
        if (!tgs || !tgs.length) state.forcePlace = false;
      }
      if (state.forceElbowFor === P.id && P.drawn === TrackCard.Elbow && !canPlaceElbowNow(P.id)) {
        state.forceElbowFor = null;
      }

      // (Do not reset skip counters here; they persist across turns
      //  and are only cleared by a successful placement/rotation.)
      endTurn();

      // --- Watchdog: if forcePlace is active and a legal placement exists, finalize it now ---
      if (state.forcePlace && P.drawn && canPlaceDrawnNow(P.id)) {
        const ok = aiForceCommitDrawn(P.id);
        if (ok) {
          await sleep(aiSleepTime);
        } else {
          state.forcePlace = false;
        }
      }
    } finally {
      // Absolute safety net: never leave the UI locked if anything threw
      state.aiBusy = false;
      setAIThinking(false);
      try { render(); } catch(_) {}
      try { updateHUD && updateHUD(); } catch(_) {}
    }
  }

  // Commit the currently drawn card immediately by using the first legal highlight.
  // Chooses a rotation that yields at least one reciprocal connection if possible.
  function aiForceCommitDrawn(pid){
    const P = state.players[pid];
    if (!P || !P.drawn) return false;

    // Recompute legal highlights for the drawn card (don’t rely on stale UI state)
    const prev = { phase: state.phase, subphase: state.subphase, highlight: state.highlight.slice() };
    try {
      state.phase='place'; state.subphase=null; state.highlight=[];
      computePlaceHighlights();
      const t = (state.highlight && state.highlight[0]) || null;
      if (!t) return false;

      const baseType = baseDrawnType(P.drawn);
      // Pick a rotation that makes at least one reciprocal attachment; fall back to 0°
      let rot = 0, bestDeg = -1;
      for (const R of [0,90,180,270]){
        const deg = aiDegreeIfPlaced(baseType, R, t.x, t.y);
        if (deg > bestDeg){ bestDeg = deg; rot = R; }
      }

      // Commit via the same rotateNew path the UI uses
      state.phase = 'place';
      state.subphase = 'rotateNew';
      state.rotateFocus = { x: t.x, y: t.y, original: 0 };
      state.previewRot  = rot;
      render(); // optional

      // Confirm placement
      placeMode();
      return true;
    } finally {
      // placeMode() resets phase/subphase/highlight; nothing to restore
      if (prev) void prev; // no-op; left here to show we intentionally don't restore
    }
  }

  // Hypothetical path test: if we placed (type,rot) at (x,y), is there a reciprocal path
  // through existing tracks to any opponent corner?
  function aiHasPathToOppCornerWithHypothetical(type, rot, x, y, pid){
    const N = state.N;
    const norm = (n)=>((n%360)+360)%360;

    // Build local accessor that returns openings at (cx,cy) considering hypothetical at (x,y)
    function openingsAt(cx, cy){
      let t, r;
      if (cx===x && cy===y){
        t = type; r = norm(rot);
      } else {
        const c = state.board[cy][cx];
        if (!c || !c.track) return null;
        t = c.track; r = norm(c.rot|0);
      }
      return rotatedOpeningsType(t, r);
    }

    const goals = PLAYERS.filter(p=>p.id!==pid).map(p=>cornerFor(p.id));
    const goalStr = new Set(goals.map(g=>`${g.x},${g.y}`));

    const start = {x,y};
    const key = (p)=>`${p.x},${p.y}`;
    const seen = new Set([key(start)]);
    const q = [start];

    while (q.length){
      const cur = q.shift();
      if (goalStr.has(key(cur))) return true;

      const opens = openingsAt(cur.x, cur.y);
      if (!opens) continue;

      for (const [dx,dy] of opens){
        const nx = cur.x + dx, ny = cur.y + dy;
        if (!within(nx,ny)) continue;

        // reciprocal check with neighbor actual (or hypothetical if same x,y)
        const nOpens = openingsAt(nx, ny);
        if (!nOpens) continue;

        // Does neighbor have the opposite opening?
        const opp = [-dx, -dy];
        const hasOpp = nOpens.some(([ex,ey]) => ex===opp[0] && ey===opp[1]);
        if (!hasOpp) continue;

        const k = `${nx},${ny}`;
        if (!seen.has(k)){
          seen.add(k);
          q.push({x:nx,y:ny});
        }
      }
    }
    return false;
  }

  function newGame(){
    // Reset AI scheduling/guards
    if (state.aiTimer) { try { clearTimeout(state.aiTimer); } catch(e) {} state.aiTimer = null; }
    state.aiBusy = false;    
    // Use the in-game dropdown as the source of truth.
    const uiSize = parseInt(UI.boardSize().value, 10) || 9;
    state.N = uiSize;
    // Keep the saved setup aligned with the in-game choice (so Main Menu and reloads match).
    state.setup = state.setup || {};
    state.setup.boardSize = uiSize;
    try { localStorage.setItem('rr.setup', JSON.stringify(state.setup)); } catch {}
    state.board = makeBoard(state.N);
    initGearOffsets(state.N);

    // Determine # of active players from setup (defaults keep Red/Green active)
    const plannedPlayers = (state.setup?.players && Array.isArray(state.setup.players))
      ? state.setup.players
      : PLAYERS.map((_, i) => ({ active: i < 2 }));
    const activeCount = plannedPlayers.filter(p => p && p.active).length || 1;    

    state.players = PLAYERS.map(p=>{
      const cfg = (state.setup?.players && state.setup.players[p.id]) || { name:p.name, ai:false, active:(p.id<2) };
      return {
        id: p.id,
        name: cfg.name || p.name,
        color: p.color,
        pocket: p.pocket,
        ai: !!cfg.ai,
        active: !!cfg.active,
        deck: makeDeck(state.N, activeCount),  // ← pass active count here
        drawn:null, tokens:0, tokensRemoved:0,
        drawLocked:false, drawUsed:false, tokenUsed:false, rollUsed:false,
        skipCount: 0, elbowSkipCount: 0, forceElbow: false, forcePlaceNext: false
      };
    });    
    state.cornerLockTurns = PLAYERS.map(() => 0);
    state.cornerSealed    = PLAYERS.map(() => false);
    state.current = 0;
    state.forceElbowFor = null;

    // Reset undo/redo
    state.history = []; state.redo = [];
    state.turnHistory = []; state.turnRedo = [];
    state.finishOrder = [];
    // Clear AI hop/edge memory for a fresh game
    state.aiLastHop  = new Map();
    state.aiLastEdge = new Map();
    state.forcePlace = false;
    state.forceElbowFor = null;
    state.players.forEach(p => { p.skipCount = 0; p.elbowSkipCount = 0; });


    // Now start the turn; this will push the baseline snapshot
    startTurn();
    updateUndoButtons();

    setStatus('New Game → Draw → Place. First placement is your corner.');
    hideSoloAIPrompt();
    state.tokensHidden = false;
    state.tokensHiddenFor = null;
    state.rotAnims = [];
    state.ghostRotAnim = null;
    state._animating = false;
    if (Array.isArray(state.players)) for (const pl of state.players) pl.tokens = 0;
    refreshBoardSaturation();
      // >>> add this at the very end of newGame():
    requestAnimationFrame(()=>{
      resize();
      requestAnimationFrame(resize);
    });
  }

  function startTurn(){
     // Find the next *eligible* player without recursive calls.
    let hops = 0;
    while (hops < state.players.length) {
      const Ptest = state.players[state.current];
      // Skip colors that are not active from setup
      if (!Ptest.active) {
        state.current = (state.current + 1) % state.players.length;
        hops++;
        continue;
      }      
      const onBoardTest = countTokens(Ptest.id);
      const finished    = playerHasFinished(Ptest);
      const outOfTokens = ((Ptest.tokensRemoved|0) >= TOKENS_MAX) && onBoardTest === 0;
      if (!finished && !outOfTokens) break;          // active turn found

      // Skip this player and try the next
      toast(Ptest.name + (finished ? ' has finished (3/3 corners)' : ' has no tokens remaining') + ' — skipping turn.');
      state.current = (state.current + 1) % state.players.length;
      hops++;
    }
    if (hops >= state.players.length) {
      // No active players remain → game over
      state.phase = 'gameOver';
      // setStatus('<span style="color:#28d07a; font-weight:700;">All players have finished — game over.</span>');
      setStatus('<span class="ok">All players have finished — game over.</span>');
      updateHUD();
      return;
    }

    const P = currentPlayer();
    // Reset any per-turn token masking
    state.tokensHidden = false;
    state.tokensHiddenFor = null;
    resetTurnHistory();
    P.drawLocked=false; P.drawUsed=false; P.tokenUsed=false; P.rollUsed=false;
    P.rotatedThisTurn = false;  // track meaningful board action
    state.deadFixDoneThisTurn = false;
    state.phase='idle'; state.subphase=null; state.highlight=[]; state.hover=null; state.previewRot=0; state.die=null; state.tokenSelect=null; state.rotateFocus=null;
    // Open a short window where "force next turn" can activate
    state._enforceForcePlaceWindow = true;
    checkForcePlace();    
    // If we're entering a forced draw+place window, consume the arming flag now.
    if (state.forcePlace && currentPlayer().forcePlaceNext) {
      currentPlayer().forcePlaceNext = false;
    }
    // Close the window so mid-turn calls won’t trigger the force
    state._enforceForcePlaceWindow = false;
    // If forced placement is active this turn, surface the warning immediately
    if (state.forcePlace) {
      setStatus('Maximum track cards skipped — you must place a legal track before ending your turn.');
      toast('Forced placement: draw & place required');
    }

    // Ensure counter exists on first load (startTurn runs before newGame)
    if (!state.cornerLockTurns) state.cornerLockTurns = PLAYERS.map(()=>0);    

    // Corner lock tracker — trigger only when the corner is *truly* locally sealed:
    // corner has a track, both neighbors have tracks, and no single-tile rotation (corner or either neighbor)
    // can create a reciprocal connection into the board.
    const owner = currentPlayer();
    if (isCornerSealed(owner.id)) {
      state.cornerLockTurns[owner.id] = (state.cornerLockTurns[owner.id] || 0) + 1;
    } else {
      state.cornerLockTurns[owner.id] = 0;
    }
    // Immediate Corner Fix if THIS owner's corner is sealed (detected on last topology change)
    if (isCornerSealed(P.id)) {
      startCornerFixCross(P.id);
      return; // fix subphase renders/locks HUD
    }
    // --- Dead-Straight Fix (STRICT: trapped straight) ---
    if (state.phase !== 'cornerFix'){ // don't collide with Corner Fix UI
      const trapped = findAllTrappedStraights();
      if (trapped.length && !state.deadFixDoneThisTurn) {
        state.phase    = 'deadFix';
        state.subphase = 'pickDeadStraight';
        state.highlight = trapped;

        const msg = 'Dead-Straight Fix: replace ONE highlighted Straight with a Cross (free).';
        setStatus(msg);
        toast(msg);

        render();
        updateHUD();
        return; // wait for the click on one of the highlighted cells
      }
    }
    // --- end Dead-Straight Fix ---
    updateHUD();

    // === AI entry point ===
    // If only one *unfinished* AI remains in the game, pause and ask the user.
    if (P.ai && onlyOneAILeft() && !state.soloAIResumed){
      setAIThinking(false);
      showSoloAIPrompt();
      // Avoid updateHUD here; it can overwrite the pause message.
      render();
      return; // do NOT auto-run the AI until user clicks Continue
    }
    hideSoloAIPrompt();    
    if (P.ai) {
      // Small timeout to let the HUD render the start of turn before actions
      if (state.aiTimer) { try { clearTimeout(state.aiTimer); } catch(e) {} }
      state.aiTimer = setTimeout(() => {
        // Guard against re-entry (e.g., if Undo/Redo fired in the meantime)
        if (!state.aiBusy && currentPlayer() === P) {
          aiTakeTurn();
        }
      }, 120);    
    }    
  }

  function endTurnImmediate(){
    pushHistory('End Turn');

    // If the ending player is still holding a track card, count as a skip
    const endingP = state.players[state.current];
    if (endingP.drawn && isTrackCard(endingP.drawn)) {
      endingP.skipCount = Math.min(3, (endingP.skipCount|0) + 1);
      if (endingP.skipCount >= 3) {
        endingP.forcePlaceNext = true;  // enforce on their NEXT turn
      }      
    }

    // If they are holding an Elbow, count an elbow-skip too
    if (endingP.drawn === TrackCard.Elbow) {
      endingP.elbowSkipCount = Math.min(3, (endingP.elbowSkipCount|0) + 1);
      checkForceElbow(endingP);
    }    

    state.current=(state.current+1)%state.players.length;
    startTurn();
    refreshSkipTags();
    // Don't overwrite Fix prompts, GameOver, or any FORCED state after startTurn()
    const forcedNow =
      state.forcePlace ||
      (state.forceElbowFor != null && state.forceElbowFor === state.current);
    if (state.phase !== 'cornerFix' && state.phase !== 'deadFix' && state.phase !== 'gameOver' && !forcedNow) {
      setStatus('Turn passed.');
    }
    state.turnAdvancing=false;
  }

  function endTurn(){
    // Block ending the turn if an Elbow is being forced and can be placed now.
    const P = currentPlayer();

    // --- AI forced-placement safety net ---
    // If an AI is being forced to place and is holding a card, try to auto-commit now.
    if (P.ai && state.forcePlace && P.drawn) {
      // Try the best-scored option first; if none, fall back to first legal.
      const targetsNow = (typeof aiListLegalTargets === 'function') ? aiListLegalTargets(P.id) : [];
      let committed = false;

      if (targetsNow && targetsNow.length && typeof aiBestPlacementForDrawn === 'function') {
        const pick = aiBestPlacementForDrawn(P.id, targetsNow);
        if (pick) {
          // Commit via the same rotateNew path the UI uses
          state.phase = 'place';
          state.subphase = 'rotateNew';
          state.rotateFocus = { x: pick.x, y: pick.y, original: 0 };
          state.previewRot  = pick.rot|0;
          placeMode(); // confirm placement
          committed = true;
        }
      }
      if (!committed) {
        // Fallback to first legal reciprocal rotation if scorer returned null
        const ok = aiForceCommitDrawn(P.id);  // returns true if it committed one
        committed = !!ok;
      }

      if (committed) {
        // Placement satisfied the force; continue normal endTurn checks below
        updateHUD(); render();
      } else {
        // If we truly can't place this card, waive the force so we don't deadlock
        state.forcePlace = false;
      }
    }

    // NEW: if a force is active but this card cannot be placed, waive it now.
    if (state.forcePlace && P.drawn && !canPlaceDrawnNow(P.id)) {
      state.forcePlace = false;
    }
    // NEW: same for forced elbows — only block if an Elbow *can* be placed.
    if ((state.forceElbowFor === P.id) && (P.drawn === TrackCard.Elbow) && !canPlaceElbowNow(P.id)) {
      state.forceElbowFor = null;
    }
    // (Do not reset skip counters here. They reset only when a card is
    //  successfully placed/rotated, or when an Elbow is actually placed.)

    // Block ending the turn if an Elbow is being forced and *is* placeable.
    if ((state.forceElbowFor === P.id) && (P.drawn === TrackCard.Elbow) && canPlaceElbowNow(P.id)) {
      setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
      toast('Forced Elbow: End Turn disabled');
      return;
    }    
    if (state.forcePlace) {
      setStatus('Maximum track cards skipped — you must place a legal track before ending your turn.');
      toast('Forced placement: End Turn disabled');
      return;
    }    
    if(state.turnAdvancing) return;
    state.turnAdvancing=true;
    setTimeout(endTurnImmediate, 120);
  }

  // Draw (1/turn)
  function drawCard(){
    pushHistory('Draw');

    if (state.boardSaturated){
      const P = currentPlayer();
      if (!hasRotationInDeck(P)) {
        setStatus('Board is full of tracks — drawing is locked (no RS/RE/RC left in deck).');
        toast('Draw locked (board full; no rotations left)');
        return;
      }
      // else: rotations remain → drawing is allowed
    }
    const P=currentPlayer();
    if(P.drawLocked && !state.forcePlace){ setStatus('You bottomed this turn; drawing is locked until End Turn.'); return; }
    if(P.drawUsed   && !state.forcePlace){ setStatus('You have already drawn this turn. End Turn to draw again next turn.'); return; }

    if(P.drawn){ setStatus('Already holding a card. Place or Bottom.'); return; }
    if(P.deck.draw.length===0 && P.deck.discard.length>0){ P.deck.draw=shuffle(P.deck.discard.splice(0)); }
    if(P.deck.draw.length===0){ setStatus('Deck empty.'); return; }
    // --- AI: prefer connector cards (RS/RE/RT/RC) when available ----------
    if (P.ai){
      // look ahead in draw pile for a connector; if found, pull it now
      const i = P.deck.draw.findIndex(c =>
        c === TrackCard.RS || c === TrackCard.RE ||
        c === TrackCard.RT || c === TrackCard.RC
      );
      if (i >= 0){
        P.drawn = P.deck.draw.splice(i, 1)[0];
      } else {
        P.drawn = P.deck.draw.shift();
      }
    } else {
      P.drawn = P.deck.draw.shift();
    }

    // If max-skips is forcing placement but this card cannot be placed anywhere,
    // waive the force rule now to avoid deadlocks.
    checkForcePlace();
    updateHUD(); refreshSkipTags();
    // If elbow is being forced and an Elbow was drawn but can't be placed, waive the force.
    if (state.forceElbowFor === P.id && P.drawn === TrackCard.Elbow) {
      if (!canPlaceElbowNow(P.id)) {
        state.forceElbowFor = null;
        setStatus('Force (Elbow) waived — no legal Elbow placement.');
        updateHUD(); refreshSkipTags();
      }
    }
    // If player is over the elbow-skip threshold and just drew an Elbow
    // that can be placed now, activate the force immediately.
    if ((P.elbowSkipCount|0) >= 3 && P.drawn === TrackCard.Elbow && canPlaceElbowNow(P.id)) {
      state.forceElbowFor = P.id;
    }

    // While forced, we don't mark Draw as "Used" so the button stays enabled until a placement happens.
    P.drawUsed = state.forcePlace ? false : true;
    const elbowForceNow =
      (state.forceElbowFor === P.id) &&
      (P.drawn === TrackCard.Elbow) &&
      canPlaceElbowNow(P.id);
    updateHUD();
    // If this is a forced-placement turn (3/3 skips) and the drawn card CAN be placed,
    // show a clear, immediate warning that they must place it now.
    if (state.forcePlace && P.drawn && canPlaceDrawnNow(P.id)) {
      setStatus('Maximum track cards skipped — you must PLACE this drawn track before ending your turn.');
      toast('Forced placement: you must place this card');
    } else if (elbowForceNow) {
      setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
    } else {
      setStatus(`${P.name} drew ${P.drawn}. Click Place.`);
    }
  }

  // Placement includes adjacency to player's tokens (even if token is on opponent tile)
  function connectedTrackFromCorner(pid){
    const start = cornerFor(pid);
    const key = (x,y)=>x+','+y;
    const vis = new Set();
    const comp = [];
    const q = [];
    if (!within(start.x,start.y)) return comp;
    const startCell = state.board[start.y][start.x];
    if (!startCell.track){ return comp; } // No network yet if no track at corner
    q.push({x:start.x,y:start.y}); vis.add(key(start.x,start.y)); comp.push({x:start.x,y:start.y});
    while(q.length){
      const {x,y} = q.shift();
      const here = state.board[y][x];
      if(!here.track || here.track==='Block') continue;
      const opens = rotatedOpenings(here);
      for(const [dx,dy] of opens){
        const nx=x+dx, ny=y+dy; if(!within(nx,ny)) continue;
        const there = state.board[ny][nx];
        if(!there.track || there.track==='Block') continue;
        // openings must match in opposite direction
        const reciprocal = [-dx,-dy];
        const hasBack = rotatedOpenings(there).some(([adx,ady])=>adx===reciprocal[0] && ady===reciprocal[1]);
        if(!hasBack) continue;
        const k = key(nx,ny);
        if(!vis.has(k)){ vis.add(k); q.push({x:nx,y:ny}); comp.push({x:nx,y:ny}); }
      }
    }
    return comp;
  }

  function connectedTrackFrom(x0, y0){
    const key = (x,y)=>x+','+y;
    const vis = new Set();
    const comp = [];
    if (!within(x0,y0)) return comp;
    const start = state.board[y0][x0];
    if (!start.track) return comp;

    const q = [{x:x0,y:y0}];
    vis.add(key(x0,y0));
    comp.push({x:x0,y:y0});

    while(q.length){
      const {x,y} = q.shift();
      const here = state.board[y][x];
      if(!here.track || here.track==='Block') continue;

      for(const [dx,dy] of rotatedOpenings(here)){
        const nx = x+dx, ny = y+dy;
        if(!within(nx,ny)) continue;
        const there = state.board[ny][nx];
        if(!there.track || there.track==='Block') continue;
        if(!hasReciprocal(here, there, dx, dy)) continue;

        const k = key(nx,ny);
        if(!vis.has(k)){
          vis.add(k);
          q.push({x:nx,y:ny});
          comp.push({x:nx,y:ny});
        }
      }
    }
    return comp;
  }

  // Start: Code to prevent "corner-lockout"
  function cornerNeighbors(pid){ // returns [{x,y} corner, {x,y} n1, {x,y} n2]
    const c = cornerFor(pid);
    if (PLAYERS[pid].pocket === 'NW') return [c, {x:1,y:0},{x:0,y:1}];
    if (PLAYERS[pid].pocket === 'NE') return [c, {x:state.N-2,y:0},{x:state.N-1,y:1}];
    if (PLAYERS[pid].pocket === 'SE') return [c, {x:state.N-2,y:state.N-1},{x:state.N-1,y:state.N-2}];
    // SW
    return [c, {x:1,y:state.N-1},{x:0,y:state.N-2}];
  }

  // --- Corner seal detector (local, rotation-cost aware) ---
  // A corner is considered sealed iff BOTH adjacent neighbors exist AND, for each neighbor,
  // the minimal number of tiles you'd need to rotate (corner and/or that neighbor) to create
  // a reciprocal connection is > 1. In other words: there is NO one-tile fix.
  const RR_ROTATIONS = [0,90,180,270];
  function rotatedOpeningsType(type, rot){
    const r = snap90(rot|0);
    return OPENINGS[type].map(([dx,dy])=>rotDir([dx,dy], r));
  }
  function hasReciprocalTypes(typeA, rotA, typeB, rotB, dx, dy){
    const aOK = rotatedOpeningsType(typeA, rotA).some(([rx,ry])=>rx===dx && ry===dy);
    if(!aOK) return false;
    const bOK = rotatedOpeningsType(typeB, rotB).some(([rx,ry])=>rx===-dx && ry===-dy);
    return bOK;
  }
  function minRotationsToConnect(cornerCell, nbrCell, dx, dy){
    if(!cornerCell?.track || !nbrCell?.track) return Infinity;
    let best = Infinity;
    for (const rc of RR_ROTATIONS){
      for (const rn of RR_ROTATIONS){
        if (hasReciprocalTypes(cornerCell.track, rc, nbrCell.track, rn, dx, dy)){
          const cost = (rc===cornerCell.rot?0:1) + (rn===nbrCell.rot?0:1); // tile-count cost
          if (cost < best) best = cost;
        }
      }
    }
    return best;
  }

  function isCornerSealed(pid){
    const [co, n1, n2] = cornerNeighbors(pid);
    const corner = state.board[co.y][co.x];
    const a = state.board[n1.y][n1.x];
    const b = state.board[n2.y][n2.x];
    if (!corner.track) return false;
    if (!(a.track && b.track)) return false; // evaluate only once both neighbors exist

    // Only the explicit "perpendicular straights jam" counts as sealed.
    // Corner must be a Straight, and both adjacent tiles must be Straights, and
    // both must be perpendicular to the corner's orientation.
    if (corner.track !== 'Straight') return false;
    if (!(a.track === 'Straight' && b.track === 'Straight')) return false;
    const isH = (rot) => ((rot % 180) === 0);
    const cornerIsHorizontal = isH(corner.rot);
    const aIsHorizontal      = isH(a.rot);
    const bIsHorizontal      = isH(b.rot);
    // Horizontal corner jammed by two verticals, or vertical corner jammed by two horizontals
    return (cornerIsHorizontal && !aIsHorizontal && !bIsHorizontal) ||
          (!cornerIsHorizontal && aIsHorizontal && bIsHorizontal);
  }

  function startCornerFixCross(ownerId){
    state.phase = 'cornerFix';
    state.fixOwner  = ownerId;
    state.fixCorner = cornerFor(ownerId); // {x,y}
    state.highlight = [state.fixCorner];
    state.rotateFocus = null; state.previewRot = 0;
    // Show a persistent RED warning while the fix is pending
    setStatus('<span class="warn">Your corner is sealed. Click on your corner track to replace it with a cross track.</span>');
    updateHUD();
  }

  // Recompute corner seals after any topology change and toast when a new seal appears
  function onTopologyChanged(){
    if (!state.cornerSealed) state.cornerSealed = PLAYERS.map(()=>false);
    const prev = state.cornerSealed.slice();
    const now  = PLAYERS.map(p=>isCornerSealed(p.id));
    state.cornerSealed = now;
    for (let pid=0; pid<PLAYERS.length; pid++){
      if (now[pid] && !prev[pid]){
        // Keep toast visible long enough to read
        toast(PLAYERS[pid].name + " corner sealed — corner will be auto-fixed on their next turn.", 4500);      
      }
    }
    refreshBoardSaturation();
  }

  // Build a set of “friendly” cells for player pid:
  // your corner-connected network PLUS any network you’re currently on via tokens.
  function friendlyNetSet(pid){
    const set = new Set();
    // Corner-connected network (ownership-agnostic once connected)
    for (const p of connectedTrackFromCorner(pid)) {
      set.add(`${p.x},${p.y}`);
    }
    // Any components reachable from each of my tokens (may be on opponent tiles)
    for (const t of allTokensOf(pid)) {
      for (const p of connectedTrackFrom(t.x, t.y)) {
        set.add(`${p.x},${p.y}`);
      }
    }
    return set;
  }

  // Return true if there exists ANY non-friendly track cell within Manhattan <= radius
  // of your friendly network (corner net ∪ token nets). Used to justify rotations.
  function hasNearbyForeignTracks(pid, radius = 2){
    const net = friendlyNetSet(pid);
    if (net.size === 0) return false;
    const seen = new Set();
    const q = [];
    for (const k of net) {
      const [x,y] = k.split(',').map(n => n|0);
      q.push({x,y,d:0});
      seen.add(k);
    }
    const inNet = (x,y)=> net.has(`${x},${y}`);
    while (q.length){
      const {x,y,d} = q.shift();
      if (d > radius) continue;
      // Check this ring for foreign tracks
      const c = state.board[y]?.[x];
      if (c && c.track && !inNet(x,y) && c.owner !== pid) return true;
      // Expand 4-neighborhood
      for (const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
        const nx = x+dx, ny = y+dy;
        if (!within(nx,ny)) continue;
        const k2 = `${nx},${ny}`;
        if (seen.has(k2)) continue;
        seen.add(k2);
        q.push({x:nx, y:ny, d:d+1});
      }
    }
    return false;
  }  

  // For a hypothetical placement, count total reciprocal attachments, and how many are "friendly"
  // (friendly = neighbor owned by pid OR neighbor in pid's corner-connected network).
  function aiAttachmentBreakdown(type, rot, x, y, pid){
    let total = 0, friendly = 0;
    const opens = rotatedOpeningsType(type, rot);
    // FRIENDLY = corner-connected net ∪ every component reachable from any of my tokens
    const netSet = friendlyNetSet(pid);    
    for (const [dx,dy] of opens){
      const nx = x+dx, ny = y+dy;
      if (!within(nx,ny)) continue;
      const n = state.board[ny][nx];
      if (!n || !n.track) continue;
      if (!hasReciprocalTypes(type, rot, n.track, n.rot, dx, dy)) continue;
      total++;
      // Directly friendly?
      let isFriendly = (n.owner === pid) || netSet.has(`${nx},${ny}`);
      // NEW: if not, consider the neighbor's full connected component
      if (!isFriendly){
        const comp = connectedTrackFrom(nx, ny);
        for (const p of comp){
          if (netSet.has(`${p.x},${p.y}`)) { isFriendly = true; break; }
          const c = state.board[p.y][p.x];
          if (c && c.owner === pid) { isFriendly = true; break; }
        }
      }
      if (isFriendly) friendly++;
    }
    return { total, friendly };
  }

  // True if (x,y) is adjacent to anything "friendly":
  //  • directly owned by pid,
  //  • in pid's friendly set (corner net ∪ all token-connected nets), OR
  //  • NEW: any immediate neighbor whose *connected component* intersects pid's
  //    friendly set or an owned tile (captures whole-network adjacency).
  function hasFriendlyNeighbor(x, y, pid){
    const netSet = friendlyNetSet(pid);
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of dirs){
      const nx = x+dx, ny = y+dy;
      if (!within(nx,ny)) continue;
      const n = state.board[ny][nx];
      if (!n || !n.track) continue;
      // Direct checks
      if (n.owner === pid || netSet.has(`${nx},${ny}`)) return true;
      // NEW: check the neighbor's whole connected component
      const comp = connectedTrackFrom(nx, ny);
      for (const p of comp){
        if (netSet.has(`${p.x},${p.y}`)) return true;
        const c = state.board[p.y][p.x];
        if (c && c.owner === pid) return true;
      }
    }
    return false;
  }

  // Helper: is the cell (x,y) itself inside my connected network OR orthogonally adjacent to it?
  // Used to keep RS/RE/RT rotations local to my current plans (no random far-away twiddles).
  function isInOrAdjacentToNet(x, y, pid){
    const net = connectedTrackFromCorner(pid);
    if (!net.length) return false;
    const key = (p)=>`${p.x},${p.y}`;
    const set = new Set(net.map(key));
    if (set.has(`${x},${y}`)) return true;
    const neigh = [[1,0],[-1,0],[0,1],[0,-1]];
    for (const [dx,dy] of neigh){
      const nx=x+dx, ny=y+dy;
      if (!within(nx,ny)) continue;
      if (set.has(`${nx},${ny}`)) return true;
    }
    return false;
  }

  // For the current player's *drawn* card, does (x,y) have ANY rotation that
  // both reciprocally connects to neighbors AND gives degree>0?
  // Allow an exception only if this is the very first placement at the player’s corner.
  function attachOkForDrawnHere(pid, x, y){
    const P = state.players[pid];
    if (!P || !P.drawn) return false;
    const base  = baseDrawnType(P.drawn);
    const first = aiIsFirstPlacement(pid);
    const c     = cornerFor(pid);

  // 1) Prefer real attachments that touch *friendly* neighbors.
  for (const R of [0,90,180,270]){
    if (!aiIsReciprocalAt(base, R, x, y)) continue;
    const br = aiAttachmentBreakdown(base, R, x, y, pid);
    if (br.friendly > 0) return true;              // connects to your network (owned or connected)
  }
  // 2) If no attaching rotation exists, still allow *adjacent-only* placement
  //    as long as the empty cell is next to your friendly network.
  if (hasFriendlyNeighbor(x, y, pid)) return true;
  // 3) Corner seed exception: very first placement at your own corner.
  return first && x===c.x && y===c.y;
  }

  // … other helpers …

  // Count reciprocal attachments the new piece would make at (x,y,rot)
  function aiDegreeIfPlaced(type, rot, x, y){
    let degree = 0;
    const opens = rotatedOpeningsType(type, rot);
    for (const [dx,dy] of opens){
      const nx = x+dx, ny = y+dy;
      if (!within(nx,ny)) continue;
      const n = state.board[ny][nx];
      if (!n || !n.track) continue;
      if (hasReciprocalTypes(type, rot, n.track, n.rot, dx, dy)) degree++;
    }
    return degree;
  }

// Correctly compute placement highlight positions applying these rules:
// (1) Corner-connected network (net): ownership-agnostic, so if you connect into an opponent’s tracks, their connected network is usable too.
// (2) Owned tiles (myOwned): so you can still build from your isolated islands.
// (3) Tokens (myTokens): already supported.
// (4) RS/RE special: allows selecting any existing Straight/Elbow of the correct type for rotation.
function computePlaceHighlights(){
  const pid = currentPlayer().id;
  const myOwned = owned(pid);
  const net = connectedTrackFromCorner(pid);
  const myTokens = allTokensOf(pid);
  const adj = new Map();

  // Adjacent to networks connected to ANY of my tokens (ownership-agnostic)
  // This fixes the “two cells away via a connected straight” case.
  for (const t of myTokens){
    const comp = connectedTrackFrom(t.x, t.y);
    for (const p of comp){
      const neighs = [
        [p.x+1, p.y], [p.x-1, p.y],
        [p.x, p.y+1], [p.x, p.y-1]
      ];
      for (const [x,y] of neighs){
        if(!within(x,y)) continue;
        const c = state.board[y][x];
        if(!c.track && c.token==null){
          adj.set(x+','+y, {x,y});
        }
      }
    }
  }

  /* RS/RE/RT HIGHLIGHTS (rotate existing of same base type) */
  const D = currentPlayer().drawn;
  const base = baseDrawnType(D);
  if (D===TrackCard.RStraight || D===TrackCard.RElbow || D===TrackCard.RT){
    for(let yy=0; yy<state.N; yy++){
      for(let xx=0; xx<state.N; xx++){
        const c = state.board[yy][xx];
        if(c.track===base && c.track!=='Block'){
          adj.set(xx+','+yy, {x:xx,y:yy});
        }
      }
    }
  }

  // RC (Replaceable Cross): any existing track is a valid target
  if (D===TrackCard.RCross){
    for(let yy=0; yy<state.N; yy++){
      for(let xx=0; xx<state.N; xx++){
        const c = state.board[yy][xx];
        //if(c.track==='Cross'){ adj.set(xx+','+yy, {x:xx,y:yy}); }
        if(c.track){ adj.set(xx+','+yy, {x:xx,y:yy}); }
      }
    }
    // Also allow RC to be PLACED on your own empty corner (not just replace)
    const co = cornerFor(pid);
    const cCell = state.board[co.y][co.x];
    if(!cCell.track && cCell.token==null){
      adj.set(co.x+','+co.y, {x:co.x, y:co.y});
    }
    // And allow RC to be PLACED on any empty cell orthogonally adjacent to YOUR corner
    // when your corner already has a track (regardless of who owns that track).
    if (cCell.track){
      const neigh = [
        {x:co.x+1, y:co.y},
        {x:co.x-1, y:co.y},
        {x:co.x,   y:co.y+1},
        {x:co.x,   y:co.y-1},
      ];
      for (const n of neigh){
        if(!within(n.x,n.y)) continue;
        const cc = state.board[n.y][n.x];
        if(!cc.track && cc.token==null){
          adj.set(n.x+','+n.y, {x:n.x, y:n.y});
        }
      }
    }
  }
  // Adjacent to tracks connected to my corner (ownership-agnostic)
  for(const p of net){
    [[p.x+1,p.y],[p.x-1,p.y],[p.x,p.y+1],[p.x,p.y-1]].forEach(([x,y])=>{
      if(!within(x,y)) return;
      const c = state.board[y][x];
      if(!c.track && c.token==null) adj.set(x+','+y,{x,y});
    });
  }

  // Adjacent to ANY of my owned tracks (not just corner-connected)
  for(const p of myOwned){
    [[p.x+1,p.y],[p.x-1,p.y],[p.x,p.y+1],[p.x,p.y-1]].forEach(([x,y])=>{
      if(!within(x,y)) return;
      const c = state.board[y][x];
      if(!c.track && c.token==null) adj.set(x+','+y,{x,y});
    });
  }

  // Adjacent to any of my tokens
  for(const t of myTokens){
    [[t.x+1,t.y],[t.x-1,t.y],[t.x,t.y+1],[t.x,t.y-1]].forEach(([x,y])=>{
      if(!within(x,y)) return;
      const c = state.board[y][x];
      if(!c.track && c.token==null) adj.set(x+','+y,{x,y});
    });
  }

  // If this is truly the first placement and the only things in `adj` are rotation targets
  // (i.e., there are NO empty cells to place on), also allow placing on your own empty corner.
  const firstPlacement = (myOwned.length===0 && myTokens.length===0 && net.length===0);

  // Do we already have at least one EMPTY target in adj?
  let hasEmptyAdj = false;
  for (const v of adj.values()){
    const cc = state.board[v.y][v.x];
    if (!cc.track && cc.token==null) { hasEmptyAdj = true; break; }
  }

  if (firstPlacement && !hasEmptyAdj){
    const co = cornerFor(pid);
    const cCell = state.board[co.y][co.x];
    if (!cCell.track && cCell.token==null){
      // Add the player's own corner as a legal placement (in addition to rotate targets)
      adj.set(co.x+','+co.y, {x:co.x, y:co.y});
    }
  }

  // Finalize highlights
  {
    const P = currentPlayer();
    const all = Array.from(adj.values());
    // Keep all OCCUPIED targets (rotation/replacement like RS/RE/RT/RC),
    // but for EMPTY cells require an actual attachment (deg>0) unless it’s
    // the very first placement at your own corner.
    state.highlight = all.filter(({x,y}) => {
      const cell = state.board[y][x];
      // Always allow occupied targets when holding RS/RE/RT or RC (rotate/replace).
      if (cell.track){
        const d = P.drawn;
        if (d===TrackCard.RStraight || d===TrackCard.RElbow || d===TrackCard.RT) return true;
        if (d===TrackCard.RCross) return true;
        // If we’re holding a normal track but clicked an occupied cell,
        // this wasn’t meant to be shown anyway; fall through to false.
        return false;
      }
      // Empty cell: must attach (or be the first-at-corner seed).
      return attachOkForDrawnHere(P.id, x, y);
    });
  }
}

// Returns true if the current player's *currently drawn card* has at least one legal
// placement (using the same logic as computePlaceHighlights), without mutating highlight.
function canPlaceDrawnNow(pid){
  const P = currentPlayer();
  if (!P.drawn) return false;
  // Save/restore the mutable bits touched by computePlaceHighlights
  const prev = {
    highlight: state.highlight ? state.highlight.slice() : [],
    phase: state.phase,
    subphase: state.subphase,
  };
  try{
    // We only need the set of legal cells; computePlaceHighlights reads P.drawn
    // and populates state.highlight accordingly.
    computePlaceHighlights();
    return (state.highlight && state.highlight.length > 0);
  } finally {
    state.highlight = prev.highlight;
    state.phase = prev.phase;
    state.subphase = prev.subphase;
  }
}

// Can the current player place an Elbow *anywhere* right now?
function canPlaceElbowNow(playerId){
  const P = state.players.find(pp => pp.id === playerId);
  if (!P) return false;

  const saved = P.drawn;
  P.drawn = TrackCard.Elbow;
  let ok = false;
  try {
    if (typeof canPlaceDrawnNow === 'function') {
      ok = !!canPlaceDrawnNow(playerId);
    } else {
      const prevPhase = state.phase, prevSub = state.subphase, prevHL = state.highlight;
      state.phase = 'place'; state.subphase = null; state.highlight = [];
      computePlaceHighlights();
      ok = Array.isArray(state.highlight) && state.highlight.length > 0;
      state.phase = prevPhase; state.subphase = prevSub; state.highlight = prevHL;
    }
  } finally {
    P.drawn = saved; // restore
  }
  return ok;
}


function canPlaceCardNow(playerId, cardType){
  const P = state.players.find(pp => pp.id === playerId);
  if (!P) return false;

  const saved = P.drawn;
  P.drawn = cardType;

  let ok = false;
  try {
    if (typeof canPlaceDrawnNow === 'function') {
      ok = !!canPlaceDrawnNow(playerId);
    } else {
      const prevPhase = state.phase, prevSub = state.subphase, prevHL = state.highlight;
      state.phase = 'place'; state.subphase = null; state.highlight = [];
      computePlaceHighlights();
      ok = Array.isArray(state.highlight) && state.highlight.length > 0;
      state.phase = prevPhase; state.subphase = prevSub; state.highlight = prevHL;
    }
  } finally {
    P.drawn = saved;
  }
  return ok;
}

function baseDrawnType(card){
  if(card===TrackCard.RStraight) return TrackCard.Straight;
  if(card===TrackCard.RElbow)    return TrackCard.Elbow;
  if(card===TrackCard.RCross)    return TrackCard.Cross;
  if(card===TrackCard.RT)        return TrackCard.T;
  return card;
}

function isTrackCard(card){
  return [
    TrackCard.Straight, TrackCard.Elbow, TrackCard.Cross, TrackCard.T,
    TrackCard.RStraight, TrackCard.RElbow, TrackCard.RCross, TrackCard.RT
  ].includes(card);
}

function isRotationCard(card){
  return card===TrackCard.RStraight || card===TrackCard.RElbow || card===TrackCard.RCross || card===TrackCard.RT;
}

function hasRotationInDeck(P){
  const draw = (P.deck && Array.isArray(P.deck.draw)) ? P.deck.draw : [];
  const disc = (P.deck && Array.isArray(P.deck.discard)) ? P.deck.discard : [];
  const all  = draw.concat(disc);
  return all.some(c =>
    c===TrackCard.RStraight || c===TrackCard.RElbow || c===TrackCard.RCross || c===TrackCard.RT
  );
}

function checkForcePlace(){
  const P = currentPlayer();

  // 1) Activate ONLY at start of the player's NEXT turn (window set in startTurn()).
  if (!state.forcePlace) {
    const shouldActivate =
      (!!state._enforceForcePlaceWindow) &&
      (!state.boardSaturated) &&
      (!!P.forcePlaceNext);
    if (shouldActivate) {
      state.forcePlace = true;             // becomes sticky for this turn
      if (!P.drawn) {                      // allow/require a draw
        P.drawLocked = false;
        P.drawUsed   = false;
      }
    }
  }

  // 2) While forced, if they DO hold a card but it has ZERO legal placements,
  //    waive the force to avoid deadlocks (lets Bottom/end turn).
  if (state.forcePlace && P.drawn && !canPlaceDrawnNow(P.id)) {
    state.forcePlace = false;
  }
}

function checkForceElbow(P){
  // Threshold: must have skipped ≥3 Elbows *and* the board isn't saturated in a way that blocks placement.
  const mustForce = (P.elbowSkipCount|0) >= 3;
  if (mustForce && canPlaceElbowNow(P.id)) {
    state.forceElbowFor = P.id;   // only force if an Elbow can actually be placed now
  } else {
    state.forceElbowFor = null;   // waive otherwise (prevents deadlocks)
  }
}

  function placeMode(){
    // --- CONFIRM (RS/RE/RT): if we are rotating an existing tile and a focus exists, commit rotation ---
    if (state.phase === 'place' && state.subphase === 'rotateExisting' && state.rotateFocus) {
      const P = currentPlayer();
      const { x, y } = state.rotateFocus;
      const cell = state.board[y][x];

      // Commit the preview orientation (snap to 0/90/180/270)
      const toRot = snap90(state.previewRot ?? cell.rot);

      pushHistory('Rotation (RS/RE/RT) Confirm');
      cell.rot = toRot;

      // Discard the RS/RE/RT card and clear force/skip counters appropriately
      P.deck.discard.push(P.drawn);
      P.drawn = null;
      P.skipCount = 0;
      state.forcePlace = false;

      // Reset subphase & UI
      state.subphase   = null;
      state.rotateFocus = null;
      state.previewRot = 0;
      state.ghostRotAnim = null;

      pulse(x, y);
      state.phase = 'idle';
      state.highlight = [];
      state.hover = null;

      if (typeof onTopologyChanged === 'function') onTopologyChanged();
      render();
      updateHUD();
      setStatus('Rotation applied.');
      maybeAutoAdvance();
      return;
    }

    // --- CONFIRM: if we are in rotateNew (tap-to-rotate) and a focus exists, commit placement ---
    if (state.phase === 'place' && state.subphase === 'rotateNew' && state.rotateFocus) {
      const P = currentPlayer();
      const { x, y } = state.rotateFocus;
      const cell = state.board[y][x];

      // Commit at the preview angle
      const placedType = baseDrawnType(P.drawn);
      pushHistory('Place/Replace');

      // Preserve owner color if RC is replacing an existing track
      const prevHadTrack = !!cell.track;
      const prevOwner    = cell.owner;

      cell.track = placedType;
      cell.rot   = snap90(state.previewRot || 0);
      if (P.drawn === TrackCard.RCross && prevHadTrack) {
        // RC replaces: keep the replaced track's color
        cell.owner = prevOwner;
      } else {
        // New placement (or non-RC): adopt current player's color
        cell.owner = P.id;
      }

      P.deck.discard.push(P.drawn);
      P.drawn = null;
      P.skipCount = 0;
      state.forcePlace = false;
      if (placedType === TrackCard.Elbow) {
        P.elbowSkipCount = 0;
        state.forceElbowFor = null;
      }

      pulse(x,y);
      state.ghostRotAnim = null;
      state.subphase = null;
      state.rotateFocus = null;
      state.previewRot  = 0;
      state.phase='idle';
      state.highlight=[];
      state.hover=null;

      if (typeof onTopologyChanged === 'function') onTopologyChanged();
      render();
      updateHUD();
      setStatus('Placed. You cannot draw again this turn.');
      maybeAutoAdvance();
      return;
    }

    const P=currentPlayer();
    if (state.boardSaturated && !isRotationCard(P.drawn)){
      setStatus('Board is full of tracks — only RS/RE/RC can be placed (rotate/replace).');
      toast('Place disabled (board full; use RS/RE/RC)');
      return;
    }    
    if(!P.drawn){ setStatus('Draw a card first.'); return; }
    state.phase='place'; state.subphase=null; computePlaceHighlights(); updateHUD();
    // If we're in a forced-place state but *nothing* is legal for this card,
    // waive the force so Bottom/End Turn become available.
    if (state.forcePlace && (!state.highlight || state.highlight.length===0)) {
      state.forcePlace = false;
      updateHUD();
    }
    // Mirror waiver for elbow-specific forcing (only if holding an Elbow)
    if (state.forceElbowFor === P.id && P.drawn === TrackCard.Elbow) {
      if (!state.highlight || state.highlight.length === 0) {
        state.forceElbowFor = null;
        updateHUD();
      }
    }
    if (!state.highlight || state.highlight.length === 0){
      setStatus('No legal placement exists for this card. Use Bottom to cycle it without penalty.');
      toast('No legal placement for this card');
    } else {
      setStatus('Placement: hover to preview, click to confirm. Rotate with Q/E.');
    }
  }

 function bottomCard(){
  const P=currentPlayer();
  // If max-skips is forcing a placement and the drawn card CAN be placed somewhere,
  // Bottom is not allowed this turn.
  if (state.forcePlace && P.drawn && canPlaceDrawnNow(P.id)) {
    setStatus('Maximum track cards skipped — you must PLACE your drawn track before ending your turn.');
    toast('Forced placement: Bottom is disabled');
    return;
  }  
  // Block Bottom if this player is forced to place an Elbow and it is placeable now.
  if ((state.forceElbowFor === P.id) && (P.drawn === TrackCard.Elbow) && canPlaceElbowNow(P.id)) {
    setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
    toast('Forced Elbow: Bottom is disabled');
    return;
  }

  if(!P.drawn){ setStatus('Nothing to bottom.'); return; }
   // Check if this card has *no* legal placement anywhere on the board.
   // On a full board, normal tracks have no legal placements; RS/RE/RC may still be placeable.
   const noPlace = !canPlaceDrawnNow(P.id);
   pushHistory(noPlace ? 'Bottom (No-Place, no penalty)' : 'Bottom');
   const bottomed = P.drawn;                  // capture BEFORE clearing
   P.deck.draw.push(bottomed);                // move to bottom
   P.drawn = null;                            // clear the hand
   if (noPlace){
     // --- NO-PENALTY BOTTOM ---
     // Do NOT lock drawing; do NOT increment any skip counters.
     // BUT: this counts as your one draw for the turn (cannot chain Bottoms).
     P.drawLocked   = false;   // not locked, just "used"
     P.drawUsed     = true;    // ← mark Draw as Used for this turn
     setStatus('No legal placement exists for that card — moved to bottom without penalty. Draw is now Used for this turn.');
   } else {
    // --- NORMAL BOTTOM (with penalties) ---
    P.drawLocked = true;
    // Only penalize if they truly did nothing meaningful this turn
    const penalize = !(P.tokenUsed || P.rotatedThisTurn);
    // And never penalize if this was an elbow-forced turn with *no* legal elbow
    const forcedButImpossible =
      (state.forceElbowFor === P.id) && !canPlaceElbowNow(P.id);
    if (penalize && !forcedButImpossible) {
      P.skipCount = Math.min(3, (P.skipCount|0) + 1);
      if (P.skipCount >= 3) {
        P.forcePlaceNext = true;   // do NOT force mid-turn; enforce next turn
       // Inform immediately that next turn will be forced
       toast('Max skips reached: forced placement next turn');        
      }      
      if (bottomed === TrackCard.Elbow) {
        P.elbowSkipCount = Math.min(3, (P.elbowSkipCount|0) + 1);
        checkForceElbow(P);                // ← elbow-only checker
      }
    }
    // If we waived elbow force, clear it explicitly
    if (forcedButImpossible) state.forceElbowFor = null;
    setStatus(
      (P.skipCount >= 3)
        ? 'Bottomed. Drawing is locked until End Turn.<br><span class="warn">Maximum track cards skipped — you must place a legal track next turn.</span>'
        : 'Bottomed. Drawing is locked until End Turn.'
    );
   }
 
   state.phase='idle'; state.highlight=[]; state.hover=null;
   checkForcePlace();
   updateHUD(); refreshSkipTags();
   maybeAutoAdvance();
 }

  // Token flow (select-first; corner placement allowed if < TOKENS_MAX)
  function tokenMode(){
    const P=currentPlayer();
    if(P.tokenUsed){ setStatus('Token action already used this turn.'); return; }
    state.phase = 'token'; state.subphase='select'; state.highlight=[]; state.hover=null; state.tokenSelect=null;

    const myTokens = allTokensOf(P.id);
    const options = [...myTokens];
    const corner = cornerFor(P.id);
    const cCell = state.board[corner.y][corner.x];
    const myCount = countTokens(P.id);
    // Safety: treat "removed" as max(tokensRemoved, reached.size) so old snapshots can’t over-place
    const reachedCount = P.reached ? (P.reached instanceof Set ? P.reached.size : new Set(P.reached).size) : 0;
    const effectiveRemoved = Math.max((P.tokensRemoved|0), reachedCount);
    const lifetimePlaced = Math.min(TOKENS_MAX, effectiveRemoved + myCount);

    if (lifetimePlaced < TOKENS_MAX && cCell.track && cCell.token == null) {
      options.push(corner);
    }
    state.highlight = options;
    if(options.length===0){
      // No tokens on board and no corner placement available — do NOT auto-advance.
      setStatus('No tokens to apply an action to. Place a token at your corner first or Draw/Place tracks.');
      toast('No tokens to act on');
      // Keep Token Action available: exit token mode without consuming the action.
      state.phase='idle'; state.subphase=null; state.tokenSelect=null; state.highlight=[]; state.hover=null;
      render(); updateHUD();
      return;
    } 
    setStatus('Token: click a token to move OR click your corner to place a new token (lifetime total of 3).');
    updateHUD();
  }

  // Rotation: meshed gears + hints (direction-correct; visible on all cells)
  function rollDie(){
    const P=currentPlayer();
    if(P.rollUsed){ setStatus('You have already rolled this turn.'); return; }
    pushHistory('Roll');
    const r = Math.floor(Math.random()*DIE_FACES.length); state.die = DIE_FACES[r];
    P.rollUsed = true;
    dieTag().textContent='Die: '+state.die; rollTag().textContent='Roll: Used';
    setStatus('Die rolled: '+state.die+'. Hints show per-cell rotation. Click Apply to rotate.');
    btn('applyBtn').disabled = (state.die==='X');
    render();
  }
  function thetaFor(face){ if(face==='CW90') return 90; if(face==='CCW90') return -90; if(face==='DEG180') return 180; return 0; }
  function mod360(a){ return (((a%360)+360)%360); }
  function snap90(a){ return mod360(Math.round(a/90) * 90); }

  // === Rotation animation helpers (anchor: RR_ROTATE_ANIMS) ===
  // Define these BEFORE render() and applyRotation() (consts are not hoisted)
  const easeInOutQuad = t => (t<0.5 ? 2*t*t : -1 + (4 - 2*t) * t);
  function shortestArc(from,to){ // both degrees [0,360)
    let d = ((to - from + 540) % 360) - 180; // in (-180,180]
    return d;
  }

  function startRotateAnim(x,y, fromDeg, toDeg, dur=500){
    state.rotAnims.push({ x, y, from:fromDeg, to:toDeg, t0: performance.now(), dur });
    ensureAnimLoop();
  }

  // Drive frames while any animation is active (tile tweens or ghost tween)
  function hasActiveAnim(){
     return (state.rotAnims && state.rotAnims.length>0) || !!state.ghostRotAnim || !!state.gearSpinAnim;
  }
  function ensureAnimLoop(){
    if (state._animating) return;
    state._animating = true;
    const step = () => {
      if (hasActiveAnim()){
        render();
        requestAnimationFrame(step);
      } else {
        state._animating = false;
      }
    };
    requestAnimationFrame(step);
  }

  // Current animated angle for the ghost (falls back to previewRot)
  function ghostAngle(){
    const a = state.ghostRotAnim;
    if(!a) return state.previewRot || 0;
    const now = performance.now();
    const u = Math.min(1, (now - a.t0) / a.dur);
    const k = easeInOutQuad(u);
    const ang = a.from + shortestArc(a.from, a.to) * k;
    if (u >= 1) state.ghostRotAnim = null;   // auto-clear when finished
    return mod360(ang);
  }

  function startGearSpinPulse(baseDeg, dur){
    // baseDeg is the die’s base rotation: +90 (CW90), -90 (CCW90), or +180 (DEG180)
    state.gearSpinAnim = { base: baseDeg, t0: performance.now(), dur };
    ensureAnimLoop(); // reuse the existing RAF driver
  }

  function applyRotation(){
    if(!state.die || state.die==='X') return;
    pushHistory('Apply Rotation');
    const base = thetaFor(state.die);
    startGearSpinPulse(base, RR_APPLY_TWEEN_MS);  // spin gears only during this Apply tween

    let rotated=0;
    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
      const cell = state.board[y][x];
      const sign = ((x + y) % 2 === 0) ? 1 : -1;

      // 1) Commit the new gear offset for EVERY cell (track or not).
      if (state.gearOffset && state.gearOffset[y]) {
        const pending = sign * base; // same parity as tiles
        state.gearOffset[y][x] = mod360((state.gearOffset[y][x] || 0) + pending);
      }

      // 2) Only rotate/tween tiles that actually have tracks.
      if(!cell.track || cell.track==='Block') continue;
      const fromRot = cell.rot;
      const toRot   = snap90(cell.rot + sign*base);
      startRotateAnim(x,y, fromRot, toRot, RR_APPLY_TWEEN_MS);
      cell.rot = toRot;
      rotated++;
      }
    }

    state.die=null; dieTag().textContent='Die: —'; btn('applyBtn').disabled = true;
    setStatus('Meshed rotation applied to '+rotated+' track cell(s).');
    if (rotated > 0) {
      const P = currentPlayer();
      P.rotatedThisTurn = true;    // NEW
    }    
    onTopologyChanged();
    render();
    maybeAutoAdvance();
  }

  // Auto-advance heuristic
  function maybeAutoAdvance(){
    const P=currentPlayer();
    if(!P.drawUsed && !P.drawLocked && !P.drawn) return;
    if(P.drawn) return;
    if(!P.tokenUsed){
      const myTokens = allTokensOf(P.id);
      const corner = cornerFor(P.id);
      const cCell = state.board[corner.y][corner.x];
      const myCount = countTokens(P.id);
      let hasOption = false;
      if(myCount < TOKENS_MAX && cCell.track && cCell.token==null){ hasOption = true; }
      if(!hasOption){
        for(const t of myTokens){
          if(reachableFrom(t, P.id).length>0){ hasOption=true; break; }
        }
      }
      if(hasOption) return;
    }
    if(!P.rollUsed) return;
    // If player is now out (no tokens remaining at all), end turn automatically.
    if (((P.tokensRemoved|0) >= TOKENS_MAX) && countTokens(P.id) === 0) {
      setStatus(P.name + ' has no tokens remaining. Auto-advancing turn…');
      endTurn();
      return;
    }    
    setStatus('No actions remaining. Auto-advancing turn…');
    endTurn();
  }

  // Canvas interactions
  function toCell(px,py){
    const x = Math.floor((px - state.pad) / state.cell);
    const y = Math.floor((py - state.pad) / state.cell);
    return {x,y};
  }

  const canvasEl=UI.canvas();
  canvasEl.addEventListener('mousemove', (e)=>{
    const rect=canvasEl.getBoundingClientRect(); const {x,y}=toCell(e.clientX-rect.left, e.clientY-rect.top);
    if(x<0||y<0||x>=state.N||y>=state.N){ state.hover=null; render(); return; }
    state.hover={x,y};
    render();
  });
  canvasEl.addEventListener('click', (e)=>{
    // Block human interactions while AI is executing its turn
    const cp = currentPlayer && currentPlayer();
    if (state.lockInput && cp && cp.ai){ toast('AI is acting — please wait.'); return; }
    if(state.turnAdvancing) return;
    const rect=canvasEl.getBoundingClientRect(); const {x,y}=toCell(e.clientX-rect.left, e.clientY-rect.top);
    if(x<0||y<0||x>=state.N||y>=state.N) return;

    // ----- Corner Fix: replace owner's corner with Cross (free) -----
    if (state.phase === 'cornerFix'){
      const P = currentPlayer();
      const c = state.fixCorner;             // set by startCornerFixCross(ownerId)
      if (!(c && x===c.x && y===c.y)){
        toast('Click your corner to apply the fix.');
        return;
      }
      const cell = state.board[y][x];
      pushHistory('Corner Fix');
      cell.track = 'Cross';
      cell.owner = P.id;
      cell.rot   = 0;                        // Cross is symmetric
      state.phase='idle'; state.highlight=[]; state.hover=null;
      state.fixOwner=null; state.fixCorner=null;
      if (typeof onTopologyChanged === 'function') onTopologyChanged();
      render(); updateHUD(); setStatus('Corner fixed: Cross placed.');
      return;
    }
    
    // Dead-Straight Fix click (one free replacement per turn)
    if (state.phase === 'deadFix' && state.subphase === 'pickDeadStraight'){
      const hit = state.highlight && state.highlight.some(h => h.x===x && h.y===y);
      if (hit){
        const cell = state.board[y][x];

        // Replace the Straight with a Cross; keep owner & token intact
        pushHistory('Dead-Straight Fix');
        state.deadFixDoneThisTurn = true;
        cell.track = 'Cross';
        cell.rot   = 0;   // Cross is symmetric
        // owner, token remain unchanged

        toast('Dead-Straight fixed: placed Cross.');

        // Clear subphase; resume normal turn
        state.phase = 'idle';
        state.subphase = null;
        state.highlight = [];
        state.hover = null;

        if (typeof onTopologyChanged === 'function') onTopologyChanged();
        render();
        updateHUD();
        setStatus('Dead-Straight fixed. Continue your turn.');
      }
      return; // consume click during deadFix phase
    }

    // PLACE phase
    if(state.phase==='place')
    {
      const P=currentPlayer(); 
      const cell=state.board[y][x];

      // If a ghost rotation tween is running (from Q/E), queue this click
      // and execute it AFTER the tween lands on the exact 90° angle.
      if (state.ghostRotAnim) {
        const wasRotateCommit =
          (state.subphase==='rotateExisting' &&
          state.rotateFocus &&
          state.rotateFocus.x===x &&
          state.rotateFocus.y===y);

        const legal = wasRotateCommit || state.highlight.some(h=>h.x===x&&h.y===y);
        if (!legal) { toast('Not a legal cell'); return; }

        const finalTo = state.ghostRotAnim.to; // the tween's target angle (a clean multiple of 90)
        waitForGhostThen(()=>{
          // Snap preview to the tween’s landed angle and perform the same action as if clicked now
          state.previewRot = ((finalTo % 360) + 360) % 360;

          // Re-enter the same logic paths below, but without the early return.
          if (wasRotateCommit) {
            // === RS/RE rotateExisting COMMIT (same as original commit block) ===
            const toRot = state.previewRot;
            cell.rot = toRot;
            P.deck.discard.push(P.drawn); P.drawn = null;
            P.skipCount = 0;
            state.forcePlace = false;
            state.subphase = null; state.rotateFocus = null; state.previewRot = 0;
            pulse(x,y);
            state.phase='idle'; state.highlight=[]; state.hover=null;
            onTopologyChanged();
            render(); updateHUD(); setStatus('Rotation applied.'); maybeAutoAdvance();
          } else {
            // === Normal placement path (same as original “place track” block) ===
            if (cell.track){ toast('Cell occupied'); return; }
            if(state.rotateFocus){
              const rf=state.rotateFocus; const cc=state.board[rf.y][rf.x];
              cc.rot=rf.original; state.rotateFocus=null; state.subphase=null;
            }
            const placedType = baseDrawnType(P.drawn);
            pushHistory('Place/Replace');
            cell.track=placedType; cell.rot=snap90(state.previewRot); cell.owner=P.id;
            P.deck.discard.push(P.drawn); P.drawn=null;
            P.skipCount = 0;
            state.forcePlace = false;
            if (placedType === TrackCard.Elbow) {
              P.elbowSkipCount = 0;
              state.forceElbowFor = null;
            }
            pulse(x,y);
            state.ghostRotAnim = null;
            state.phase='idle'; state.highlight=[]; state.hover=null;
            onTopologyChanged(); updateHUD();
            setStatus('Placed. You cannot draw again this turn.');
            maybeAutoAdvance();
          }
        });
        return; // stop now; the queued action above will run after the tween finishes
      }

      // RS/RE: COMMIT rotation FIRST if we're clicking the selected tile
      if (state.subphase==='rotateExisting'
         && state.rotateFocus
         && state.rotateFocus.x===x
         && state.rotateFocus.y===y) {
        // Commit the preview orientation (no re-animate; user already saw the ghost at final angle)
        const toRot   = snap90(state.previewRot ?? cell.rot);
        cell.rot = toRot;
        P.deck.discard.push(P.drawn); P.drawn = null;
        P.skipCount = 0;
        state.forcePlace = false;     // placing satisfies the force rule
        state.subphase = null; state.rotateFocus = null; state.previewRot = 0;
        pulse(x,y);
        state.ghostRotAnim = null;
        state.phase='idle'; state.highlight=[]; state.hover=null;
        onTopologyChanged();
        render(); updateHUD(); setStatus('Rotation applied.'); maybeAutoAdvance();
        return;
      }

      // --- NEW-PLACEMENT: COMMIT after rotation if tapping same focused cell ---
      if (state.subphase==='rotateNew' && state.rotateFocus &&
          state.rotateFocus.x===x && state.rotateFocus.y===y) {
        const P = currentPlayer();
        const cell = state.board[y][x];

        // Commit at the preview angle
        const placedType = baseDrawnType(P.drawn);
        pushHistory('Place/Replace');
        cell.track = placedType;
        cell.rot   = snap90(state.previewRot || 0);
        cell.owner = P.id;

        P.deck.discard.push(P.drawn);
        P.drawn = null;
        P.skipCount = 0;
        state.forcePlace = false;

        if (placedType === TrackCard.Elbow) {
          P.elbowSkipCount = 0;
          state.forceElbowFor = null;
        }

        pulse(x,y);
        state.ghostRotAnim = null;
        state.subphase = null;
        state.rotateFocus = null;
        state.previewRot  = 0;
        state.phase='idle';
        state.highlight=[];
        state.hover=null;

        if (typeof onTopologyChanged === 'function') onTopologyChanged();
        render();
        updateHUD();
        setStatus('Placed. You cannot draw again this turn.');
        maybeAutoAdvance();
        return;
      }

      // === RS/RE: ENTER rotateExisting BEFORE legal-cell gating ===
      // Allow rotating ANY existing tile of the same base type (even on first turn).
      if (cell.track && (P.drawn===TrackCard.RStraight || P.drawn===TrackCard.RElbow || P.drawn===TrackCard.RT)) {
        const base = baseDrawnType(P.drawn);
        if (cell.track === base) {
          state.subphase='rotateExisting';
          state.rotateFocus = {x,y, original: cell.rot};
          state.previewRot  = cell.rot;
          state.hover       = {x,y};
          state.highlight   = [{x,y}];   // show selection
          setStatus('Rotating ' + base + ': use ⟲/⟳ or Q/E to rotate; click again or press “Confirm” to apply.');
          render(); updateHUD();
          return;
        }
      }
      // (commit handled above)
      // For everything else, we still require the cell to be legal
      const legal = state.highlight.some(h=>h.x===x&&h.y===y);
      if(!legal){ toast('Not a legal cell'); return; }

      // If it's a legal EMPTY cell for a NEW placement, enter rotateNew subphase first
      if (!cell.track && state.subphase !== 'rotateExisting') {
        state.subphase    = 'rotateNew';
        state.rotateFocus = { x, y, original: 0 };
        // Start preview angle from whatever the ghost shows now
        state.previewRot  = mod360(ghostAngle() || 0);
        state.hover       = {x,y};
        state.highlight   = [{x,y}]; // show focus box
        setStatus('Rotate with ⟲/⟳ (or Q/E), then tap again to place.');
        render();
        updateHUD();
        return;
      }

      // RC: Replaceable Cross — replace any existing track and KEEP the replaced tile's color
      if (P.drawn === TrackCard.RCross && cell.track) {
        pushHistory('Place/Replace');
        const prevOwner = cell.owner;      // preserve color
        cell.track = 'Cross';
        cell.rot   = 0;                     // Cross is symmetric
        cell.owner = (prevOwner != null ? prevOwner : P.id);

        // discard card, clear force/skip counters, and commit
        P.deck.discard.push(P.drawn);
        P.drawn = null;
        P.skipCount = 0;
        state.forcePlace = false;

        pulse(x,y);
        state.phase='idle';
        state.subphase=null;
        state.rotateFocus=null;
        state.previewRot=0;
        state.highlight=[];
        state.hover=null;
        if (typeof onTopologyChanged === 'function') onTopologyChanged();
        render(); updateHUD();
        setStatus('Replaced with Cross. You cannot draw again this turn.');
        maybeAutoAdvance();
        return;
      }

      // (RS/RE enter block moved above legal check)
      if(cell.track){ toast('Cell occupied'); return; }
      if(state.rotateFocus){ const rf=state.rotateFocus; const cc=state.board[rf.y][rf.x]; cc.rot=rf.original; state.rotateFocus=null; state.subphase=null; }
          const placedType = baseDrawnType(P.drawn);
          pushHistory('Place/Replace');
          cell.track=placedType; cell.rot=snap90(state.previewRot); cell.owner=P.id;
          P.deck.discard.push(P.drawn); P.drawn=null;
          P.skipCount = 0;
          state.forcePlace = false;   // placing satisfies the force rule
          if (placedType === TrackCard.Elbow) {
            P.elbowSkipCount = 0;
            state.forceElbowFor = null;       // clear the elbow force after placing one
          }
          pulse(x,y);
          state.ghostRotAnim = null;  // clear any in-progress ghost tween
          state.phase='idle'; state.highlight=[]; state.hover=null; onTopologyChanged(); updateHUD(); setStatus('Placed. You cannot draw again this turn.');
          maybeAutoAdvance();
          return;
    }

    // TOKEN phase
    if(state.phase==='token'){
      const P=currentPlayer();
      if(state.subphase==='select'){
        const isMine = state.board[y][x].token===P.id;
        if(isMine){
          const from = {x,y};
          const moves = reachableFrom(from, P.id);
          if (moves.length===0) {
            // Stay on this player's turn: warn, and keep selection active.
            setStatus('That token is stuck (no connected destinations). Choose a different token or click End Turn.');
            toast('Token cannot move');

            // Re-highlight only tokens that CAN move (plus corner, if eligible).
            const movable = allTokensOf(P.id).filter(t => reachableFrom(t, P.id).length > 0);
            const corner = cornerFor(P.id);
            const cCell  = state.board[corner.y][corner.x];
            const canPlace = countTokens(P.id) < TOKENS_MAX && cCell.track && cCell.token == null;

            state.tokenSelect = null;               // remain in subphase='select'
            state.highlight   = canPlace ? [...movable, corner] : movable;
            render();
            return;
          }          
          state.tokenSelect = from; state.highlight = moves; state.subphase='target';
          setStatus('Token: choose a connected destination (pipes may traverse opponents).'); render(); return;
        }
        const corner = cornerFor(P.id);
        if(corner.x===x && corner.y===y){
          const cCell = state.board[corner.y][corner.x];
          const myCount = countTokens(P.id);
          // Safety: don’t let legacy snapshots over-place
          const reachedCount = P.reached ? (P.reached instanceof Set ? P.reached.size : new Set(P.reached).size) : 0;
          const effectiveRemoved = Math.max((P.tokensRemoved|0), reachedCount);
          const lifetimePlaced = Math.min(TOKENS_MAX, effectiveRemoved + myCount);

          if (lifetimePlaced >= TOKENS_MAX) {
            toast('You have already used all 3 tokens.');
            return;
          }
          if(!(cCell.track && (cCell.token==null))){ toast('Corner must have a track and be open.'); return; }
          pushHistory('Token: place');
          cCell.token = P.id; state.players[P.id].tokens = myCount+1;
          P.tokenUsed = true; tokenTag().textContent='Token: Used'; btn('tokenBtn').disabled = true;
          state.phase='idle'; state.subphase=null; state.highlight=[]; state.tokenSelect=null; setStatus('New token placed at your corner.'); render(); updateHUD();
          maybeAutoAdvance();
          return;
        }
        toast('Select your token to move, or your open corner to place a new one.');
      } else if(state.subphase==='target'){
        const legal = state.highlight.some(h=>h.x===x&&h.y===y);
        if(!legal){ toast('Pick a connected destination.'); return; }
        const from = state.tokenSelect;
        // Move / Score handling (fix: always remove moving token on scoring; never leave extra token on board)
        pushHistory('Token: move');
        // 1) Clear the moving token from its source cell (always)
        if (from && within(from.x, from.y) && state.board[from.y][from.x].token === P.id) {
          state.board[from.y][from.x].token = null;
        }
        const oppId = opponentCornerAt(x, y, P.id);
        const destHasOwner = (oppId != null && state.board[y][x].token === oppId);
        if (oppId != null) {
          // 2) Reached an opponent's corner → record score
          if (!P.reached) P.reached = new Set();
          const oppName = PLAYERS[oppId].name;
          P.reached.add(oppName);
          recordFinishIfNew(P);
          // 3) Do NOT leave our token on the destination (corner stays with its owner’s token if present)
          if (state.board[y][x].token === P.id) {
            state.board[y][x].token = null;
          }
          // 4) Count this token as removed from play
          P.tokensRemoved = Math.min(TOKENS_MAX, (P.tokensRemoved|0) + 1);
          setStatus(P.name + ' scored at ' + oppName + "'s corner!");
        } else {
          // Normal move to a non-scoring cell → place our token there
          state.board[y][x].token = P.id;
          setStatus('Token moved.');
        }
        // If that move completed 3/3 corners, auto-end the turn immediately.
        if (playerHasFinished(currentPlayer())) {
          const P = currentPlayer();
          P.tokenUsed = true;                // consume the action
          tokenTag().textContent='Token: Used';
          btn('tokenBtn').disabled = true;
          state.phase='idle'; state.subphase=null;
          state.highlight=[]; state.tokenSelect=null;
          render(); updateHUD();
          setStatus(P.name + ' completed all three corners — auto-advancing turn…');
          endTurn();
          return; // stop; we just advanced the turn
        }

        currentPlayer().tokenUsed = true; tokenTag().textContent='Token: Used'; btn('tokenBtn').disabled = true;
              state.phase='idle'; state.subphase=null; state.highlight=[]; state.tokenSelect=null; render(); updateHUD();
              maybeAutoAdvance();
              return;
      }
    }
  });

  // === ROTATE PREVIEW KEYS (anchor: RR_ROTATE_KEYS) ===
  window.addEventListener('keydown', (e)=>{
    if (state.phase !== 'place') return;
    const k = e.key.toLowerCase();
    if (k !== 'q' && k !== 'e') return;

    // Where is the mouse?
    const h = state.hover;
    const hoveringEmpty = !!(h && within(h.x, h.y) && (()=>{
      const c = state.board[h.y][h.x];
      return !c.track && c.token == null;
    })());

    // Allow rotation if:
    // 1) We are actively rotating an existing tile (RS/RE after click), OR
    // 2) We are hovering an EMPTY cell (previewing a new placement)
    if (!(state.subphase === 'rotateExisting' || hoveringEmpty)) {
      // Optional: UI nudge when RS/RE is drawn and you're over an occupied cell
      // const d = currentPlayer().drawn;
      // if (d===TrackCard.RStraight || d===TrackCard.RElbow) setStatus('Click a track to rotate');
      return;
    }

    const stepDeg = (k==='q' ? -90 : 90);      // Q=CCW, E=CW
    rotatePreview(stepDeg);
    const from = ghostAngle();                 // current animated angle (if mid-tween)
    const to   = mod360(from + stepDeg);
    state.previewRot   = to;                   // target angle
    state.ghostRotAnim = { from, to, t0: performance.now(), dur: PREVIEW_ROT_TWEEN_MS };
    ensureAnimLoop();
    render();                                  // draw first frame immediately    
  });  

  // Wire buttons
  btn('newGameBtn').addEventListener('click', newGame);
  document.getElementById('returnMenuBtn').addEventListener('click', ()=>{
    const ok = confirm('Return to Main Menu? Current game progress will be lost unless you saved.');
    if (!ok) return;
      window.location.href = 'MainMenu.html';
  });
  btn('drawBtn').addEventListener('click', drawCard);
  btn('placeBtn').addEventListener('click', placeMode);
  btn('bottomBtn').addEventListener('click', bottomCard);
  const endTurnBtn = document.getElementById('endTurnBtn');
  endTurnBtn.addEventListener('click', endTurn);
  const overrideBtn = document.getElementById('overrideBtn');
  overrideBtn.addEventListener('click', ()=>{
    state.forcePlace = false;
    endTurnBtn.disabled = false;
    overrideBtn.style.display = 'none';
    toast('Override used: End Turn enabled.');
  });
  btn('rotateCCWBtn').addEventListener('click', ()=>rotatePreview(-90));
  btn('rotateCWBtn').addEventListener('click',  ()=>rotatePreview(+90));
  btn('tokenBtn').addEventListener('click', tokenMode);
  // Auto-unhide when entering Token Action
  btn('tokenBtn').addEventListener('click', () => {
    ensureTokensVisible();
  });
  // Toggle button for Hide/Unhide
  btn('toggleTokensBtn').addEventListener('click', () => {
    const P = currentPlayer();
    // Only meaningful for the human player's turn
    if (P && !P.ai) setTokensHidden(!state.tokensHidden);
  });
  btn('rollBtn').addEventListener('click', rollDie);
  btn('applyBtn').addEventListener('click', applyRotation);
  UI.vizEdges().addEventListener('change', render);

  btn('saveBtn').addEventListener('click', saveGame);
  btn('loadBtn').addEventListener('click', () => document.getElementById('loadFile').click());
  document.getElementById('loadFile').addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) loadFromFile(f);
    e.target.value = ''; // reset so the same file can be chosen again later
  });

  function rotatePreview(stepDeg){
    if (state.phase !== 'place') return;

    // Can rotate if: rotating an existing tile OR rotating a new placement focus
    const rotatingExisting = (state.subphase === 'rotateExisting' && state.rotateFocus);
    const rotatingNew      = (state.subphase === 'rotateNew'      && state.rotateFocus);

    if (!(rotatingExisting || rotatingNew)) return;

    const from = ghostAngle();
    const to   = snap90(from + stepDeg);
    state.previewRot   = to;
    state.ghostRotAnim = { from, to, t0: performance.now(), dur: PREVIEW_ROT_TWEEN_MS };
    ensureAnimLoop();
    render();
  }

  // Undo/Redo buttons
  document.getElementById('undoGlobalBtn').addEventListener('click', undoGlobal);
  document.getElementById('redoGlobalBtn').addEventListener('click', redoGlobal);
  document.getElementById('undoTurnBtn').addEventListener('click', undoTurn);
  document.getElementById('redoTurnBtn').addEventListener('click', redoTurn);

  function ordinal(n){
    const s = ["th","st","nd","rd"], v = n % 100;
    return n + (s[(v-20)%10] || s[v] || s[0]);
  }

  // Returns [{pid, name, color, score, active}]
  function collectScores(){
    return state.players.map(p => {
      const reachedSet = p.reached
        ? (Array.isArray(p.reached) ? new Set(p.reached) : p.reached)
        : new Set();
      return {
        pid: p.id,
        name: p.name,
        color: p.color,
        active: !!p.active,
        ai: !!p.ai,
        score: reachedSet.size|0
      };
    });
  }

  // Sort by score DESC, keep stable by pid
  function computeStandings(){
    const rows = collectScores();
    const order = Array.isArray(state.finishOrder) ? state.finishOrder.slice() : [];
    const byPid = new Map(rows.map(r => [r.pid, r]));

    // A) Finished players in recorded finish order
    const finishedOrdered = [];
    for (const pid of order){
      const r = byPid.get(pid);
      if (r && r.score >= 3) finishedOrdered.push(r);
    }
    // Include any finished players not in finishOrder (e.g., legacy saves), pid-stable
    const finishedUnordered = rows
      .filter(r => r.score >= 3 && !order.includes(r.pid))
      .sort((a,b) => a.pid - b.pid);

    // B) Unfinished players by score (desc), pid-stable
    const unfinished = rows
      .filter(r => r.score < 3 && !order.includes(r.pid))
      .sort((a,b) => (b.score - a.score) || (a.pid - b.pid));

    const arranged = [...finishedOrdered, ...finishedUnordered, ...unfinished];
    arranged.forEach((r,i) => r.place = i+1);      // unique places 1..N
    arranged.forEach(r => { r.isLeader = (r.place === 1); });
    return arranged;
  }

  function renderStandingsTop(){
    const el = document.getElementById('standingsTop');
    if (!el) return;

    // Compute standings and filter to ACTIVE players only
    const rowsAll = computeStandings();
    const rows = rowsAll.filter(r => r.active);

    // Do we have any score on the board yet?
    const anyScore = rowsAll.some(r => r.score > 0);

    const parts = rows.map(r => {
      const baseTitle = `${r.name} (${r.score}/3)`;
      const dot = `<span class="dot" style="background:${r.color}"></span>`;
      const badge = r.ai ? `<span class="aiBadge">AI</span>` : '';

      let display = baseTitle;
      if (anyScore) {
        const samePlaceCount = rowsAll.filter(x => x.place === r.place && x.active).length;
        const label = (samePlaceCount > 1) ? `T-${ordinal(r.place)}` : ordinal(r.place);
        display = `${label}: ${baseTitle}`;
      }

      const content = `<span class="standText">${display}${badge}</span>`;
      if (anyScore && r.place === 1) {
        return `<div class="standLine"><b>${dot}${content}</b></div>`;
      } else {
        return `<div class="standLine">${dot}${content}</div>`;
      }
    });

    // One entry per line (no separators), each line is non-wrapping
    el.innerHTML = parts.join('');
  }

  function renderCornerScoreTable(){
    const tb = document.querySelector('#cornerScoreTable tbody');
    if (!tb || !state || !state.players) return;

    const N = state.N;

    const quadText = (pocket) => {
      switch (pocket) {
        case 'NW': return 'NW (0,0)';
        case 'NE': return `NE (${N-1},0)`;
        case 'SE': return `SE (${N-1},${N-1})`;
        case 'SW': return `SW (0,${N-1})`;
        default:   return pocket || '—';
      }
    };

    // Compute standings once
    const standings = computeStandings();
    const byPid = new Map(standings.map(r => [r.pid, r]));

    // NEW: detect if any score exists yet (game-wide)
    const anyScore = standings.some(r => r.score > 0);

    for (const p of state.players) {
      const pid = p.id;
      const tr  = tb.querySelector(`tr[data-pid="${pid}"]`);
      if (tr) tr.classList.toggle('inactiveRow', !p.active);

      // Build score string from this player's reached set
      const reachedSet = p.reached
        ? (Array.isArray(p.reached) ? new Set(p.reached) : p.reached)
        : new Set();
      const letters = reachedSet.size
        ? Array.from(reachedSet).map(n => String(n)[0]).join(', ')
        : '';
      const scoreStr = `${reachedSet.size}/3${letters ? ` [${letters}]` : ''}`;

      const qEl  = document.getElementById(`quad-${pid}`);
      const sEl  = document.getElementById(`score-${pid}`);
      const plEl = document.getElementById(`place-${pid}`);

      if (qEl) qEl.textContent = (p.pocket ? (() => {
        switch (p.pocket) {
          case 'NW': return 'NW (0,0)';
          case 'NE': return `NE (${N-1},0)`;
          case 'SE': return `SE (${N-1},${N-1})`;
          case 'SW': return `SW (0,${N-1})`;
          default:   return p.pocket;
        }
      })() : '—') + (p.active ? '' : ' (inactive)');

      if (sEl) sEl.textContent = p.active ? scoreStr : '—';

      if (plEl) {
        const row = byPid.get(pid);

        if (!p.active) {
          // Inactive players: no place shown
          plEl.textContent = '—';
          plEl.style.fontWeight = '';
        } else if (!anyScore) {
          // Before first score anywhere: hide places
          plEl.textContent = '—';
          plEl.style.fontWeight = '';
        } else if (row) {
          // After first score: show ordinals (ties get T- prefix)
          const samePlaceCount = standings.filter(r => r.place === row.place && r.active).length;
          const label = (samePlaceCount > 1) ? `T-${ordinal(row.place)}` : ordinal(row.place);
          plEl.textContent = label;
          // Bold leaders (1st place)
          plEl.style.fontWeight = (row.place === 1) ? '700' : '';
        }
      }
      const nmEl = document.getElementById(`pname-${pid}`);
      const abEl = document.getElementById(`aibadge-${pid}`);
      if (nmEl) nmEl.textContent = p.name || nmEl.textContent;
      if (abEl) abEl.style.display = p.ai ? '' : 'none';
    }
  }

    // Start/stop a requestAnimationFrame loop that advances the global gear angle
  function startGearSpin(){
    if (!GEAR_SPIN_ENABLED) return;
    if (state._spinRAF) cancelAnimationFrame(state._spinRAF);
    state._lastSpinT = performance.now();

    const step = (t) => {
      const dt = t - state._lastSpinT;                // milliseconds
      state._lastSpinT = t;

      // degrees per millisecond = RPM * 360 / 60000
      const degPerMs = (GEAR_SPIN_RPM * 360) / 60000;
      state.gearSpinDeg = (state.gearSpinDeg + degPerMs * dt) % 360;

      // Repaint only if the image is ready (avoids useless work before onload)
      if (gearReady) render();

      state._spinRAF = requestAnimationFrame(step);
    };
    state._spinRAF = requestAnimationFrame(step);
  }

  function stopGearSpin(){
    if (state._spinRAF) cancelAnimationFrame(state._spinRAF);
    state._spinRAF = null;
  }

  function updateHUD(){
    (function(){
      const b = document.getElementById('placeBtn');
      if (!b) return;
      const confirming =
        (state.phase === 'place') &&
        !!state.rotateFocus &&
        (state.subphase === 'rotateNew' || state.subphase === 'rotateExisting');
      b.textContent = confirming ? 'Confirm' : 'Place';
    })();

    if (state.phase === 'gameOver') {
      const P = currentPlayer();
      turnTag().textContent  = 'Turn: —';
      phaseTag().textContent = 'Phase: gameOver';
      drawnTag().textContent = 'Card: —';
      drawTag().textContent  = 'Draw: —';
      dieTag().textContent   = 'Die: —';
      rollTag().textContent  = 'Roll: —';
      tokenTag().textContent = 'Token: —';
      // Disable all action buttons
      ['drawBtn','placeBtn','bottomBtn','tokenBtn','rollBtn','applyBtn','endTurnBtn','undoGlobalBtn','redoGlobalBtn','undoTurnBtn','redoTurnBtn']
        .forEach(id => { const b = document.getElementById(id); if (b) b.disabled = true; });
      renderCornerScoreTable();
      renderStandingsTop();
      render();
      updateUndoButtons();
      return;
    }

    renderCornerScoreTable();
    renderStandingsTop();

    const P=currentPlayer();

    // Update Hide/Unhide button state and label
    (function(){
      const b = document.getElementById('toggleTokensBtn');
      if (!b) return;
      const hidden = !!state.tokensHidden;
      b.textContent = hidden ? 'Unhide' : 'Hide';
      // Prefer disabling during AI turns/thinking
      b.disabled = (currentPlayer()?.ai === true) || !!state.aiBusy;
    })();

    if (state.phase === 'deadFix'){
      const rotationsRemain = hasRotationInDeck(P);      // Keep the messaging visible while the selection is up
      drawTag().textContent = (state.phase === 'deadFix')
        ? 'Draw: Locked (Dead-Straight Fix)'
        : (P.drawUsed
            ? 'Draw: Used'
            : (rotationsRemain ? 'Draw: Ready (Board Full: rotations available)'
                               : 'Draw: Locked (Board Full)'));
      // Keep Skipped tag accurate during deadFix (prevents stale "⚠" from older UI states)
      (function(){
        const el = document.getElementById('skippedTag');
        if(!el) return;
        const skipCount = (P && P.skipCount) ? P.skipCount : 0;
        el.textContent = 'Skipped: ' + skipCount + '/3';
        if (skipCount >= 3) {
          el.classList.add('warn');
          el.textContent += '  ⚠ Maximum skipped';
        } else {
          el.classList.remove('warn');
        }
      })();                               
      setStatus('Dead-Straight Fix: replace ONE highlighted Straight with a Cross (free).');
      render();
      updateUndoButtons();
      return; // ← prevent later HUD paths from overwriting this status
    }

    if (state.boardSaturated){
      const P = currentPlayer();
      const elbowForceNow =
        (state.forceElbowFor === P.id) &&
        (P.drawn === TrackCard.Elbow) &&
        canPlaceElbowNow(P.id);      
      const rotationsRemain = hasRotationInDeck(P);
      const holdingRotation = isRotationCard(P.drawn);

      // Tag
      drawTag().textContent = state.phase === 'deadFix'
        ? 'Draw: Locked (Dead-Straight Fix)'
        : (rotationsRemain ? 'Draw: Ready (Board Full: rotations available)' : 'Draw: Locked (Board Full)');

      // Basic tags that should still reflect current state
      turnTag().textContent  = 'Turn: ' + currentPlayer().name + ' (' + currentPlayer().pocket + ')';
      phaseTag().textContent = 'Phase: ' + state.phase;
      dieTag().textContent   = 'Die: ' + (state.die || '—');
      rollTag().textContent  = 'Roll: ' + (currentPlayer().rollUsed ? 'Used' : 'Ready');
      tokenTag().textContent = 'Token: ' + (currentPlayer().tokenUsed ? 'Used' : 'Ready');
      drawnTag().textContent = 'Card: ' + (P.drawn || '—');   // ← keep the Card tag in sync

      // Score tag MUST keep updating even when board is full
      (function(){
        const el = document.getElementById('scoreTag');
        if(!el) return;
        const P = currentPlayer();
        const reached = P.reached ? P.reached : new Set();
        const list = (reached && reached.size) ? Array.from(reached).map(n=>n[0]).join(', ') : '';
        el.textContent = 'Score: ' + (reached ? reached.size : 0) + '/3' + (list ? (' ['+list+']') : '');
      })();

      // Skipped tag MUST also refresh here (otherwise stale "⚠ Maximum skipped" can stick)
      (function(){
        const el = document.getElementById('skippedTag');
        if(!el) return;
        const skipCount = (P && P.skipCount) ? P.skipCount : 0;
        el.textContent = 'Skipped: ' + skipCount + '/3';
        if (skipCount >= 3) {
          el.classList.add('warn');
          el.textContent += '  ⚠ Maximum skipped';
        } else {
          el.classList.remove('warn');
        }
      })();

      // Elbows Skipped tag also refreshes here
      (function(){
        const el = document.getElementById('elbowSkippedTag');
        if(!el) return;
        const ecount = (P && P.elbowSkipCount) ? P.elbowSkipCount : 0;
        el.textContent = 'Elbows Skipped: ' + ecount + '/3';
        if (ecount >= 3) {
          el.classList.add('warn');
          el.textContent += elbowForceNow
            ? '  ⚠. This elbow must be now be placed'
            : '  ⚠ Next Elbow must be placed';
        } else {
          el.classList.remove('warn');
        }
      })();
      // Buttons: draw allowed only if rotations remain; place allowed only if holding RS/RE/RC
      const forcedOK = state.forcePlace && !P.drawn; // unchanged forced-draw semantics
      btn('drawBtn').disabled   = !!P.drawn || P.drawUsed || ((!rotationsRemain) && !forcedOK);
      btn('placeBtn').disabled  = !P.drawn || !holdingRotation;   // only RS/RE/RC can act on full board
      // Bottom blocked while elbow is being forced and placeable
      btn('bottomBtn').disabled = !P.drawn || state.forcePlace || elbowForceNow;
      // End Turn blocked while elbow is being forced and placeable
      endTurnBtn.disabled = !!elbowForceNow;
      overrideBtn.style.display = 'none';
      btn('tokenBtn').disabled = !!currentPlayer().tokenUsed;
      btn('rollBtn').disabled  = !!currentPlayer().rollUsed;
      btn('applyBtn').disabled = !(state.die && state.die!=='X');
      if (elbowForceNow) {
        setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
      }
      // During forced placement, Bottom must not be available if the drawn card can be placed now.
      try {
        const P = currentPlayer && currentPlayer();
        const mustPlaceNow = !!(state.forcePlace && P && P.drawn && canPlaceDrawnNow(P.id));
        const bottomBtn = document.getElementById('bottomBtn');
        if (bottomBtn) {
          bottomBtn.disabled = bottomBtn.disabled || mustPlaceNow;
          bottomBtn.title = mustPlaceNow ? 'Disabled: forced placement this turn' : '';
        }
      } catch {}            

      render();
      updateUndoButtons();
      return;
    }

    // Corner Fix HUD lock: show a RED warning and disable all actions until the free Cross is applied
    if (state.phase === 'cornerFix'){
      // Make sure the tags reflect the current subphase
      turnTag().textContent='Turn: '+P.name+' ('+P.pocket+')';
      phaseTag().textContent='Phase: cornerFix';
      setStatus('<span class="warn">Your corner is sealed. Click on your corner track to replace it with a cross track.</span>');
      drawTag().textContent = 'Draw: Locked (Corner Fix)';
      btn('drawBtn').disabled   = true;
      btn('placeBtn').disabled  = true;
      btn('bottomBtn').disabled = true;
      btn('tokenBtn').disabled  = true;
      btn('rollBtn').disabled   = true;
      btn('applyBtn').disabled  = true;
      endTurnBtn.disabled = true;
      overrideBtn.style.display = 'none';

      render();
      updateUndoButtons();

      return;
    }

    if (P.drawn && (P.drawn===TrackCard.Straight || P.drawn===TrackCard.Elbow ||
        P.drawn===TrackCard.Cross || P.drawn===TrackCard.RStraight ||
        P.drawn===TrackCard.RElbow || P.drawn===TrackCard.RCross)) {
      setStatus(`Skipped: ${P.skipCount}/3`);
    }

    turnTag().textContent='Turn: '+P.name+' ('+P.pocket+')';
    phaseTag().textContent='Phase: '+state.phase;
    drawnTag().textContent='Card: '+(P.drawn || '—');
    dieTag().textContent='Die: '+(state.die || '—');
    drawTag().textContent = 'Draw: ' + (
      (state.forcePlace && !P.drawn) ? 'Ready (Forced)' :
      (P.drawLocked ? 'Locked' : (P.drawUsed ? 'Used' : 'Ready'))
    );    
    rollTag().textContent='Roll: '+(P.rollUsed ? 'Used' : 'Ready');
    // Deterministic draw gating; allow draw during forced-draw even if previously locked/used
    const _forcedDrawOK = state.forcePlace && !P.drawn;
    btn('drawBtn').disabled = !!P.drawn || ((P.drawLocked || P.drawUsed) && !_forcedDrawOK);    // Enable Place only when a track card is in hand
    btn('placeBtn').disabled = !P.drawn;    

    // Disable Bottom when there's nothing to bottom, or when maximum-skips forces a draw/place
    btn('bottomBtn').disabled = !P.drawn || state.forcePlace;    
    btn('applyBtn').disabled = !(state.die && state.die!=='X');
    btn('tokenBtn').disabled = !!P.tokenUsed;
    btn('rollBtn').disabled = !!P.rollUsed;

    // Arm elbow force here as well if threshold reached and a placeable Elbow is in hand.
    if ((P.elbowSkipCount|0) >= 3 && P.drawn === TrackCard.Elbow && canPlaceElbowNow(P.id)) {
      state.forceElbowFor = P.id;
    }    

    // Elbow force applies only when the forced player is current, holding an Elbow, and it can be placed.
    const elbowForceApplies =
      (state.forceElbowFor === P.id) &&
      (P.drawn === TrackCard.Elbow) &&
      canPlaceElbowNow(P.id);

    // Waive elbow force here too if it turns out impossible right now
    if (state.forceElbowFor === P.id && P.drawn === TrackCard.Elbow && !canPlaceElbowNow(P.id)) {
      state.forceElbowFor = null;
    }

    if (elbowForceApplies) {
      btn('bottomBtn').disabled = true;
      endTurnBtn.disabled = true;
      overrideBtn.style.display = 'none';
      setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
    }

    tokenTag().textContent = 'Token: ' + (P.tokenUsed ? 'Used' : 'Ready');
    
    // --- TOKEN COUNT (show the *actual* count) ---
    (function(){
      const el = document.getElementById('tokenCount');
      if (!el) return;

      const onBoard = countTokens(P.id);
      const removed = (P.tokensRemoved|0);
      const actualPlaced = Math.min(TOKENS_MAX, removed + onBoard);

      // Show the ACTUAL number (no safety inflation)
      el.textContent = 'Token: ' + actualPlaced + '/' + TOKENS_MAX;

      // If there is a mismatch between scored corners and removed tokens, surface it (subtle warning).
      // This does NOT affect the displayed number.
      const reachedCount =
        P.reached ? (P.reached instanceof Set ? P.reached.size : new Set(P.reached).size) : 0;
      const expectedMin = Math.min(TOKENS_MAX, reachedCount + onBoard);

      if (actualPlaced < expectedMin) {
        // Mismatch: we've scored more corners than tokensRemoved reflects.
        el.textContent += ' ⚠';
        el.title = `Mismatch detected: reached=${reachedCount}, onBoard=${onBoard}, tokensRemoved=${removed}`;
        // Optional: tint the text to draw attention. Remove if you prefer no color change.
        el.style.color = '#ffb020';
        el.style.fontWeight = '600';
      } else {
        // Clear any prior styling/tooltips if mismatch resolved
        el.removeAttribute('title');
        el.style.color = '';
        el.style.fontWeight = '';
      }
    })();

    (function(){
      const el = document.getElementById('skippedTag');
      if(!el){ return; }
      const P = currentPlayer();
      const skipCount = (P && P.skipCount) ? P.skipCount : 0;
      el.textContent = 'Skipped: ' + skipCount + '/3';
      // Visual warning when max skips reached
      if (skipCount >= 3) {
        el.classList.add('warn');   // <- requires CSS for .warn
        el.textContent += '  ⚠ Maximum skipped';
      } else {
        el.classList.remove('warn');
      }
      // SAFETY: if force is active BUT the current card can’t be placed anywhere,
      // auto-waive to prevent deadlocks (Bottom/End Turn become available).
      if (state.forcePlace && P.drawn && !canPlaceDrawnNow(P.id)) {
        state.forcePlace = false;
      }
      if (state.forcePlace) {
        endTurnBtn.disabled = true;
        // overrideBtn.style.display = 'inline-block';
        // Only show Override if there IS a track in hand; otherwise force Draw first
        overrideBtn.style.display = P.drawn ? 'inline-block' : 'none';

        if (!P.drawn) {
          setStatus('Maximum track cards skipped — you must Draw and Place before ending your turn (or use Override).');
        } else {
          setStatus('Maximum track cards skipped — you must Place your drawn track (or use Override).');
        }
      } else {
        // Do NOT re-enable End Turn if a forced Elbow is in hand and placeable.
        if (!elbowForceApplies) {
          endTurnBtn.disabled = false;
        }
        overrideBtn.style.display = 'none';
      }
    })();

    (function(){
      const el = document.getElementById('elbowSkippedTag');
      if(!el){ return; }
      const P = currentPlayer();
      const ecount = (P && P.elbowSkipCount) ? P.elbowSkipCount : 0;
      el.textContent = 'Elbows Skipped: ' + ecount + '/3';
      if (ecount >= 3) {
        el.classList.add('warn');
        el.textContent += elbowForceApplies
          ? '  ⚠. This elbow must be now be placed'
          : '  ⚠ Next Elbow must be placed';
      } else {
        el.classList.remove('warn');
      }
    })();    

    (function(){
      const el = document.getElementById('scoreTag');
      if(!el){ return; }
      const reached = P.reached ? P.reached : new Set();
      const list = (reached && reached.size) ? Array.from(reached).map(n=>n[0]).join(', ') : '';
      el.textContent = 'Score: ' + (reached ? reached.size : 0) + '/3' + (list?(' ['+list+']'):'');
    })();
    render();
    // Ensure standings reflect per-player scores & correct ordinals
    renderStandingsAccurate();
    updatePlacesFromFinishOrder();    
  }

  function render(){
    const N=state.N, cell=state.cell, pad=state.pad;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle=COLORS.bg; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.translate(pad,pad);
    const size=cell*N;
    const now = performance.now();
    state._frameNow = now;  // unify timing across all per-frame animations
    // grid
    ctx.strokeStyle=COLORS.grid; ctx.lineWidth=1;
    ctx.strokeRect(0,0,size,size);
    for(let i=1;i<N;i++){ ctx.beginPath(); ctx.moveTo(i*cell,0); ctx.lineTo(i*cell,size); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,i*cell); ctx.lineTo(size,i*cell); ctx.stroke(); }
    // gears (background)
    for(let y=0;y<N;y++) for(let x=0;x<N;x++){ drawGear(x,y); }
    // corner color badges
    drawCornerBadges();

    // tracks (with rotation tween overlay)
    // prune finished tweens
    state.rotAnims = state.rotAnims.filter(a => (now - a.t0) <= (a.dur + 24));
    const rotMap = new Map();
    for(const a of state.rotAnims){
      const u = Math.min(1, (now - a.t0)/a.dur);
      const k = easeInOutQuad(u);
      const rot = a.from + shortestArc(a.from, a.to) * k;
      rotMap.set(a.x+','+a.y, rot);
    }
    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
        const c=state.board[y][x]; if(!c.track) continue;
        const key = x+','+y;
        if(rotMap.has(key)){
          drawTrack(c.track, ((rotMap.get(key)%360)+360)%360, x,y, 1);
        }else{
          drawTrack(c.track, c.rot, x,y, 1);
        }
      }
    }    

    // tokens
    for(let y=0;y<N;y++) for(let x=0;x<N;x++){ const c=state.board[y][x]; if(c.token!=null) drawToken(c.token,x,y); }
    // connection edges
    if(UI.vizEdges().checked){ drawEdges(); }
    // rotation hints
    if(state.die && state.die!=='X'){ drawRotationHints(); }
    // center marker
    const cc=Math.floor(N/2); const cx=cc*cell+cell/2, cy=cc*cell+cell/2;
    ctx.strokeStyle=COLORS.hilite; ctx.globalAlpha=0.5; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy, cell*0.42, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
    // turn corner highlight
    drawTurnCornerHighlight();
    // placement highlights
    ctx.strokeStyle=COLORS.hilite; ctx.lineWidth=3;
    state.highlight.forEach(p=>{ ctx.strokeRect(p.x*cell+3, p.y*cell+3, cell-6, cell-6); });
    // stronger "active" outline while rotating an existing tile with RS/RE
    if(state.phase==='place' && state.subphase==='rotateExisting' && state.rotateFocus){
      const rf = state.rotateFocus;
      ctx.save();
      ctx.lineWidth = 5;
      ctx.setLineDash([6,4]);
      ctx.strokeStyle = '#ffcc00';
      ctx.strokeRect(rf.x*cell+2, rf.y*cell+2, cell-4, cell-4);
      ctx.restore();
    }    
    // ghost
    const P=currentPlayer();
    if(state.phase==='place' && state.subphase==='rotateExisting' && state.rotateFocus) {
      const rf = state.rotateFocus; const c = state.board[rf.y][rf.x];
      drawTrack(c.track, ghostAngle(), rf.x, rf.y, 0.9);    
    }
    else if (state.phase==='place' && state.subphase==='rotateNew' && state.rotateFocus) {
      const rf = state.rotateFocus;
      const P  = currentPlayer();
      // Draw the to-be-placed piece at the focused cell, regardless of mouse hover
      drawTrack(baseDrawnType(P.drawn), ghostAngle(), rf.x, rf.y, 0.55);
    }
    else if(state.phase==='place' && state.hover && P.drawn){
      const {x,y}=state.hover;
      const legal = state.highlight.some(h=>h.x===x && h.y===y);
      // Follow-cursor ghost everywhere; greenish when legal, faint red tint when illegal
      drawTrack(baseDrawnType(P.drawn), ghostAngle(), x, y, legal ? 0.55 : 0.35);
      if(!legal){
        ctx.save();
        ctx.strokeStyle = '#e03';
        ctx.lineWidth = 3;
        ctx.setLineDash([6,4]);
        ctx.strokeRect(x*cell+4, y*cell+4, cell-8, cell-8);
        ctx.restore();
      }
    }
    // Token ghost (during Token actions) — same visual rules
    else if(state.phase==='token' && state.hover){
      const {x,y}=state.hover;
      let legal=false;
      if(state.subphase==='target'){
        legal = state.highlight.some(h=>h.x===x && h.y===y);
      }else if(state.subphase==='select'){
        const P=currentPlayer();
        const corner = cornerFor(P.id);
        const cCell  = state.board[corner.y][corner.x];
        const myCount = countTokens(P.id);
        legal = (x===corner.x && y===corner.y && myCount < TOKENS_MAX && cCell.track && cCell.token==null);
      }
      drawToken(currentPlayer().id, x, y, legal ? 0.55 : 0.35);
      if(!legal){
        ctx.save();
        ctx.strokeStyle = '#e03';
        ctx.lineWidth = 3;
        ctx.setLineDash([6,4]);
        ctx.strokeRect(x*cell+4, y*cell+4, cell-8, cell-8);
        ctx.restore();
      }
    }
    // --- end-of-frame cleanup for gear tween ---
    if (state.gearSpinAnim) {
      const a = state.gearSpinAnim;
      if ((performance.now() - a.t0) >= a.dur) {
        state.gearSpinAnim = null;
      }
    }
    // Outer restore for the whole frame   
    ctx.restore();
  }

  // === CORNER COLOR BADGES (anchor: RR_CORNER_BADGES) ===
  // Draw a small right-triangle in each player's corner using their color.
  function drawCornerBadges(){
    const cell = state.cell;
    const m = 3;                                // inset margin
    const t = Math.max(8, Math.floor(cell * 0.25)); // triangle leg length
    ctx.save();
    ctx.globalAlpha = 0.85;
    for (const P of PLAYERS){
      const live = state.players[P.id]?.active !== false;
      ctx.globalAlpha = live ? 0.85 : 0.25;
      const c = cornerFor(P.id);
      const px = c.x * cell, py = c.y * cell;
      ctx.beginPath();
      switch (P.pocket){
        case 'NW':
          ctx.moveTo(px + m,         py + m);
          ctx.lineTo(px + m + t,     py + m);
          ctx.lineTo(px + m,         py + m + t);
          break;
        case 'NE':
          ctx.moveTo(px + cell - m,      py + m);
          ctx.lineTo(px + cell - m - t,  py + m);
          ctx.lineTo(px + cell - m,      py + m + t);
          break;
        case 'SE':
          ctx.moveTo(px + cell - m,      py + cell - m);
          ctx.lineTo(px + cell - m - t,  py + cell - m);
          ctx.lineTo(px + cell - m,      py + cell - m - t);
          break;
        // 'SW'
        default:
          ctx.moveTo(px + m,         py + cell - m);
          ctx.lineTo(px + m + t,     py + cell - m);
          ctx.lineTo(px + m,         py + cell - m - t);
          break;
      }
      ctx.closePath();
      ctx.fillStyle = P.color;
      ctx.fill();
    }
    ctx.restore();
  }

  function drawTurnCornerHighlight(){
    const P=currentPlayer();
    if (!P.active) return; // should not happen, but guard the highlight
    const corner = cornerFor(P.id);
    const cell=state.cell;
    ctx.save();
    ctx.lineWidth = 4;
    ctx.strokeStyle = P.color;
    ctx.globalAlpha = 0.95;
    ctx.strokeRect(corner.x*cell+2, corner.y*cell+2, cell-4, cell-4);
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = P.color;
    ctx.fillRect(corner.x*cell+3, corner.y*cell+3, cell-6, cell-6);
    ctx.restore();
  }

  function drawEdges(){
    const cell=state.cell;
    ctx.save();
    ctx.strokeStyle=COLORS.edge;
    ctx.lineWidth=2;
    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
        const a=state.board[y][x];
        if(!a.track || a.track==='Block') continue;
        for(const [dx,dy] of rotatedOpenings(a)){
          const nx=x+dx, ny=y+dy; if(!within(nx,ny)) continue;
          const b=state.board[ny][nx];
          if(!b.track || b.track==='Block') continue;
          if(hasReciprocal(a,b,dx,dy)){
            const x1=(x+0.5)*cell, y1=(y+0.5)*cell;
            const x2=(nx+0.5)*cell, y2=(ny+0.5)*cell;
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
          }
        }
      }
    }
    ctx.restore();
  }

  // Draw a background gear from the external SVG.
  // Alternates orientation by cell parity: even -> 0°, odd -> 90°.
  function drawGear(x, y){
    const cell = state.cell;
    const cx   = x*cell + cell/2;
    const cy   = y*cell + cell/2;

    // Draw a faint cell border (keeps your existing grid vibe)
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth   = 1;
    ctx.strokeRect(x*cell, y*cell, cell, cell);

    // If the SVG isn’t ready, keep the old fallback so nothing looks broken
    if (!gearReady || !gearImg.naturalWidth || !gearImg.naturalHeight){
      ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(cx, cy, cell/2-4, 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle = '#202a3d';
      ctx.beginPath(); ctx.arc(cx, cy, cell/2-7, 0, Math.PI*2); ctx.fill();
      return;
    }

    // Target outer diameter (so neighboring centers = outer diameter => visual meshing)
    const targetOuter = cell * GEAR_OUTER_FIT;

    // Scale uniformly based on the smaller natural dimension of the SVG
    const natW = gearImg.naturalWidth  || 512;
    const natH = gearImg.naturalHeight || 512;
    const natMin = Math.min(natW, natH);
    const k = targetOuter / natMin;

    // Base mesh orientation (0°/90°) + persistent per-cell offset + transient tween to it
    const baseDeg = ((x + y) % 2 === 0) ? 0 : 90;
    const offset  = (state.gearOffset && state.gearOffset[y] && state.gearOffset[y][x]) || 0;

    let animAdj = 0; // delta applied on top of the committed offset (old→new interpolation)
    const a = state.gearSpinAnim;
    if (a) {
      const now = state._frameNow || performance.now();
      const u   = Math.min(1, (now - a.t0) / a.dur);
      const k   = easeInOutQuad(u);            // same easing as tile tween
      const pending = ((x + y) % 2 === 0) ? (+a.base) : (-a.base); // signed per-cell delta
      // Show: newOffset - pending*(1-k)  →  starts at old, lands at new without snapping
      animAdj = -pending * (1 - k);
    }
    const rotDeg = baseDeg + offset + animAdj;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotDeg * Math.PI / 180);
    ctx.globalAlpha = 1.0; // feel free to drop to ~0.9 if you want tracks to pop more

    // Render with uniform scale; keep the original aspect ratio
    const drawW = natW * k;
    const drawH = natH * k;
    ctx.drawImage(gearImg, -drawW/2, -drawH/2, drawW, drawH);
    ctx.restore();
  }

  function drawTrack(type, rot, x,y, alpha){
    const cell=state.cell; const cx=x*cell+cell/2, cy=y*cell+cell/2; const r=cell/2-8;
    ctx.save(); ctx.globalAlpha=alpha; ctx.translate(cx,cy); ctx.rotate(rot*Math.PI/180);
    if(type==='Block'){
      ctx.fillStyle='#434b63'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=COLORS.grid; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
    } else {
      ctx.fillStyle = COLORS.track;
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      // Stroke pipes using the owning player's color (fallback to slot color)
      let ownerColor = COLORS.slot;
      const cellObj = state.board && state.board[y] && state.board[y][x];
      if (cellObj && Number.isInteger(cellObj.owner) && state.players[cellObj.owner]) {
        ownerColor = state.players[cellObj.owner].color || ownerColor;
      }
      ctx.strokeStyle = ownerColor;
      ctx.lineWidth = 6;      
      if(type==='Straight'){
        ctx.beginPath(); ctx.moveTo(-r*0.85,0); ctx.lineTo(r*0.85,0); ctx.stroke();
      }
      if(type==='Elbow'){
        ctx.beginPath(); ctx.moveTo(0,-r*0.85); ctx.lineTo(0,0); ctx.lineTo(r*0.85,0); ctx.stroke();
      }
      if(type==='Cross'){
        ctx.beginPath(); ctx.moveTo(-r*0.85,0); ctx.lineTo(r*0.85,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,-r*0.85); ctx.lineTo(0,r*0.85); ctx.stroke();
      }
      if(type==='T'){
        // Base orientation matches OPENINGS T: E, W, N (closed South). Rotation handles others.
        ctx.beginPath(); ctx.moveTo(-r*0.85,0); ctx.lineTo(r*0.85,0); ctx.stroke(); // horizontal bar
        ctx.beginPath(); ctx.moveTo(0,-r*0.85); ctx.lineTo(0,0); ctx.stroke();      // stem up
      }
    }
    ctx.restore();
  }

  // --- Rotation hints overlay (direction-correct; visible on all cells) ---
  function drawRotationHints(){
    const base = thetaFor(state.die);
    if(base===0) return;
    ctx.save();
    ctx.lineWidth = 3;

    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
        const cellData = state.board[y][x];
        const sign = ((x + y) % 2 === 0) ? 1 : -1;
        const theta = sign * base;
        const cx = x*state.cell + state.cell/2;
        const cy = y*state.cell + state.cell/2;
        const r = state.cell*0.28;
        const sweep = Math.abs(theta) * Math.PI / 180;
        const cw = theta > 0;
        const isTrack = !!cellData.track && cellData.track!=='Block';
        ctx.globalAlpha = isTrack ? 0.58 : 0.22;
        ctx.strokeStyle = COLORS.hint;
        drawArrowArcDir(cx, cy, r, sweep, cw);
      }
    }
    ctx.restore();
  }

  function drawArrowArcDir(cx, cy, r, sweep, cw){
    const start = -Math.PI/2;
    const end = cw ? (start + sweep) : (start - sweep);
    const anticlockwise = !cw;
    ctx.beginPath();
    ctx.arc(cx, cy, r, start, end, anticlockwise);
    ctx.stroke();
    // Arrowhead at end
    const ax = cx + r*Math.cos(end);
    const ay = cy + r*Math.sin(end);
    const t = end + (cw ? Math.PI/2 : -Math.PI/2);
    const len = 8;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - len*Math.cos(t - 0.4), ay - len*Math.sin(t - 0.4));
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - len*Math.cos(t + 0.4), ay - len*Math.sin(t + 0.4));
    ctx.stroke();
  }

  function drawToken(pid,x,y, alphaOverride){
    // Hide all tokens while hidden for the current human player
    if (state.tokensHidden) return;    
    const color = PLAYERS[pid].color; const cell=state.cell;
    const cx=x*cell+cell/2, cy=y*cell+cell/2; const r=cell/2-12;
    const a = (alphaOverride==null ? 0.75 : alphaOverride);
    ctx.fillStyle=color; ctx.globalAlpha=a; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
  }

  function pulse(x,y){
    const cell=state.cell; const pad=state.pad; const cx=pad+(x+0.5)*cell, cy=pad+(y+0.5)*cell; const r0=6, r1=26;
    const start=performance.now();
    function step(t){
      const k=Math.min(1,(t-start)/280);
      ctx.save();
      ctx.strokeStyle=COLORS.hilite; ctx.lineWidth=3; ctx.globalAlpha=1-k;
      ctx.beginPath(); ctx.arc(cx, cy, r0 + (r1-r0)*k, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
      if(k<1){ requestAnimationFrame(step); } else { render(); }
    }
    requestAnimationFrame(step);
  }

  // initial
  resize();

  // ---- STARTUP ENTRY POINT (runs once the DOM is ready) ----
  document.addEventListener('DOMContentLoaded', function(){
    try {
      // Read menu setup (saved by MainMenu.html) into THIS IIFE's state
      if (typeof loadSetupFromStorage === 'function') {
        const s = loadSetupFromStorage();
        if (s) {
          state.setup = s;
          // keep sidebar Board Size dropdown visually in sync if it's on-screen
          const dd = document.getElementById('boardSize');
          if (dd) dd.value = String(s.boardSize);
        }
      }
      // Build board & start the game using state.setup (7x7/9x9, names, AI flags)
      newGame();
    } catch (e) {
      console.error(e);
    }
  });
})();</script>
</body>
</html>