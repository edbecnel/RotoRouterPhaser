<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RotoRouter</title>
  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: #0f1115; color: #e6e6e6; }
    .app { display: grid; grid-template-columns: 360px 1fr; height: 100%; }
    .sidebar { padding: 14px 16px; border-right: 1px solid #222835; background: #121723; overflow: auto; }
    .sidebar h1 { font-size: 18px; margin: 0 0 8px; }
    .sidebar h2 { font-size: 14px; margin: 16px 0 8px; color: #b7c1ff; }
    .row { display: flex; gap: 8px; align-items: center; margin: 6px 0; flex-wrap: wrap; }
    .row.nowrap { flex-wrap: nowrap; }
    .nowrap { white-space: nowrap; }
    .btn { padding: 8px 10px; background: #1b2233; color: #fff; border: 1px solid #30384f; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .tag { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #2a3249; background: #0f1626; }
    .panel { border: 1px solid #1f2636; padding: 10px; border-radius: 12px; background: #0d1220; }
    .muted { color: #9da6b8; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .small { font-size: 12px; }
    .legend { display: grid; grid-template-columns: auto 1fr; gap: 6px 10px; align-items: center; }
    .dot { width: 12px; height: 12px; border-radius: 50%; display: inline-block; border: 1px solid #fff4; }
    .inactiveRow { opacity: .4; filter: grayscale(.2); }
    canvas { display: block; }
    .toast { position: fixed; left: 380px; bottom: 16px; background: #182031; border: 1px solid #2b3650; padding: 10px 14px; border-radius: 10px; pointer-events: none; opacity: 0; transition: opacity .18s ease; }
    .toast.show { opacity: 1; }
    label.toggle { display:flex; align-items:center; gap:8px; font-size:12px; user-select:none; }
    .warn {
      color: #c00;       /* red text */
      font-weight: 600;  /* bold */
    }
    .ok { color:#28d07a; font-weight:700; }
  </style>
</head>
<body>
  <div class="app">
    <aside class="sidebar">
      <h1>RotoRouter</h1>
      <div class="panel">
        <div class="row"><span class="tag" id="turnTag">Turn: —</span><span class="tag" id="phaseTag">Phase: —</span></div>
        <div class="row small muted" id="status">New Game → Draw → Place. First placement is your corner.</div>
      </div>

      <h2>Setup</h2>
      <div class="grid">
        <label class="small muted">Board Size
          <select id="boardSize">
            <option value="9">9×9</option>
            <option value="7">7×7</option>
          </select>
        </label>
      </div>
      <div class="row">
        <button class="btn" id="newGameBtn">New Game</button>
        <button class="btn" id="returnMenuBtn">Main Menu</button>
      </div>
      <h2>Actions</h2>
      <div class="panel">
        <div class="row"><b>Track</b></div>
        <div class="row">
          <button class="btn" id="drawBtn">Draw</button>
          <span id="drawnCard" class="tag">Card: —</span>
          <span id="drawTag" class="tag">Draw: Ready</span>
        </div>
        <div class="row">
          <button class="btn" id="placeBtn">Place</button>
          <button class="btn" id="bottomBtn">Bottom</button>
        </div>
        <div class="row">
          <button class="btn" id="rotateCCWBtn">⟲ CCW</button>
          <button class="btn" id="rotateCWBtn">⟳ CW</button>
          <span id="rotateTag" class="tag">Rotate: —</span>
        </div>
        <div class="row small muted">
          On touch devices: tap a legal cell to enter <b>rotation mode</b>, use the buttons (or Q/E) to rotate, then tap again to place.
        </div>
        <div class="row small muted nowrap">
          <span>Hover shows a <b>ghost</b>. Tap/click a legal cell to rotate it first, then tap/click again to place. Rotate with Q/E or the buttons.</span>
        </div>
        <hr style="border-color:#1f2636"/>
        <div class="row"><b>Token</b></div>
        <div class="row">
          <button class="btn" id="tokenBtn">Token Action</button>
          <span id="tokenTag" class="tag">Token: Ready</span>
          <span id="skippedTag" class="tag">Skipped: 0/3</span>
          <span id="elbowSkippedTag" class="tag">Elbows Skipped: 0/3</span>
          <span id="tokenCount" class="tag">Token: 0/3</span>
          <span id="scoreTag" class="tag">Score: 0/3</span>
        </div>
        <div class="row small muted">Move along <b>any connected pipes</b> (opponent tracks allowed once networks connect). One token action/turn. Max 3 tokens/player.</div>
        <label class="toggle"><input type="checkbox" id="vizEdges"> Show connection edges</label>
        <hr style="border-color:#1f2636"/>
        <div class="row"><b>Rotation</b></div>
        <div class="row">
          <button class="btn" id="rollBtn">Roll Die</button>
          <span id="dieFace" class="tag">Die: —</span>
          <button class="btn" id="applyBtn" disabled>Apply</button>
          <span id="rollTag" class="tag">Roll: Ready</span>
        </div>
        <div class="row small muted">Meshed gears: neighbors alternate opposite direction. One roll per turn.</div>
        <hr style="border-color:#1f2636"/>
        <div class="row"><button class="btn" id="endTurnBtn">End Turn</button>
        <button id="overrideBtn" style="display:none;">Override</button></div>

        <hr style="border-color:#1f2636"/>
        <div class="row"><b>Undo / Redo</b></div>
        <div class="row">
          <button class="btn" id="undoGlobalBtn" disabled>Undo (Global)</button>
          <button class="btn" id="redoGlobalBtn" disabled>Redo (Global)</button>
        </div>
        <div class="row">
          <button class="btn" id="undoTurnBtn" disabled>Undo (Turn)</button>
          <button class="btn" id="redoTurnBtn" disabled>Redo (Turn)</button>
        </div>

        <h2>Save / Load</h2>
        <div class="panel">
          <div class="row">
            <button class="btn" id="saveBtn">Save Game</button>
            <button class="btn" id="loadBtn">Load Game</button>
            <input type="file" id="loadFile" accept="application/json" style="display:none" />
          </div>
          <div class="row small muted">
            Saves to a local JSON file. Load restores the full game later.
          </div>
        </div>
      </div>

      <h2>Corners</h2>
      <div class="panel">
        <table class="scoreTable" id="cornerScoreTable" style="width:100%; border-collapse:collapse;">
          <thead>
            <tr>
              <th style="text-align:left;">Color</th>
              <th style="text-align:left;">Quadrant</th>
              <th style="text-align:right;">Score</th>
            </tr>
          </thead>
          <tbody>
            <tr data-pid="0">
              <td><span class="dot" style="background:#ff6b6b"></span> Red</td>
              <td id="quad-0">—</td>
              <td id="score-0" style="text-align:right;">0/3</td>
            </tr>
            <tr data-pid="1">
              <td><span class="dot" style="background:#6bff95"></span> Green</td>
              <td id="quad-1">—</td>
              <td id="score-1" style="text-align:right;">0/3</td>
            </tr>
            <tr data-pid="2">
              <td><span class="dot" style="background:#6bd9ff"></span> Blue</td>
              <td id="quad-2">—</td>
              <td id="score-2" style="text-align:right;">0/3</td>
            </tr>
            <tr data-pid="3">
              <td><span class="dot" style="background:#ffef6b"></span> Yellow</td>
              <td id="quad-3">—</td>
              <td id="score-3" style="text-align:right;">0/3</td>
            </tr>
          </tbody>
        </table>
      </div>
    </aside>
    <main id="game"><canvas id="board"></canvas></main>
  </div>
  <div id="toast" class="toast"></div>

<script>

function loadSetupFromStorage(){
  try {
    const s = JSON.parse(localStorage.getItem('rr.setup') || 'null');
    if (!s) return null;
    // normalize expected shape
    return {
      boardSize: (Number.isFinite(s.boardSize) ? s.boardSize : 9),
      players: Array.isArray(s.players) ? s.players.map((p,i)=>({
        id: i,
        name: (p && p.name) ? String(p.name) : ['Red','Green','Blue','Yellow'][i],
        ai: !!(p && p.ai),
        active: (p && typeof p.active === 'boolean') ? !!p.active : (i < 2) // default Red/Green active
      })) : null
    };
  } catch(e){ console.warn('setup load failed', e); return null; }
}

  (function(){
  // Toast with adjustable duration (defaults to ~3.5s) and proper clearing
  let _toastTimer=null;
  const toast=(m, ms=3500)=>{
    const el=document.getElementById('toast');
    el.textContent=m;
    el.classList.add('show');
    if(_toastTimer) clearTimeout(_toastTimer);
    _toastTimer=setTimeout(()=>el.classList.remove('show'), ms);
  };  
  const setStatus=(t)=>{ document.getElementById('status').innerHTML=t; };
  const tag = (id)=>document.getElementById(id);
  const turnTag=()=>tag('turnTag');
  const phaseTag=()=>tag('phaseTag');
  const drawnTag=()=>tag('drawnCard');
  const drawTag=()=>tag('drawTag');
  const dieTag=()=>tag('dieFace');
  const rollTag=()=>tag('rollTag');
  const tokenTag=()=>tag('tokenTag');
  const tokenCount=()=>tag('tokenCount');
  const btn=(id)=>document.getElementById(id);
  

  // Colors & constants
  const COLORS={ bg:'#0b0f18', grid:'#263145', gear:'#202a3d', track:'#6d7aa6', block:'#434b63', slot:'#a8b7ff', hilite:'#9efff4', tokenR:'#ff6b6b', tokenG:'#6bff95', tokenB:'#6bd9ff', tokenY:'#ffef6b', edge:'#f4b86a', hint:'#c7f0ff' };
  const TrackCard={
    Straight:'Straight', Elbow:'Elbow', Cross:'Cross', T:'T',
    RStraight:'RS', RElbow:'RE', RCross:'RC', RT:'RT'
  };
  const DIE_FACES=['X','X','X','CW90','CW90','CCW90','CCW90','DEG180'];
  // === Animation timing knobs ===
  const RR_APPLY_TWEEN_MS = 650;    // duration for the big "Apply" rotation tween (tiles + gears)
  const PREVIEW_ROT_TWEEN_MS = 400; // duration for RR keys initiated track placement ghost preview rotation
  const TOKENS_MAX=3;
  const PLAYERS=[
    { id:0, name:'Red', color: COLORS.tokenR, pocket:'NW' },
    { id:1, name:'Green', color: COLORS.tokenG, pocket:'NE' },
    { id:2, name:'Blue', color: COLORS.tokenB, pocket:'SE' },
    { id:3, name:'Yellow', color: COLORS.tokenY, pocket:'SW' },
  ];

  // ==== GEAR SVG (mesh-ready: alternate 0° / 90°) ====
  const GEAR_SRC = 'gear-grayblue-03.svg';     // file should sit beside RotoRouter.html
  const gearImg = new Image();
  let gearReady = false;
  // Optional: set decoding to sync to improve first-paint, browsers may ignore
  if ('decoding' in gearImg) gearImg.decoding = 'sync';
  gearImg.onload = () => { gearReady = true; render(); };
  gearImg.onerror = () => { console.warn('Could not load gear SVG:', GEAR_SRC); };
  gearImg.src = `${GEAR_SRC}?v=2025-10-02`;
  // How tightly the gear outer diameter should fit the cell (1.00 = full cell)
  // For tight teeth meshing, keep at 1.00. If you want a tiny gap, try 0.98.
  const GEAR_OUTER_FIT = 1.00;   // -> try 0.98 if you prefer a hairline gap
  // ==== GEAR SPIN (animated) ====
  // Toggle overall gear animation
  const GEAR_SPIN_ENABLED = true;

  // Spin speed in revolutions per minute (positive = clockwise for even parity cells)
  const GEAR_SPIN_RPM = 6;   // try 3–12 to taste

  // ==== UNDO / REDO CONFIG ====
  // Master switch and per-scope toggles (code-only; no UI)
  const UNDO_CONFIG = {
    enabled: true,     // turn Undo/Redo on/off entirely
    global:  true,     // allow Global undo/redo
    turn:    true      // allow Player-turn-scoped undo/redo
  };

  // Openings — Elbow base = EAST+NORTH (NE), Straight is horizontal base
  const OPENINGS={
    Straight: [[1,0],[-1,0]],            // base: horizontal
    Elbow:    [[1,0],[0,-1]],            // base: TURNS from East to North
    Cross:    [[1,0],[-1,0],[0,1],[0,-1]],
    T:        [[1,0],[-1,0],[0,-1]]      // base: ┴  (open E, W, N; closed S) — rotation adds others
  };

  function rotDir([dx,dy],deg){ const t=((deg%360)+360)%360; if(t===0) return [dx,dy]; if(t===90) return [-dy,dx]; if(t===180) return [-dx,-dy]; if(t===270) return [dy,-dx]; return [dx,dy]; }
  function rotatedOpenings(cell){
    if(!cell.track || cell.track==='Block') return [];
    return OPENINGS[cell.track].map(([dx,dy])=>rotDir([dx,dy], cell.rot));
  }
  function hasReciprocal(aCell, bCell, dx, dy){
    const aOk = rotatedOpenings(aCell).some(([rx,ry])=>rx===dx && ry===dy);
    if(!aOk) return false;
    const bOk = rotatedOpenings(bCell).some(([rx,ry])=>rx===-dx && ry===-dy);
    return bOk;
  }
  
  // Utilities & state
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
  function makeDeck(size){
    const cfgMap = {
      // 7×7
      7: { Straight:7,  Elbow:6,  Cross:1,  T:3,
          RStraight:3, RElbow:2, RCross:1, RT:1 },
      // 9×9
      9: { Straight:9,  Elbow:8,  Cross:1,  T:3,
          RStraight:4, RElbow:3, RCross:2, RT:2 },
    };
    const cfg = cfgMap[size] || (size <= 7 ? cfgMap[7] : cfgMap[9]);
    return {
      draw: shuffle([
        ...Array(cfg.Straight||0).fill(TrackCard.Straight),
        ...Array(cfg.Elbow||0).fill(TrackCard.Elbow),
        ...Array(cfg.Cross||0).fill(TrackCard.Cross),
        ...Array(cfg.T||0).fill(TrackCard.T),

        ...Array(cfg.RStraight||0).fill(TrackCard.RStraight),
        ...Array(cfg.RElbow||0).fill(TrackCard.RElbow),
        ...Array(cfg.RCross||0).fill(TrackCard.RCross),
        ...Array(cfg.RT||0).fill(TrackCard.RT),
      ]),
      discard: []
    };
  }
  function makeBoard(N){ const b=[]; for(let y=0;y<N;y++){ const r=[]; for(let x=0;x<N;x++){ r.push({track:null,rot:0,owner:null,token:null}); } b.push(r);} return b; }
  function initGearOffsets(N){
    state.gearOffset = Array.from({length:N}, () => Array(N).fill(0));
  }

  const UI = {
    boardSize:()=>document.getElementById('boardSize'),
    template:()=>document.getElementById('template'),
    canvas:()=>document.getElementById('board'),
    vizEdges:()=>document.getElementById('vizEdges'),
  };

  const state={ N:9, cell:64, pad:20, board:makeBoard(9),
    players:PLAYERS.map(p=>({...p, deck:makeDeck(), drawn:null, tokens:0, tokensRemoved:0, drawLocked:false, drawUsed:false, tokenUsed:false, rollUsed:false, skipCount: 0, elbowSkipCount: 0, forceElbow: false, active:true })),    cornerLockTurns: PLAYERS.map(()=>0),
    current:0, phase:'idle', subphase:null, highlight:[], hover:null, forcePlace:false, previewRot:0, die:null, tokenSelect:null,
    turnAdvancing:false,
    deadFixDoneThisTurn: false,
    rotAnims: [],  // active rotation tweens (on placed tiles)
    ghostRotAnim: null,   // {from,to,t0,dur} while rotating the ghost
    _animating: false,     // RAF loop guard
    gearSpinAnim: null,   // { base: +90|-90|180, t0, dur } active only during Apply tween
    gearOffset: null,     // per-cell persistent gear angle offset (degrees, 0..359)
    // Undo/Redo stacks
    history: [],        // Global undo stack (array of snapshots)
    redo:    [],        // Global redo stack
    turnHistory: [],    // Per-turn undo stack (current player's turn)
    turnRedo:   [],      // Per-turn redo stack
    forceElbowFor: null, // If set to a player id, that player must place an Elbow this turn (but only if placement is possible)
    _enforceForcePlaceWindow: false  // gate: only true during startTurn() check
  };
  


  const canvas=UI.canvas(); const ctx=canvas.getContext('2d');

  // ==== UNDO / REDO HELPERS ====
  function pushHistory(label){
    if (!UNDO_CONFIG.enabled) return;
    const snap = snapshotState();
    snap.__turnId = state.current;      // tag snapshot with current player's turn id
    snap.__undo_label = label || '';
    // Global
    if (UNDO_CONFIG.global){
      state.history.push(snap);
      state.redo.length = 0; // new action invalidates redo
    }
    // Turn-scoped
    if (UNDO_CONFIG.turn){
      state.turnHistory.push(snap);
      state.turnRedo.length = 0;
    }
    updateUndoButtons();
  }

  function applySnapshotFromHistory(snap, label, op){
    // op is 'undo' or 'redo'
    applySnapshot(snap, { fromHistory: true, status: label || null, op });
  }

  function updateUndoButtons(){
    // Called inside updateHUD() as well, but safe to call anytime
    const gCanUndo = UNDO_CONFIG.enabled && UNDO_CONFIG.global && state.history.length > 0;
    const gCanRedo = UNDO_CONFIG.enabled && UNDO_CONFIG.global && state.redo.length > 0;

    const tCanUndo = UNDO_CONFIG.enabled && UNDO_CONFIG.turn && state.turnHistory.length > 1; // need ≥1 action beyond baseline
    const tCanRedo = UNDO_CONFIG.enabled && UNDO_CONFIG.turn && state.turnRedo.length > 0;

    const bU = document.getElementById('undoGlobalBtn');
    const bR = document.getElementById('redoGlobalBtn');
    const bTU= document.getElementById('undoTurnBtn');
    const bTR= document.getElementById('redoTurnBtn');

    if (bU) bU.disabled  = !gCanUndo;
    if (bR) bR.disabled  = !gCanRedo;
    if (bTU) bTU.disabled = !tCanUndo;
    if (bTR) bTR.disabled = !tCanRedo;
  }

  // Global Undo/Redo (mirrors into Turn stacks so buttons stay in sync)
  function undoGlobal(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.global) return;
    if (state.history.length === 0) return;

    const cur = snapshotState();            // current state → global redo
    const prev = state.history.pop();       // previous snapshot to apply
    state.redo.push(cur);

    // Mirror into Turn stacks
    if (UNDO_CONFIG.turn) {
      const curTurnId  = state.current;
      const stepTurnId = (prev && prev.__turnId != null) ? prev.__turnId : curTurnId;

      if (stepTurnId === curTurnId) {
        // Undoing a step from THIS turn → pop one from per-turn history
        if (state.turnHistory.length > 1) {
          state.turnRedo.push(cur);
          state.turnHistory.pop();
        }
      } else {
        // Undoing into a different turn → collapse to baseline for clarity
        state.turnHistory = state.turnHistory.slice(0, 1);
        state.turnRedo.length = 0;
      }
    }

    applySnapshotFromHistory(prev, 'Undid (Global).', 'undo');
    toast('Undo (Global)');
    updateUndoButtons();
  }

  function redoGlobal(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.global) return;
    if (state.redo.length === 0) return;

    const cur  = snapshotState();       // current state → global history
    const next = state.redo.pop();      // snapshot to reapply
    state.history.push(cur);

    // Mirror into Turn stacks
    if (UNDO_CONFIG.turn) {
      const curTurnId  = state.current;
      const stepTurnId = (next && next.__turnId != null) ? next.__turnId : curTurnId;

      if (stepTurnId === curTurnId) {
        // Redoing a step that belongs to THIS turn
        state.turnHistory.push(cur);
        if (state.turnRedo.length > 0) state.turnRedo.pop();
      } else {
        // Redoing into a different turn → keep per-turn at baseline
        state.turnHistory = state.turnHistory.slice(0, 1);
        state.turnRedo.length = 0;
      }
    }

    applySnapshotFromHistory(next, 'Redid (Global).', 'redo');
    toast('Redo (Global)');
    updateUndoButtons();
  }

  // Turn-scoped Undo/Redo (only within the *current* player's turn)
  function undoTurn(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.turn) return;
    // Need at least baseline + 1 action
    if (state.turnHistory.length <= 1) return;

    // Current snapshot becomes redo entry
    const cur = snapshotState();

    // Pop the target "previous" snapshot from turnHistory and apply it
    const prev = state.turnHistory.pop();

    // Mirror the move to Global stacks so buttons/behavior stay in sync
    if (UNDO_CONFIG.global && state.history.length > 0) {
      // push current to global redo, drop one from global history
      state.redo.push(cur);
      state.history.pop();
    }

    // Turn redo receives current
    state.turnRedo.push(cur);

    applySnapshotFromHistory(prev, 'Undid (Turn).', 'undo');
    toast('Undo (Turn)');
    updateUndoButtons();
  }

  function redoTurn(){
    if (!UNDO_CONFIG.enabled || !UNDO_CONFIG.turn) return;
    if (state.turnRedo.length === 0) return;

    const cur = snapshotState();
    const next = state.turnRedo.pop();

    // Mirror to Global stacks
    if (UNDO_CONFIG.global) {
      // current becomes a new step in global history
      state.history.push(cur);
      // consume one from global redo if available
      if (state.redo.length > 0) state.redo.pop();
    }

    // Turn history receives current
    state.turnHistory.push(cur);

    applySnapshotFromHistory(next, 'Redid (Turn).', 'redo');
    toast('Redo (Turn)');
    updateUndoButtons();
  }

  // Reset per-turn history at the start of each player's turn.
  function resetTurnHistory(){
    state.turnHistory = [];
    state.turnRedo    = [];
    // Push a baseline so "first action" undo target exists,
    // but keep the button disabled until an action actually happens.
    if (UNDO_CONFIG.enabled && UNDO_CONFIG.turn){
      state.turnHistory.push(snapshotState());
      state.turnRedo.length = 0;
    }
    updateUndoButtons();
  }

  // ===== SAVE / LOAD =====

  // Build a plain JSON-safe snapshot of the full game state.
  function snapshotState() {
    // Convert Sets to arrays, drop transient/animation fields
    const players = state.players.map(p => ({
      id: p.id,
      name: p.name,
      color: p.color,
      pocket: p.pocket,
      active: !!p.active,
      deck: {
        draw: [...(p.deck?.draw || [])],
        discard: [...(p.deck?.discard || [])],
      },
      drawn: p.drawn ?? null,
      tokens: p.tokens|0,
      tokensRemoved: p.tokensRemoved|0,
      drawLocked: !!p.drawLocked,
      drawUsed: !!p.drawUsed,
      tokenUsed: !!p.tokenUsed,
      rollUsed: !!p.rollUsed,
      skipCount: p.skipCount|0,
      elbowSkipCount: p.elbowSkipCount|0,
      forceElbow: !!p.forceElbow,
      forcePlaceNext: !!p.forcePlaceNext,
      reached: p.reached ? Array.from(p.reached) : [], // names of corners reached
    }));

    // Deep copy board (tracks, rotations, owners, tokens)
    const board = [];
    for (let y=0; y<state.N; y++) {
      const row = [];
      for (let x=0; x<state.N; x++) {
        const c = state.board[y][x] || {};
        row.push({
          track: c.track ?? null,
          rot: c.rot|0,
          owner: (c.owner==null? null : c.owner|0),
          token: (c.token==null? null : c.token|0),
        });
      }
      board.push(row);
    }

    // Deep copy per-cell gear offsets so Undo/Redo can restore visual orientation
    const gearOffset = (state.gearOffset && state.gearOffset.length === state.N)
      ? state.gearOffset.map(row => row.slice())
      : null;    

    return {
      __rr_version: 1,
      savedAt: new Date().toISOString(),
      N: state.N,
      current: state.current|0,
      players,
      board,
      gearOffset,  // ← include in snapshot (also helps Save/Load stay visually consistent)
      // Corner/seal bookkeeping
      cornerLockTurns: Array.isArray(state.cornerLockTurns) ? [...state.cornerLockTurns] : null,
      cornerSealed: Array.isArray(state.cornerSealed) ? [...state.cornerSealed] : null,
      deadFixDoneThisTurn: !!state.deadFixDoneThisTurn,   // ← top-level, not per-player
      // We intentionally DO NOT persist: phase, subphase, highlights, die, animations, hover, etc.
    };
  }

  // Download a JSON file (no server needed)
  function downloadJSON(obj, filename) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      document.body.removeChild(a);
    }, 0);
  }

  function saveGame() {
    const snap = snapshotState();
    const name = `RotoRouter_${snap.N}x${snap.N}_${snap.savedAt.replace(/[:.]/g,'-')}.json`;
    downloadJSON(snap, name);
    toast('Game saved.');
  }

  // Apply a snapshot back into our live state (safe restore)
  function applySnapshot(snap, opts) {
    // Basic validation
    if (!snap || typeof snap !== 'object' || snap.__rr_version == null) {
      throw new Error('Not a valid RotoRouter save file.');
    }
    if (!Number.isInteger(snap.N) || !Array.isArray(snap.board) || !Array.isArray(snap.players)) {
      throw new Error('Save is missing required fields.');
    }
    // Clear stacks only on real loads, not when applying from history
    if (!opts || !opts.fromHistory) {
      state.history = []; state.redo = [];
      state.turnHistory = []; state.turnRedo = [];
    }
    // Resize board if needed & sync dropdown
    state.N = snap.N;
    const sizeSel = UI.boardSize();
    if (sizeSel) {
      const opt = [...sizeSel.options].find(o => parseInt(o.value,10) === state.N);
      if (opt) sizeSel.value = String(state.N);
    }

    // Restore board
    state.board = makeBoard(state.N);
    initGearOffsets(state.N); // <- add this
    for (let y=0; y<state.N; y++) {
      for (let x=0; x<state.N; x++) {
        const s = (snap.board[y] && snap.board[y][x]) || {};
        state.board[y][x] = {
          track: s.track ?? null,
          rot: (s.rot|0) % 360,
          owner: (s.owner==null? null : s.owner|0),
          token: (s.token==null? null : s.token|0),
        };
      }
    }

    // Restore per-cell gear angles if present in the snapshot (Undo/Redo & Save/Load)
    if (Array.isArray(snap.gearOffset)) {
      state.gearOffset = Array.from({length: state.N}, (_, y) =>
        Array.from({length: state.N}, (_, x) => {
          const v = (snap.gearOffset[y] && snap.gearOffset[y][x]);
          return Number.isFinite(v) ? ((((v % 360) + 360) % 360)|0) : 0;
        })
      );
    } // else keep the zero-initialized offsets from initGearOffsets(N)    

    // Restore players (keep order aligned with PLAYERS by id)
    state.players = PLAYERS.map((baseP) => {
      const from = snap.players.find(pp => pp.id === baseP.id) || {};
      return {
        id: baseP.id,
        name: baseP.name,
        color: baseP.color,
        pocket: baseP.pocket,
        active: (typeof from.active === 'boolean') ? !!from.active : true,
        deck: {
          draw: [...(from.deck?.draw || [])],
          discard: [...(from.deck?.discard || [])],
        },
        drawn: from.drawn ?? null,
        tokens: from.tokens|0,
        tokensRemoved: from.tokensRemoved|0,
        drawLocked: !!from.drawLocked,
        drawUsed: !!from.drawUsed,
        tokenUsed: !!from.tokenUsed,
        rollUsed: !!from.rollUsed,
        skipCount: from.skipCount|0,
        elbowSkipCount: from.elbowSkipCount|0,
        forceElbow: !!from.forceElbow,
        forcePlaceNext: !!from.forcePlaceNext,
        reached: new Set(from.reached || []),
      };
    });

    // --- Robust legacy backfill for token counts ---
    // Newer code treats:
    //   tokensRemoved = lifetime tokens that have been removed from board (scored or otherwise gone)
    //   onBoard       = count of tokens currently on the board
    //   placed        = tokensRemoved + onBoard  (0..TOKENS_MAX)
    // Older saves often had `tokens: 3` for everyone and it did NOT mean "placed".
    for (const p of state.players) {
      const src = snap.players.find(pp => pp.id === p.id) || {};
      const onBoard = countTokens(p.id);
      const reachedLen =
        p.reached instanceof Set ? p.reached.size :
        Array.isArray(src.reached) ? src.reached.length : 0;

      const hasTokensRemoved = Number.isFinite(src.tokensRemoved);
      let tokensRemoved = hasTokensRemoved ? Math.max(0, Math.min(TOKENS_MAX, src.tokensRemoved|0)) : null;

      // Try to interpret legacy `tokens` if present.
      // Case A: it might be "remaining to place" (0..3). If so, remaining + onBoard + removed == TOKENS_MAX.
      let legacyTokens = Number.isFinite(src.tokens) ? Math.max(0, Math.min(TOKENS_MAX, src.tokens|0)) : null;
      let remainingGuess = null;
      if (legacyTokens != null) {
        // Treat as "remaining" if it yields a consistent total ≤ TOKENS_MAX when combined with onBoard and reached/removed.
        // Prefer using explicit tokensRemoved if provided; else fall back to reached count as a proxy for removals.
        const removedGuessFromReached = Math.max(0, Math.min(TOKENS_MAX, reachedLen));
        const removedRef = (tokensRemoved != null) ? tokensRemoved : removedGuessFromReached;
        const total = legacyTokens + onBoard + removedRef;
        if (total === TOKENS_MAX) {
          remainingGuess = legacyTokens;
          if (tokensRemoved == null) tokensRemoved = removedRef;
        }
      }

      // If we still don’t have tokensRemoved, infer from reached (common rule: scoring removes your token).
      if (tokensRemoved == null) tokensRemoved = Math.max(0, Math.min(TOKENS_MAX, reachedLen));

      // If even that yields zero evidence AND nothing is on the board, assume they’re “out” to avoid soft-locks.
      if (tokensRemoved === 0 && onBoard === 0 && legacyTokens == null && reachedLen === 0) {
        tokensRemoved = TOKENS_MAX;
      }

      // Finalize
      p.tokensRemoved = Math.max(0, Math.min(TOKENS_MAX, tokensRemoved));
      // Keep p.tokens coherent going forward: placed = removed + onBoard (cap at TOKENS_MAX).
      p.tokens = Math.max(0, Math.min(TOKENS_MAX, p.tokensRemoved + onBoard));
    }

    // Turn + corner bookkeeping
    state.current = (snap.current|0) % state.players.length;
    state.cornerLockTurns = Array.isArray(snap.cornerLockTurns)
      ? snap.cornerLockTurns.slice(0, PLAYERS.length)
      : PLAYERS.map(()=>0);
    state.cornerSealed = Array.isArray(snap.cornerSealed)
      ? snap.cornerSealed.slice(0, PLAYERS.length)
      : PLAYERS.map(()=>false);

    // Reset transients/animations/UI-phase safely
    state.phase = 'idle';
    state.subphase = null;
    state.highlight = [];
    state.hover = null;
    state.forcePlace = false;
    state.previewRot = 0;
    state.die = null;
    state.tokenSelect = null;
    state.rotateFocus = null;
    state.turnAdvancing = false;
    state.rotAnims = [];
    state.ghostRotAnim = null;
    state.deadFixDoneThisTurn = !!snap.deadFixDoneThisTurn;   // default false if absent

    // Recompute saturation immediately after restore
    refreshBoardSaturation();

    // Recompute any topology-derived hints (e.g., seals)
    if (typeof onTopologyChanged === 'function') onTopologyChanged();

    // Resize canvas for the (possibly) new N and redraw
    resize();
    updateHUD();

    if (opts && opts.fromHistory) {
      // After UNDO/REDO, re-enter fix phases (Corner Fix then Dead-Straight Fix) if eligible
      maybeEnterFixPhasesAfterHistory(opts.op);

      // If we are not in a fix subphase, show the provided status (e.g., “Redid (Global)”).
      if (state.phase !== 'cornerFix' && state.phase !== 'deadFix' && opts.status) {
        setStatus(opts.status);
      }
      render();
      return;
    }

    // ---- real file load path ----
    setStatus('Game loaded.');
    render();
    startTurn();
    return;
  }

  function loadFromFile(file) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const snap = JSON.parse(reader.result);
        applySnapshot(snap);
        toast('Save loaded successfully.');
      } catch (err) {
        console.error(err);
        toast('Failed to load: ' + err.message);
        setStatus('Load error: ' + err.message);
      }
    };
    reader.readAsText(file);
  }


  function resize(){
    const rightW = window.innerWidth - 360; const h = window.innerHeight;
    const size = Math.min(rightW, h) * 0.95;
    state.cell = Math.floor(size / state.N);
    state.pad = Math.floor((Math.min(rightW, h) - state.cell*state.N)/2);
    canvas.width = rightW; canvas.height = h;
    render();
  }
  window.addEventListener('resize', resize);

  function currentPlayer(){ return state.players[state.current]; }
  
function opponentCornerAt(x,y,pid){
  for(const q of PLAYERS){
    if(q.id===pid) continue;
    const c = cornerFor(q.id);
    if(c.x===x && c.y===y) return q.id;
  }
  return null;
}

function cornerFor(pid){
    const N=state.N; const p=PLAYERS[pid].pocket;
    if(p==='NW') return {x:0,y:0}; if(p==='NE') return {x:N-1,y:0}; if(p==='SE') return {x:N-1,y:N-1}; return {x:0,y:N-1};
  }
  function owned(pid){ const out=[]; for(let y=0;y<state.N;y++) for(let x=0;x<state.N;x++){ const c=state.board[y][x]; if(c.track && c.owner===pid) out.push({x,y}); } return out; }
  function within(x,y){ return x>=0 && y>=0 && x<state.N && y<state.N; }

  // ---- Dead-Straight detection helpers (STRICT: "trapped straight") ----
  function isStraightHorizontal(cell){
    return !!cell && cell.track === 'Straight' && ((cell.rot|0) % 180 === 0); // 0 or 180
  }
  function isStraightVertical(cell){
    return !!cell && cell.track === 'Straight' && ((cell.rot|0) % 180 !== 0); // 90 or 270
  }

  // STRICT + BORDER rule:
  // A Straight at (x,y) is “trapped” iff:
  // • Every *present* orthogonal neighbor is a Straight oriented perpendicular to the center, AND
  // • At least 3 neighbors are present (so corners with only 2 neighbors never qualify).
  // This covers:
  //   – Inner cells: need all 4 neighbors, all perpendicular (classic case).
  //   – Border cells: 3 in-bounds neighbors, all perpendicular ⇒ trapped.
  //   – Corner cells: only 2 neighbors ⇒ never trapped.
  function isTrappedStraight(x, y) {
    const c = state.board[y][x];
    if (!c || c.track !== 'Straight') return false;

    const centerIsH = isStraightHorizontal(c);

    // Describe the 4 orthogonal neighbors with bounds checks
    const neigh = [
      { nx: x - 1, ny: y,     need: centerIsH ? isStraightVertical : isStraightHorizontal }, // L
      { nx: x + 1, ny: y,     need: centerIsH ? isStraightVertical : isStraightHorizontal }, // R
      { nx: x,     ny: y - 1, need: centerIsH ? isStraightVertical : isStraightHorizontal }, // U
      { nx: x,     ny: y + 1, need: centerIsH ? isStraightVertical : isStraightHorizontal }, // D
    ];

    let present = 0;

    for (const n of neigh) {
      if (!within(n.nx, n.ny)) continue;           // out-of-bounds neighbor simply doesn't exist
      present++;
      const cell = state.board[n.ny][n.nx];
      if (!n.need(cell)) return false;             // present neighbor must be a Straight, perpendicular
    }

    // Require at least 3 present neighbors to count as trapped.
    // This allows border (3-side) traps and inner (4-side) traps, but excludes corners (2).
    return present >= 3;
  }

  function findAllTrappedStraights(){
    const out = [];
    for (let y=0; y<state.N; y++){
      for (let x=0; x<state.N; x++){
        if (isTrappedStraight(x,y)) out.push({x,y});
      }
    }
    return out;
  }

    // --- replace the entire maybeResumeDeadFixAfterHistory() with this unified helper ---
  function maybeEnterFixPhasesAfterHistory(op){
    if (state.turnAdvancing) return;
    if (state.phase !== 'idle') return;

    const P = currentPlayer();

    // Corner Fix has priority over Dead-Straight Fix
    if (typeof isCornerSealed === 'function' && isCornerSealed(P.id)) {
      startCornerFixCross(P.id);
      return;
    }

    // Dead-Straight Fix (only if not already consumed this turn)
    if (!state.deadFixDoneThisTurn && typeof findAllTrappedStraights === 'function') {
      const trapped = findAllTrappedStraights();
      if (trapped && trapped.length){
        state.phase    = 'deadFix';
        state.subphase = 'pickDeadStraight';
        state.highlight = trapped;
        const msg = 'Dead-Straight Fix: replace ONE highlighted Straight with a Cross (free).';
        setStatus(msg);
        render();
        updateHUD();
        return;
      }
    }
  }

  function isBoardFullyTracked(){
    for (let y=0; y<state.N; y++){
      for (let x=0; x<state.N; x++){
        const c = state.board[y][x];
        if (!c.track) return false;
      }
    }
    return true;
  }

  // Keep a cached flag on state
  state.boardSaturated = false;
  function refreshBoardSaturation(){
    const was = !!state.boardSaturated;
    state.boardSaturated = isBoardFullyTracked();
    if (!was && state.boardSaturated){
      setStatus('Board is full of tracks — normal placement locked. Tokens, rotations, and rotate/replace cards (RS/RE/RC) still allowed.');
      toast('Board fully tracked: track placement locked.');
    }
  }

  // Count tokens for a player
  function countTokens(pid){
    let n=0;
    for(let y=0;y<state.N;y++) for(let x=0;x<state.N;x++){ if(state.board[y][x].token===pid) n++; }
    return n;
  }
  function allTokensOf(pid){
    const arr=[];
    for(let y=0;y<state.N;y++) for(let x=0;x<state.N;x++){ if(state.board[y][x].token===pid) arr.push({x,y}); }
    return arr;
  }

  function playerHasFinished(P){
    if (!P) return false;
    const reached = P.reached
      ? (P.reached instanceof Set ? P.reached : new Set(P.reached))
      : new Set();
    return reached.size >= 3;
  }

  // BFS for token moves — by default do NOT pass through any tokens.
  // If no destinations exist under that rule, do a fallback BFS that allows
  // pass-through over *opponent* tokens (never over your own). Corners can’t
  // be blocked: moving onto an opponent’s corner is always a legal terminal.
  function reachableFrom(start, pid){
    const run = (allowPassThroughOpp=false) => {
      const vis = new Set();
      const q = [start];
      const out = [];
      const key = (x,y)=>x+','+y;
      vis.add(key(start.x,start.y));
      while(q.length){
        const {x,y} = q.shift();
        const here = state.board[y][x];
        if(!here.track || here.track==='Block') continue;
        for(const [dx,dy] of rotatedOpenings(here)){
          const nx = x+dx, ny = y+dy;
          if(!within(nx,ny)) continue;
          const there = state.board[ny][nx];
          if(!there.track || there.track==='Block') continue;
          if(!hasReciprocal(here, there, dx, dy)) continue; // pipes must connect both ways
          const k = key(nx,ny);
          if(vis.has(k)) continue;

          const oppId = opponentCornerAt(nx,ny,pid);
          const ownerOnOwnCorner = (oppId!=null && there.token===oppId);
          if (oppId != null) {
            // If this opponent's corner has ALREADY been reached by this player,
           // do NOT offer it again as a destination.
            const P = state.players[pid];
            const reachedSet = P?.reached
              ? (P.reached instanceof Set ? P.reached : new Set(P.reached))
              : new Set();
            const oppName = PLAYERS[oppId].name;

            if (reachedSet.has(oppName)) {
              // We've already scored this opponent; their corner should not be reachable again.
              vis.add(k);
              // Do not add to 'out' and do not traverse beyond the corner.
              continue;
            }
          }
          // Corners can't be blocked: moving onto opponent's corner (with their token present)
          // is a legal terminal IF not already scored above.
          if (ownerOnOwnCorner){
            vis.add(k);
            out.push({x:nx,y:ny});
            continue; // do not traverse beyond an opponent's scored corner
          }

          // Token blocking logic
          if (there.token != null){
            // Never pass through your own token
            if (there.token === pid) continue;
            // Pass-through over opponent tokens only if fallback is enabled
            if (!allowPassThroughOpp) continue;
            // Fallback path: traverse through opponent token, but cannot stop on it
            vis.add(k);
            q.push({x:nx,y:ny});
            continue;
          }

          // Empty neighbor: traverse and consider as a legal destination
          vis.add(k);
          q.push({x:nx,y:ny});
          out.push({x:nx,y:ny});
        }
      }
      return out;
    };
    // Phase 1: strict (no pass-through over any tokens)
    const strict = run(false);
    if (strict.length > 0) return strict;
    // Phase 2: fallback only if strictly trapped by *opponents'* tokens
    return run(true);
  }

  // Game flow
  function newGame(){
  // Use the in-game dropdown as the source of truth.
  const uiSize = parseInt(UI.boardSize().value, 10) || 9;
  state.N = uiSize;
  // Keep the saved setup aligned with the in-game choice (so Main Menu and reloads match).
  state.setup = state.setup || {};
  state.setup.boardSize = uiSize;
  try { localStorage.setItem('rr.setup', JSON.stringify(state.setup)); } catch {}    state.board = makeBoard(state.N);
    initGearOffsets(state.N); // <- add this
    state.players = PLAYERS.map(p=>{
      const cfg = (state.setup?.players && state.setup.players[p.id]) || { name:p.name, ai:false, active:(p.id<2) };
      return {
        id: p.id,
        name: cfg.name || p.name,
        color: p.color,
        pocket: p.pocket,
        ai: !!cfg.ai,
        active: !!cfg.active,
        deck: makeDeck(state.N),
        drawn:null, tokens:0, tokensRemoved:0,
        drawLocked:false, drawUsed:false, tokenUsed:false, rollUsed:false,
        skipCount: 0, elbowSkipCount: 0, forceElbow: false, forcePlaceNext: false
      };
    });    
    state.cornerLockTurns = PLAYERS.map(() => 0);
    state.cornerSealed    = PLAYERS.map(() => false);
    state.current = 0;
    state.forceElbowFor = null;

    // Reset undo/redo
    state.history = []; state.redo = [];
    state.turnHistory = []; state.turnRedo = [];

    // Now start the turn; this will push the baseline snapshot
    startTurn();
    updateUndoButtons();

    setStatus('New Game → Draw → Place. First placement is your corner.');
    state.rotAnims = [];
    state.ghostRotAnim = null;
    state._animating = false;
    if (Array.isArray(state.players)) for (const pl of state.players) pl.tokens = 0;
    refreshBoardSaturation();
      // >>> add this at the very end of newGame():
    requestAnimationFrame(()=>{
      resize();
      requestAnimationFrame(resize);
    });
  }

  function startTurn(){
     // Find the next *eligible* player without recursive calls.
    let hops = 0;
    while (hops < state.players.length) {
      const Ptest = state.players[state.current];
      // Skip colors that are not active from setup
      if (!Ptest.active) {
        state.current = (state.current + 1) % state.players.length;
        hops++;
        continue;
      }      
      const onBoardTest = countTokens(Ptest.id);
      const finished    = playerHasFinished(Ptest);
      const outOfTokens = ((Ptest.tokensRemoved|0) >= TOKENS_MAX) && onBoardTest === 0;
      if (!finished && !outOfTokens) break;          // active turn found

      // Skip this player and try the next
      toast(Ptest.name + (finished ? ' has finished (3/3 corners)' : ' has no tokens remaining') + ' — skipping turn.');
      state.current = (state.current + 1) % state.players.length;
      hops++;
    }
    if (hops >= state.players.length) {
      // No active players remain → game over
      state.phase = 'gameOver';
      // setStatus('<span style="color:#28d07a; font-weight:700;">All players have finished — game over.</span>');
      setStatus('<span class="ok">All players have finished — game over.</span>');
      updateHUD();
      return;
    }

    const P = currentPlayer();
    resetTurnHistory();
    P.drawLocked=false; P.drawUsed=false; P.tokenUsed=false; P.rollUsed=false;
    P.rotatedThisTurn = false;  // track meaningful board action
    state.deadFixDoneThisTurn = false;
    state.phase='idle'; state.subphase=null; state.highlight=[]; state.hover=null; state.previewRot=0; state.die=null; state.tokenSelect=null; state.rotateFocus=null;
    // Open a short window where "force next turn" can activate
    state._enforceForcePlaceWindow = true;
    checkForcePlace();    
    // If we're entering a forced draw+place window, consume the arming flag now.
    if (state.forcePlace && currentPlayer().forcePlaceNext) {
      currentPlayer().forcePlaceNext = false;
    }
    // Close the window so mid-turn calls won’t trigger the force
    state._enforceForcePlaceWindow = false;
    // Ensure counter exists on first load (startTurn runs before newGame)
    if (!state.cornerLockTurns) state.cornerLockTurns = PLAYERS.map(()=>0);    

    // Corner lock tracker — trigger only when the corner is *truly* locally sealed:
    // corner has a track, both neighbors have tracks, and no single-tile rotation (corner or either neighbor)
    // can create a reciprocal connection into the board.
    const owner = currentPlayer();
    if (isCornerSealed(owner.id)) {
      state.cornerLockTurns[owner.id] = (state.cornerLockTurns[owner.id] || 0) + 1;
    } else {
      state.cornerLockTurns[owner.id] = 0;
    }
    // Immediate Corner Fix if THIS owner's corner is sealed (detected on last topology change)
    if (isCornerSealed(P.id)) {
      startCornerFixCross(P.id);
      return; // fix subphase renders/locks HUD
    }
    // --- Dead-Straight Fix (STRICT: trapped straight) ---
    if (state.phase !== 'cornerFix'){ // don't collide with Corner Fix UI
      const trapped = findAllTrappedStraights();
      if (trapped.length && !state.deadFixDoneThisTurn) {
        state.phase    = 'deadFix';
        state.subphase = 'pickDeadStraight';
        state.highlight = trapped;

        const msg = 'Dead-Straight Fix: replace ONE highlighted Straight with a Cross (free).';
        setStatus(msg);
        toast(msg);

        render();
        updateHUD();
        return; // wait for the click on one of the highlighted cells
      }
    }
    // --- end Dead-Straight Fix ---
    // --- end Dead-Straight Fix ---        
    updateHUD();
  }

  function endTurnImmediate(){
    pushHistory('End Turn');

    // If the ending player is still holding a track card, count as a skip
    const endingP = state.players[state.current];
    if (endingP.drawn && isTrackCard(endingP.drawn)) {
      endingP.skipCount++;
      if (endingP.skipCount >= 3) {
        endingP.forcePlaceNext = true;  // enforce on their NEXT turn
      }      
    }

    // If they are holding an Elbow, count an elbow-skip too
    if (endingP.drawn === TrackCard.Elbow) {
      endingP.elbowSkipCount++;
      checkForceElbow(endingP);
    }    

    state.current=(state.current+1)%state.players.length;
    startTurn();
    // Don't overwrite Fix prompts or GameOver after startTurn()
    if (state.phase !== 'cornerFix' && state.phase !== 'deadFix' && state.phase !== 'gameOver') {
      setStatus('Turn passed.');
    }
    state.turnAdvancing=false;
  }

  function endTurn(){
    // Block ending the turn if an Elbow is being forced and can be placed now.
    const P = currentPlayer();
    if ((state.forceElbowFor === P.id) && (P.drawn === TrackCard.Elbow) && canPlaceElbowNow(P.id)) {
      setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
      toast('Forced Elbow: End Turn disabled');
      return;
    }    
    if (state.forcePlace) {
      setStatus('Maximum track cards skipped — you must place a legal track before ending your turn.');
      toast('Forced placement: End Turn disabled');
      return;
    }    
    if(state.turnAdvancing) return;
    state.turnAdvancing=true;
    setTimeout(endTurnImmediate, 120);
  }

  // Draw (1/turn)
  function drawCard(){
    pushHistory('Draw');

    if (state.boardSaturated){
      const P = currentPlayer();
      if (!hasRotationInDeck(P)) {
        setStatus('Board is full of tracks — drawing is locked (no RS/RE/RC left in deck).');
        toast('Draw locked (board full; no rotations left)');
        return;
      }
      // else: rotations remain → drawing is allowed
    }
    const P=currentPlayer();
    if(P.drawLocked && !state.forcePlace){ setStatus('You bottomed this turn; drawing is locked until End Turn.'); return; }
    if(P.drawUsed   && !state.forcePlace){ setStatus('You have already drawn this turn. End Turn to draw again next turn.'); return; }

    if(P.drawn){ setStatus('Already holding a card. Place or Bottom.'); return; }
    if(P.deck.draw.length===0 && P.deck.discard.length>0){ P.deck.draw=shuffle(P.deck.discard.splice(0)); }
    if(P.deck.draw.length===0){ setStatus('Deck empty.'); return; }
    P.drawn=P.deck.draw.shift();
    // If max-skips is forcing placement but this card cannot be placed anywhere,
    // waive the force rule now to avoid deadlocks.
    checkForcePlace();
    updateHUD();
    // If elbow is being forced and an Elbow was drawn but can't be placed, waive the force.
    if (state.forceElbowFor === P.id && P.drawn === TrackCard.Elbow) {
      if (!canPlaceElbowNow(P.id)) {
        state.forceElbowFor = null;
        setStatus('Force (Elbow) waived — no legal Elbow placement.');
        updateHUD();
      }
    }
    // If player is over the elbow-skip threshold and just drew an Elbow
    // that can be placed now, activate the force immediately.
    if ((P.elbowSkipCount|0) >= 3 && P.drawn === TrackCard.Elbow && canPlaceElbowNow(P.id)) {
      state.forceElbowFor = P.id;
    }

    // While forced, we don't mark Draw as "Used" so the button stays enabled until a placement happens.
    P.drawUsed = state.forcePlace ? false : true;
    const elbowForceNow =
      (state.forceElbowFor === P.id) &&
      (P.drawn === TrackCard.Elbow) &&
      canPlaceElbowNow(P.id);
    updateHUD();
    if (elbowForceNow) {
      setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
    } else {
      setStatus(`${P.name} drew ${P.drawn}. Click Place.`);
    }
  }

// Placement includes adjacency to player's tokens (even if token is on opponent tile)
function connectedTrackFromCorner(pid){
  const start = cornerFor(pid);
  const key = (x,y)=>x+','+y;
  const vis = new Set();
  const comp = [];
  const q = [];
  if (!within(start.x,start.y)) return comp;
  const startCell = state.board[start.y][start.x];
  if (!startCell.track){ return comp; } // No network yet if no track at corner
  q.push({x:start.x,y:start.y}); vis.add(key(start.x,start.y)); comp.push({x:start.x,y:start.y});
  while(q.length){
    const {x,y} = q.shift();
    const here = state.board[y][x];
    if(!here.track || here.track==='Block') continue;
    const opens = rotatedOpenings(here);
    for(const [dx,dy] of opens){
      const nx=x+dx, ny=y+dy; if(!within(nx,ny)) continue;
      const there = state.board[ny][nx];
      if(!there.track || there.track==='Block') continue;
      // openings must match in opposite direction
      const reciprocal = [-dx,-dy];
      const hasBack = rotatedOpenings(there).some(([adx,ady])=>adx===reciprocal[0] && ady===reciprocal[1]);
      if(!hasBack) continue;
      const k = key(nx,ny);
      if(!vis.has(k)){ vis.add(k); q.push({x:nx,y:ny}); comp.push({x:nx,y:ny}); }
    }
  }
  return comp;
}

function connectedTrackFrom(x0, y0){
  const key = (x,y)=>x+','+y;
  const vis = new Set();
  const comp = [];
  if (!within(x0,y0)) return comp;
  const start = state.board[y0][x0];
  if (!start.track) return comp;

  const q = [{x:x0,y:y0}];
  vis.add(key(x0,y0));
  comp.push({x:x0,y:y0});

  while(q.length){
    const {x,y} = q.shift();
    const here = state.board[y][x];
    if(!here.track || here.track==='Block') continue;

    for(const [dx,dy] of rotatedOpenings(here)){
      const nx = x+dx, ny = y+dy;
      if(!within(nx,ny)) continue;
      const there = state.board[ny][nx];
      if(!there.track || there.track==='Block') continue;
      if(!hasReciprocal(here, there, dx, dy)) continue;

      const k = key(nx,ny);
      if(!vis.has(k)){
        vis.add(k);
        q.push({x:nx,y:ny});
        comp.push({x:nx,y:ny});
      }
    }
  }
  return comp;
}


// Start: Code to prevent "corner-lockout"
function cornerNeighbors(pid){ // returns [{x,y} corner, {x,y} n1, {x,y} n2]
  const c = cornerFor(pid);
  if (PLAYERS[pid].pocket === 'NW') return [c, {x:1,y:0},{x:0,y:1}];
  if (PLAYERS[pid].pocket === 'NE') return [c, {x:state.N-2,y:0},{x:state.N-1,y:1}];
  if (PLAYERS[pid].pocket === 'SE') return [c, {x:state.N-2,y:state.N-1},{x:state.N-1,y:state.N-2}];
  // SW
  return [c, {x:1,y:state.N-1},{x:0,y:state.N-2}];
}

// --- Corner seal detector (local, rotation-cost aware) ---
// A corner is considered sealed iff BOTH adjacent neighbors exist AND, for each neighbor,
// the minimal number of tiles you'd need to rotate (corner and/or that neighbor) to create
// a reciprocal connection is > 1. In other words: there is NO one-tile fix.
const RR_ROTATIONS = [0,90,180,270];
function rotatedOpeningsType(type, rot){ return OPENINGS[type].map(([dx,dy])=>rotDir([dx,dy], rot)); }
function hasReciprocalTypes(typeA, rotA, typeB, rotB, dx, dy){
  const aOK = rotatedOpeningsType(typeA, rotA).some(([rx,ry])=>rx===dx && ry===dy);
  if(!aOK) return false;
  const bOK = rotatedOpeningsType(typeB, rotB).some(([rx,ry])=>rx===-dx && ry===-dy);
  return bOK;
}
function minRotationsToConnect(cornerCell, nbrCell, dx, dy){
  if(!cornerCell?.track || !nbrCell?.track) return Infinity;
  let best = Infinity;
  for (const rc of RR_ROTATIONS){
    for (const rn of RR_ROTATIONS){
      if (hasReciprocalTypes(cornerCell.track, rc, nbrCell.track, rn, dx, dy)){
        const cost = (rc===cornerCell.rot?0:1) + (rn===nbrCell.rot?0:1); // tile-count cost
        if (cost < best) best = cost;
      }
    }
  }
  return best;
}

function isCornerSealed(pid){
  const [co, n1, n2] = cornerNeighbors(pid);
  const corner = state.board[co.y][co.x];
  const a = state.board[n1.y][n1.x];
  const b = state.board[n2.y][n2.x];
  if (!corner.track) return false;
  if (!(a.track && b.track)) return false; // evaluate only once both neighbors exist

  // Only the explicit "perpendicular straights jam" counts as sealed.
  // Corner must be a Straight, and both adjacent tiles must be Straights, and
  // both must be perpendicular to the corner's orientation.
  if (corner.track !== 'Straight') return false;
  if (!(a.track === 'Straight' && b.track === 'Straight')) return false;
  const isH = (rot) => ((rot % 180) === 0);
  const cornerIsHorizontal = isH(corner.rot);
  const aIsHorizontal      = isH(a.rot);
  const bIsHorizontal      = isH(b.rot);
  // Horizontal corner jammed by two verticals, or vertical corner jammed by two horizontals
  return (cornerIsHorizontal && !aIsHorizontal && !bIsHorizontal) ||
         (!cornerIsHorizontal && aIsHorizontal && bIsHorizontal);
}

function startCornerFixCross(ownerId){
  state.phase = 'cornerFix';
  state.fixOwner  = ownerId;
  state.fixCorner = cornerFor(ownerId); // {x,y}
  state.highlight = [state.fixCorner];
  state.rotateFocus = null; state.previewRot = 0;
  // Show a persistent RED warning while the fix is pending
  setStatus('<span class="warn">Your corner is sealed. Click on your corner track to replace it with a cross track.</span>');
  updateHUD();
}
// Recompute corner seals after any topology change and toast when a new seal appears
function onTopologyChanged(){
  if (!state.cornerSealed) state.cornerSealed = PLAYERS.map(()=>false);
  const prev = state.cornerSealed.slice();
  const now  = PLAYERS.map(p=>isCornerSealed(p.id));
  state.cornerSealed = now;
  for (let pid=0; pid<PLAYERS.length; pid++){
    if (now[pid] && !prev[pid]){
      // Keep toast visible long enough to read
      toast(PLAYERS[pid].name + " corner sealed — corner will be auto-fixed on their next turn.", 4500);      
    }
  }
  refreshBoardSaturation();
}

// Correctly compute placement highlight positions applying these rules:
// (1) Corner-connected network (net): ownership-agnostic, so if you connect into an opponent’s tracks, their connected network is usable too.
// (2) Owned tiles (myOwned): so you can still build from your isolated islands.
// (3) Tokens (myTokens): already supported.
// (4) RS/RE special: allows selecting any existing Straight/Elbow of the correct type for rotation.
function computePlaceHighlights(){
  const pid = currentPlayer().id;
  const myOwned = owned(pid);
  const net = connectedTrackFromCorner(pid);
  const myTokens = allTokensOf(pid);
  const adj = new Map();

  // Adjacent to networks connected to ANY of my tokens (ownership-agnostic)
  // This fixes the “two cells away via a connected straight” case.
  for (const t of myTokens){
    const comp = connectedTrackFrom(t.x, t.y);
    for (const p of comp){
      const neighs = [
        [p.x+1, p.y], [p.x-1, p.y],
        [p.x, p.y+1], [p.x, p.y-1]
      ];
      for (const [x,y] of neighs){
        if(!within(x,y)) continue;
        const c = state.board[y][x];
        if(!c.track && c.token==null){
          adj.set(x+','+y, {x,y});
        }
      }
    }
  }

  /* RS/RE/RT HIGHLIGHTS (rotate existing of same base type) */
  const D = currentPlayer().drawn;
  const base = baseDrawnType(D);
  if (D===TrackCard.RStraight || D===TrackCard.RElbow || D===TrackCard.RT){
    for(let yy=0; yy<state.N; yy++){
      for(let xx=0; xx<state.N; xx++){
        const c = state.board[yy][xx];
        if(c.track===base && c.track!=='Block'){
          adj.set(xx+','+yy, {x:xx,y:yy});
        }
      }
    }
  }

  // RC (Replaceable Cross): any existing track is a valid target
  if (D===TrackCard.RCross){
    for(let yy=0; yy<state.N; yy++){
      for(let xx=0; xx<state.N; xx++){
        const c = state.board[yy][xx];
        //if(c.track==='Cross'){ adj.set(xx+','+yy, {x:xx,y:yy}); }
        if(c.track){ adj.set(xx+','+yy, {x:xx,y:yy}); }
      }
    }
    // Also allow RC to be PLACED on your own empty corner (not just replace)
    const co = cornerFor(pid);
    const cCell = state.board[co.y][co.x];
    if(!cCell.track && cCell.token==null){
      adj.set(co.x+','+co.y, {x:co.x, y:co.y});
    }
    // And allow RC to be PLACED on any empty cell orthogonally adjacent to YOUR corner
    // when your corner already has a track (regardless of who owns that track).
    if (cCell.track){
      const neigh = [
        {x:co.x+1, y:co.y},
        {x:co.x-1, y:co.y},
        {x:co.x,   y:co.y+1},
        {x:co.x,   y:co.y-1},
      ];
      for (const n of neigh){
        if(!within(n.x,n.y)) continue;
        const cc = state.board[n.y][n.x];
        if(!cc.track && cc.token==null){
          adj.set(n.x+','+n.y, {x:n.x, y:n.y});
        }
      }
    }
  }
  // Adjacent to tracks connected to my corner (ownership-agnostic)
  for(const p of net){
    [[p.x+1,p.y],[p.x-1,p.y],[p.x,p.y+1],[p.x,p.y-1]].forEach(([x,y])=>{
      if(!within(x,y)) return;
      const c = state.board[y][x];
      if(!c.track && c.token==null) adj.set(x+','+y,{x,y});
    });
  }

  // Adjacent to ANY of my owned tracks (not just corner-connected)
  for(const p of myOwned){
    [[p.x+1,p.y],[p.x-1,p.y],[p.x,p.y+1],[p.x,p.y-1]].forEach(([x,y])=>{
      if(!within(x,y)) return;
      const c = state.board[y][x];
      if(!c.track && c.token==null) adj.set(x+','+y,{x,y});
    });
  }

  // Adjacent to any of my tokens
  for(const t of myTokens){
    [[t.x+1,t.y],[t.x-1,t.y],[t.x,t.y+1],[t.x,t.y-1]].forEach(([x,y])=>{
      if(!within(x,y)) return;
      const c = state.board[y][x];
      if(!c.track && c.token==null) adj.set(x+','+y,{x,y});
    });
  }

  // If this is truly the first placement and the only things in `adj` are rotation targets
  // (i.e., there are NO empty cells to place on), also allow placing on your own empty corner.
  const firstPlacement = (myOwned.length===0 && myTokens.length===0 && net.length===0);

  // Do we already have at least one EMPTY target in adj?
  let hasEmptyAdj = false;
  for (const v of adj.values()){
    const cc = state.board[v.y][v.x];
    if (!cc.track && cc.token==null) { hasEmptyAdj = true; break; }
  }

  if (firstPlacement && !hasEmptyAdj){
    const co = cornerFor(pid);
    const cCell = state.board[co.y][co.x];
    if (!cCell.track && cCell.token==null){
      // Add the player's own corner as a legal placement (in addition to rotate targets)
      adj.set(co.x+','+co.y, {x:co.x, y:co.y});
    }
  }

  // Finalize highlights
  state.highlight = Array.from(adj.values());
}

// Returns true if the current player's *currently drawn card* has at least one legal
// placement (using the same logic as computePlaceHighlights), without mutating highlight.
function canPlaceDrawnNow(pid){
  const P = currentPlayer();
  if (!P.drawn) return false;
  // Save/restore the mutable bits touched by computePlaceHighlights
  const prev = {
    highlight: state.highlight ? state.highlight.slice() : [],
    phase: state.phase,
    subphase: state.subphase,
  };
  try{
    // We only need the set of legal cells; computePlaceHighlights reads P.drawn
    // and populates state.highlight accordingly.
    computePlaceHighlights();
    return (state.highlight && state.highlight.length > 0);
  } finally {
    state.highlight = prev.highlight;
    state.phase = prev.phase;
    state.subphase = prev.subphase;
  }
}

// Can the current player place an Elbow *anywhere* right now?
function canPlaceElbowNow(playerId){
  const P = state.players.find(pp => pp.id === playerId);
  if (!P) return false;

  const saved = P.drawn;
  P.drawn = TrackCard.Elbow;
  let ok = false;
  try {
    if (typeof canPlaceDrawnNow === 'function') {
      ok = !!canPlaceDrawnNow(playerId);
    } else {
      const prevPhase = state.phase, prevSub = state.subphase, prevHL = state.highlight;
      state.phase = 'place'; state.subphase = null; state.highlight = [];
      computePlaceHighlights();
      ok = Array.isArray(state.highlight) && state.highlight.length > 0;
      state.phase = prevPhase; state.subphase = prevSub; state.highlight = prevHL;
    }
  } finally {
    P.drawn = saved; // restore
  }
  return ok;
}


function canPlaceCardNow(playerId, cardType){
  const P = state.players.find(pp => pp.id === playerId);
  if (!P) return false;

  const saved = P.drawn;
  P.drawn = cardType;

  let ok = false;
  try {
    if (typeof canPlaceDrawnNow === 'function') {
      ok = !!canPlaceDrawnNow(playerId);
    } else {
      const prevPhase = state.phase, prevSub = state.subphase, prevHL = state.highlight;
      state.phase = 'place'; state.subphase = null; state.highlight = [];
      computePlaceHighlights();
      ok = Array.isArray(state.highlight) && state.highlight.length > 0;
      state.phase = prevPhase; state.subphase = prevSub; state.highlight = prevHL;
    }
  } finally {
    P.drawn = saved;
  }
  return ok;
}

function baseDrawnType(card){
  if(card===TrackCard.RStraight) return TrackCard.Straight;
  if(card===TrackCard.RElbow)    return TrackCard.Elbow;
  if(card===TrackCard.RCross)    return TrackCard.Cross;
  if(card===TrackCard.RT)        return TrackCard.T;
  return card;
}

function isTrackCard(card){
  return [
    TrackCard.Straight, TrackCard.Elbow, TrackCard.Cross, TrackCard.T,
    TrackCard.RStraight, TrackCard.RElbow, TrackCard.RCross, TrackCard.RT
  ].includes(card);
}

function isRotationCard(card){
  return card===TrackCard.RStraight || card===TrackCard.RElbow || card===TrackCard.RCross || card===TrackCard.RT;
}

function hasRotationInDeck(P){
  const draw = (P.deck && Array.isArray(P.deck.draw)) ? P.deck.draw : [];
  const disc = (P.deck && Array.isArray(P.deck.discard)) ? P.deck.discard : [];
  const all  = draw.concat(disc);
  return all.some(c =>
    c===TrackCard.RStraight || c===TrackCard.RElbow || c===TrackCard.RCross || c===TrackCard.RT
  );
}

function checkForcePlace(){
  const P = currentPlayer();

  // 1) Activate ONLY at start of the player's NEXT turn (window set in startTurn()).
  if (!state.forcePlace) {
    const shouldActivate =
      (!!state._enforceForcePlaceWindow) &&
      (!state.boardSaturated) &&
      (!!P.forcePlaceNext);
    if (shouldActivate) {
      state.forcePlace = true;             // becomes sticky for this turn
      if (!P.drawn) {                      // allow/require a draw
        P.drawLocked = false;
        P.drawUsed   = false;
      }
    }
  }

  // 2) While forced, if they DO hold a card but it has ZERO legal placements,
  //    waive the force to avoid deadlocks (lets Bottom/end turn).
  if (state.forcePlace && P.drawn && !canPlaceDrawnNow(P.id)) {
    state.forcePlace = false;
  }
}

function checkForceElbow(P){
  // Threshold: must have skipped ≥3 Elbows *and* the board isn't saturated in a way that blocks placement.
  const mustForce = (P.elbowSkipCount|0) >= 3;
  if (mustForce && canPlaceElbowNow(P.id)) {
    state.forceElbowFor = P.id;   // only force if an Elbow can actually be placed now
  } else {
    state.forceElbowFor = null;   // waive otherwise (prevents deadlocks)
  }
}

  function placeMode(){
    // --- CONFIRM: if we are in rotateNew (tap-to-rotate) and a focus exists, commit placement ---
    if (state.phase === 'place' && state.subphase === 'rotateNew' && state.rotateFocus) {
      const P = currentPlayer();
      const { x, y } = state.rotateFocus;
      const cell = state.board[y][x];

      // Commit at the preview angle
      const placedType = baseDrawnType(P.drawn);
      pushHistory('Place/Replace');
      cell.track = placedType;
      cell.rot   = mod360(state.previewRot || 0);
      cell.owner = P.id;

      P.deck.discard.push(P.drawn);
      P.drawn = null;
      P.skipCount = 0;
      state.forcePlace = false;
      if (placedType === TrackCard.Elbow) {
        P.elbowSkipCount = 0;
        state.forceElbowFor = null;
      }

      pulse(x,y);
      state.ghostRotAnim = null;
      state.subphase = null;
      state.rotateFocus = null;
      state.previewRot  = 0;
      state.phase='idle';
      state.highlight=[];
      state.hover=null;

      if (typeof onTopologyChanged === 'function') onTopologyChanged();
      render();
      updateHUD();
      setStatus('Placed. You cannot draw again this turn.');
      maybeAutoAdvance();
      return;
    }

    const P=currentPlayer();
    if (state.boardSaturated && !isRotationCard(P.drawn)){
      setStatus('Board is full of tracks — only RS/RE/RC can be placed (rotate/replace).');
      toast('Place disabled (board full; use RS/RE/RC)');
      return;
    }    
    if(!P.drawn){ setStatus('Draw a card first.'); return; }
    state.phase='place'; state.subphase=null; computePlaceHighlights(); updateHUD();
    // If we're in a forced-place state but *nothing* is legal for this card,
    // waive the force so Bottom/End Turn become available.
    if (state.forcePlace && (!state.highlight || state.highlight.length===0)) {
      state.forcePlace = false;
      updateHUD();
    }
    // Mirror waiver for elbow-specific forcing (only if holding an Elbow)
    if (state.forceElbowFor === P.id && P.drawn === TrackCard.Elbow) {
      if (!state.highlight || state.highlight.length === 0) {
        state.forceElbowFor = null;
        updateHUD();
      }
    }
    if (!state.highlight || state.highlight.length === 0){
      setStatus('No legal placement exists for this card. Use Bottom to cycle it without penalty.');
      toast('No legal placement for this card');
    } else {
      setStatus('Placement: hover to preview, click to confirm. Rotate with Q/E.');
    }
  }

 function bottomCard(){
  const P=currentPlayer();
  // If max-skips is forcing a placement and the drawn card CAN be placed somewhere,
  // Bottom is not allowed this turn.
  if (state.forcePlace && P.drawn && canPlaceDrawnNow(P.id)) {
    setStatus('Maximum track cards skipped — you must PLACE your drawn track before ending your turn.');
    toast('Forced placement: Bottom is disabled');
    return;
  }  
  // Block Bottom if this player is forced to place an Elbow and it is placeable now.
  if ((state.forceElbowFor === P.id) && (P.drawn === TrackCard.Elbow) && canPlaceElbowNow(P.id)) {
    setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
    toast('Forced Elbow: Bottom is disabled');
    return;
  }

  if(!P.drawn){ setStatus('Nothing to bottom.'); return; }
   // Check if this card has *no* legal placement anywhere on the board.
   // On a full board, normal tracks have no legal placements; RS/RE/RC may still be placeable.
   const noPlace = !canPlaceDrawnNow(P.id);
   pushHistory(noPlace ? 'Bottom (No-Place, no penalty)' : 'Bottom');
   const bottomed = P.drawn;                  // capture BEFORE clearing
   P.deck.draw.push(bottomed);                // move to bottom
   P.drawn = null;                            // clear the hand
   if (noPlace){
     // --- NO-PENALTY BOTTOM ---
     // Do NOT lock drawing; do NOT increment any skip counters.
     // BUT: this counts as your one draw for the turn (cannot chain Bottoms).
     P.drawLocked   = false;   // not locked, just "used"
     P.drawUsed     = true;    // ← mark Draw as Used for this turn
     setStatus('No legal placement exists for that card — moved to bottom without penalty. Draw is now Used for this turn.');
   } else {
    // --- NORMAL BOTTOM (with penalties) ---
    P.drawLocked = true;
    // Only penalize if they truly did nothing meaningful this turn
    const penalize = !(P.tokenUsed || P.rotatedThisTurn);
    // And never penalize if this was an elbow-forced turn with *no* legal elbow
    const forcedButImpossible =
      (state.forceElbowFor === P.id) && !canPlaceElbowNow(P.id);
    if (penalize && !forcedButImpossible) {
      P.skipCount++;
      if (P.skipCount >= 3) {
        P.forcePlaceNext = true;   // do NOT force mid-turn; enforce next turn
      }      
      if (bottomed === TrackCard.Elbow) {
        P.elbowSkipCount = (P.elbowSkipCount|0) + 1;
        checkForceElbow(P);                // ← elbow-only checker
      }
    }
    // If we waived elbow force, clear it explicitly
    if (forcedButImpossible) state.forceElbowFor = null;
    setStatus('Bottomed. Drawing is locked until End Turn.');
   }
 
   state.phase='idle'; state.highlight=[]; state.hover=null;
   checkForcePlace();
   updateHUD();
   maybeAutoAdvance();
 }

  // Token flow (select-first; corner placement allowed if < TOKENS_MAX)
  function tokenMode(){
    const P=currentPlayer();
    if(P.tokenUsed){ setStatus('Token action already used this turn.'); return; }
    state.phase = 'token'; state.subphase='select'; state.highlight=[]; state.hover=null; state.tokenSelect=null;

    const myTokens = allTokensOf(P.id);
    const options = [...myTokens];
    const corner = cornerFor(P.id);
    const cCell = state.board[corner.y][corner.x];
    const myCount = countTokens(P.id);
    // Safety: treat "removed" as max(tokensRemoved, reached.size) so old snapshots can’t over-place
    const reachedCount = P.reached ? (P.reached instanceof Set ? P.reached.size : new Set(P.reached).size) : 0;
    const effectiveRemoved = Math.max((P.tokensRemoved|0), reachedCount);
    const lifetimePlaced = Math.min(TOKENS_MAX, effectiveRemoved + myCount);

    if (lifetimePlaced < TOKENS_MAX && cCell.track && cCell.token == null) {
      options.push(corner);
    }
    state.highlight = options;
    if(options.length===0){
      // No tokens on board and no corner placement available — do NOT auto-advance.
      setStatus('No tokens to apply an action to. Place a token at your corner first or Draw/Place tracks.');
      toast('No tokens to act on');
      // Keep Token Action available: exit token mode without consuming the action.
      state.phase='idle'; state.subphase=null; state.tokenSelect=null; state.highlight=[]; state.hover=null;
      render(); updateHUD();
      return;
    } 
    setStatus('Token: click a token to move OR click your corner to place a new token (lifetime total of 3).');
    updateHUD();
  }

  // Rotation: meshed gears + hints (direction-correct; visible on all cells)
  function rollDie(){
    const P=currentPlayer();
    if(P.rollUsed){ setStatus('You have already rolled this turn.'); return; }
    pushHistory('Roll');
    const r = Math.floor(Math.random()*DIE_FACES.length); state.die = DIE_FACES[r];
    P.rollUsed = true;
    dieTag().textContent='Die: '+state.die; rollTag().textContent='Roll: Used';
    setStatus('Die rolled: '+state.die+'. Hints show per-cell rotation. Click Apply to rotate.');
    btn('applyBtn').disabled = (state.die==='X');
    render();
  }
  function thetaFor(face){ if(face==='CW90') return 90; if(face==='CCW90') return -90; if(face==='DEG180') return 180; return 0; }
  function mod360(a){ return (((a%360)+360)%360); }

  // === Rotation animation helpers (anchor: RR_ROTATE_ANIMS) ===
  // Define these BEFORE render() and applyRotation() (consts are not hoisted)
  const easeInOutQuad = t => (t<0.5 ? 2*t*t : -1 + (4 - 2*t) * t);
  function shortestArc(from,to){ // both degrees [0,360)
    let d = ((to - from + 540) % 360) - 180; // in (-180,180]
    return d;
  }

  function startRotateAnim(x,y, fromDeg, toDeg, dur=500){
    state.rotAnims.push({ x, y, from:fromDeg, to:toDeg, t0: performance.now(), dur });
    ensureAnimLoop();
  }

  // Drive frames while any animation is active (tile tweens or ghost tween)
  function hasActiveAnim(){
     return (state.rotAnims && state.rotAnims.length>0) || !!state.ghostRotAnim || !!state.gearSpinAnim;
  }
  function ensureAnimLoop(){
    if (state._animating) return;
    state._animating = true;
    const step = () => {
      if (hasActiveAnim()){
        render();
        requestAnimationFrame(step);
      } else {
        state._animating = false;
      }
    };
    requestAnimationFrame(step);
  }

  // Current animated angle for the ghost (falls back to previewRot)
  function ghostAngle(){
    const a = state.ghostRotAnim;
    if(!a) return state.previewRot || 0;
    const now = performance.now();
    const u = Math.min(1, (now - a.t0) / a.dur);
    const k = easeInOutQuad(u);
    const ang = a.from + shortestArc(a.from, a.to) * k;
    if (u >= 1) state.ghostRotAnim = null;   // auto-clear when finished
    return mod360(ang);
  }

  function startGearSpinPulse(baseDeg, dur){
    // baseDeg is the die’s base rotation: +90 (CW90), -90 (CCW90), or +180 (DEG180)
    state.gearSpinAnim = { base: baseDeg, t0: performance.now(), dur };
    ensureAnimLoop(); // reuse the existing RAF driver
  }

  function applyRotation(){
    if(!state.die || state.die==='X') return;
    pushHistory('Apply Rotation');
    const base = thetaFor(state.die);
    startGearSpinPulse(base, RR_APPLY_TWEEN_MS);  // spin gears only during this Apply tween

    let rotated=0;
    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
      const cell = state.board[y][x];
      const sign = ((x + y) % 2 === 0) ? 1 : -1;

      // 1) Commit the new gear offset for EVERY cell (track or not).
      if (state.gearOffset && state.gearOffset[y]) {
        const pending = sign * base; // same parity as tiles
        state.gearOffset[y][x] = mod360((state.gearOffset[y][x] || 0) + pending);
      }

      // 2) Only rotate/tween tiles that actually have tracks.
      if(!cell.track || cell.track==='Block') continue;
      const fromRot = cell.rot;
      const toRot   = mod360(cell.rot + sign*base);
      startRotateAnim(x,y, fromRot, toRot, RR_APPLY_TWEEN_MS);
      cell.rot = toRot; // commit; tween overlays visually
      rotated++;
      }
    }

    state.die=null; dieTag().textContent='Die: —'; btn('applyBtn').disabled = true;
    setStatus('Meshed rotation applied to '+rotated+' track cell(s).');
    if (rotated > 0) {
      const P = currentPlayer();
      P.rotatedThisTurn = true;    // NEW
    }    
    onTopologyChanged();
    render();
    maybeAutoAdvance();
  }

  // Auto-advance heuristic
  function maybeAutoAdvance(){
    const P=currentPlayer();
    if(!P.drawUsed && !P.drawLocked && !P.drawn) return;
    if(P.drawn) return;
    if(!P.tokenUsed){
      const myTokens = allTokensOf(P.id);
      const corner = cornerFor(P.id);
      const cCell = state.board[corner.y][corner.x];
      const myCount = countTokens(P.id);
      let hasOption = false;
      if(myCount < TOKENS_MAX && cCell.track && cCell.token==null){ hasOption = true; }
      if(!hasOption){
        for(const t of myTokens){
          if(reachableFrom(t, P.id).length>0){ hasOption=true; break; }
        }
      }
      if(hasOption) return;
    }
    if(!P.rollUsed) return;
    // If player is now out (no tokens remaining at all), end turn automatically.
    if (((P.tokensRemoved|0) >= TOKENS_MAX) && countTokens(P.id) === 0) {
      setStatus(P.name + ' has no tokens remaining. Auto-advancing turn…');
      endTurn();
      return;
    }    
    setStatus('No actions remaining. Auto-advancing turn…');
    endTurn();
  }

  // Canvas interactions
  function toCell(px,py){
    const x = Math.floor((px - state.pad) / state.cell);
    const y = Math.floor((py - state.pad) / state.cell);
    return {x,y};
  }

  const canvasEl=UI.canvas();
  canvasEl.addEventListener('mousemove', (e)=>{
    const rect=canvasEl.getBoundingClientRect(); const {x,y}=toCell(e.clientX-rect.left, e.clientY-rect.top);
    if(x<0||y<0||x>=state.N||y>=state.N){ state.hover=null; render(); return; }
    state.hover={x,y};
    render();
  });
  canvasEl.addEventListener('click', (e)=>{
    if(state.turnAdvancing) return;
    const rect=canvasEl.getBoundingClientRect(); const {x,y}=toCell(e.clientX-rect.left, e.clientY-rect.top);
    if(x<0||y<0||x>=state.N||y>=state.N) return;

    // ----- Corner Fix: replace owner's corner with Cross (free) -----
    if (state.phase === 'cornerFix'){
      const P = currentPlayer();
      const c = state.fixCorner;             // set by startCornerFixCross(ownerId)
      if (!(c && x===c.x && y===c.y)){
        toast('Click your corner to apply the fix.');
        return;
      }
      const cell = state.board[y][x];
      pushHistory('Corner Fix');
      cell.track = 'Cross';
      cell.owner = P.id;
      cell.rot   = 0;                        // Cross is symmetric
      state.phase='idle'; state.highlight=[]; state.hover=null;
      state.fixOwner=null; state.fixCorner=null;
      if (typeof onTopologyChanged === 'function') onTopologyChanged();
      render(); updateHUD(); setStatus('Corner fixed: Cross placed.');
      return;
    }
    
    // Dead-Straight Fix click (one free replacement per turn)
    if (state.phase === 'deadFix' && state.subphase === 'pickDeadStraight'){
      const hit = state.highlight && state.highlight.some(h => h.x===x && h.y===y);
      if (hit){
        const cell = state.board[y][x];

        // Replace the Straight with a Cross; keep owner & token intact
        pushHistory('Dead-Straight Fix');
        state.deadFixDoneThisTurn = true;
        cell.track = 'Cross';
        cell.rot   = 0;   // Cross is symmetric
        // owner, token remain unchanged

        toast('Dead-Straight fixed: placed Cross.');

        // Clear subphase; resume normal turn
        state.phase = 'idle';
        state.subphase = null;
        state.highlight = [];
        state.hover = null;

        if (typeof onTopologyChanged === 'function') onTopologyChanged();
        render();
        updateHUD();
        setStatus('Dead-Straight fixed. Continue your turn.');
      }
      return; // consume click during deadFix phase
    }

    // PLACE phase
    if(state.phase==='place')
    {
      const P=currentPlayer(); 
      const cell=state.board[y][x];

      // If a ghost rotation tween is running (from Q/E), queue this click
      // and execute it AFTER the tween lands on the exact 90° angle.
      if (state.ghostRotAnim) {
        const wasRotateCommit =
          (state.subphase==='rotateExisting' &&
          state.rotateFocus &&
          state.rotateFocus.x===x &&
          state.rotateFocus.y===y);

        const legal = wasRotateCommit || state.highlight.some(h=>h.x===x&&h.y===y);
        if (!legal) { toast('Not a legal cell'); return; }

        const finalTo = state.ghostRotAnim.to; // the tween's target angle (a clean multiple of 90)
        waitForGhostThen(()=>{
          // Snap preview to the tween’s landed angle and perform the same action as if clicked now
          state.previewRot = ((finalTo % 360) + 360) % 360;

          // Re-enter the same logic paths below, but without the early return.
          if (wasRotateCommit) {
            // === RS/RE rotateExisting COMMIT (same as original commit block) ===
            const toRot = state.previewRot;
            cell.rot = toRot;
            P.deck.discard.push(P.drawn); P.drawn = null;
            P.skipCount = 0;
            state.forcePlace = false;
            state.subphase = null; state.rotateFocus = null; state.previewRot = 0;
            pulse(x,y);
            state.phase='idle'; state.highlight=[]; state.hover=null;
            onTopologyChanged();
            render(); updateHUD(); setStatus('Rotation applied.'); maybeAutoAdvance();
          } else {
            // === Normal placement path (same as original “place track” block) ===
            if (cell.track){ toast('Cell occupied'); return; }
            if(state.rotateFocus){
              const rf=state.rotateFocus; const cc=state.board[rf.y][rf.x];
              cc.rot=rf.original; state.rotateFocus=null; state.subphase=null;
            }
            const placedType = baseDrawnType(P.drawn);
            pushHistory('Place/Replace');
            cell.track=placedType; cell.rot=state.previewRot; cell.owner=P.id;
            P.deck.discard.push(P.drawn); P.drawn=null;
            P.skipCount = 0;
            state.forcePlace = false;
            if (placedType === TrackCard.Elbow) {
              P.elbowSkipCount = 0;
              state.forceElbowFor = null;
            }
            pulse(x,y);
            state.ghostRotAnim = null;
            state.phase='idle'; state.highlight=[]; state.hover=null;
            onTopologyChanged(); updateHUD();
            setStatus('Placed. You cannot draw again this turn.');
            maybeAutoAdvance();
          }
        });
        return; // stop now; the queued action above will run after the tween finishes
      }

      // RS/RE: COMMIT rotation FIRST if we're clicking the selected tile
      if (state.subphase==='rotateExisting'
         && state.rotateFocus
         && state.rotateFocus.x===x
         && state.rotateFocus.y===y) {
        // Commit the preview orientation (no re-animate; user already saw the ghost at final angle)
        const toRot   = mod360((state.previewRot ?? cell.rot));
        cell.rot = toRot;
        P.deck.discard.push(P.drawn); P.drawn = null;
        P.skipCount = 0;
        state.forcePlace = false;     // placing satisfies the force rule
        state.subphase = null; state.rotateFocus = null; state.previewRot = 0;
        pulse(x,y);
        state.ghostRotAnim = null;
        state.phase='idle'; state.highlight=[]; state.hover=null;
        onTopologyChanged();
        render(); updateHUD(); setStatus('Rotation applied.'); maybeAutoAdvance();
        return;
      }

      // --- NEW-PLACEMENT: COMMIT after rotation if tapping same focused cell ---
      if (state.subphase==='rotateNew' && state.rotateFocus &&
          state.rotateFocus.x===x && state.rotateFocus.y===y) {
        const P = currentPlayer();
        const cell = state.board[y][x];

        // Commit at the preview angle
        const placedType = baseDrawnType(P.drawn);
        pushHistory('Place/Replace');
        cell.track = placedType;
        cell.rot   = mod360(state.previewRot || 0);
        cell.owner = P.id;

        P.deck.discard.push(P.drawn);
        P.drawn = null;
        P.skipCount = 0;
        state.forcePlace = false;

        if (placedType === TrackCard.Elbow) {
          P.elbowSkipCount = 0;
          state.forceElbowFor = null;
        }

        pulse(x,y);
        state.ghostRotAnim = null;
        state.subphase = null;
        state.rotateFocus = null;
        state.previewRot  = 0;
        state.phase='idle';
        state.highlight=[];
        state.hover=null;

        if (typeof onTopologyChanged === 'function') onTopologyChanged();
        render();
        updateHUD();
        setStatus('Placed. You cannot draw again this turn.');
        maybeAutoAdvance();
        return;
      }

      // === RS/RE: ENTER rotateExisting BEFORE legal-cell gating ===
      // Allow rotating ANY existing tile of the same base type (even on first turn).
      if (cell.track && (P.drawn===TrackCard.RStraight || P.drawn===TrackCard.RElbow || P.drawn===TrackCard.RT)) {
        const base = baseDrawnType(P.drawn);
        if (cell.track === base) {
          state.subphase='rotateExisting';
          state.rotateFocus = {x,y, original: cell.rot};
          state.previewRot  = cell.rot;
          state.hover       = {x,y};
          state.highlight   = [{x,y}];   // show selection
          setStatus('Rotating '+base+': use Q/E to rotate; click again to confirm.');
          render(); updateHUD();
          return;
        }
      }
      // (commit handled above)
      // For everything else, we still require the cell to be legal
      const legal = state.highlight.some(h=>h.x===x&&h.y===y);
      if(!legal){ toast('Not a legal cell'); return; }

      // If it's a legal EMPTY cell for a NEW placement, enter rotateNew subphase first
      if (!cell.track && state.subphase !== 'rotateExisting') {
        state.subphase    = 'rotateNew';
        state.rotateFocus = { x, y, original: 0 };
        // Start preview angle from whatever the ghost shows now
        state.previewRot  = mod360(ghostAngle() || 0);
        state.hover       = {x,y};
        state.highlight   = [{x,y}]; // show focus box
        setStatus('Rotate with ⟲/⟳ (or Q/E), then tap again to place.');
        render();
        updateHUD();
        return;
      }

      // RC: Replaceable Cross — claim any existing track type on click
      if (P.drawn===TrackCard.RCross && cell.track){
        // (Rotation is irrelevant for Cross; keep current orientation or normalize to 0 if you prefer.)
        pushHistory('Place/Replace');
        cell.track = 'Cross';
        cell.owner = P.id;
        cell.rot = 0; // optional, Cross is symmetric
        // cell.rot = 0; // optional: normalize
        P.deck.discard.push(P.drawn); P.drawn = null;
        P.skipCount = 0;
        state.forcePlace = false;   // placing satisfies the force rule
        pulse(x,y);
        state.ghostRotAnim = null;
        state.phase='idle'; state.highlight=[]; state.hover=null; state.previewRot=0;
        onTopologyChanged();
        render(); updateHUD(); setStatus('Track replaced with Cross (ownership changed).'); maybeAutoAdvance();
        return;
      }

      // (RS/RE enter block moved above legal check)
      if(cell.track){ toast('Cell occupied'); return; }
      if(state.rotateFocus){ const rf=state.rotateFocus; const cc=state.board[rf.y][rf.x]; cc.rot=rf.original; state.rotateFocus=null; state.subphase=null; }
          const placedType = baseDrawnType(P.drawn);
          pushHistory('Place/Replace');
          cell.track=placedType; cell.rot=state.previewRot; cell.owner=P.id;
          P.deck.discard.push(P.drawn); P.drawn=null;
          P.skipCount = 0;
          state.forcePlace = false;   // placing satisfies the force rule
          if (placedType === TrackCard.Elbow) {
            P.elbowSkipCount = 0;
            state.forceElbowFor = null;       // clear the elbow force after placing one
          }
          pulse(x,y);
          state.ghostRotAnim = null;  // clear any in-progress ghost tween
          state.phase='idle'; state.highlight=[]; state.hover=null; onTopologyChanged(); updateHUD(); setStatus('Placed. You cannot draw again this turn.');
          maybeAutoAdvance();
          return;
    }

    // TOKEN phase
    if(state.phase==='token'){
      const P=currentPlayer();
      if(state.subphase==='select'){
        const isMine = state.board[y][x].token===P.id;
        if(isMine){
          const from = {x,y};
          const moves = reachableFrom(from, P.id);
          if (moves.length===0) {
            // Stay on this player's turn: warn, and keep selection active.
            setStatus('That token is stuck (no connected destinations). Choose a different token or click End Turn.');
            toast('Token cannot move');

            // Re-highlight only tokens that CAN move (plus corner, if eligible).
            const movable = allTokensOf(P.id).filter(t => reachableFrom(t, P.id).length > 0);
            const corner = cornerFor(P.id);
            const cCell  = state.board[corner.y][corner.x];
            const canPlace = countTokens(P.id) < TOKENS_MAX && cCell.track && cCell.token == null;

            state.tokenSelect = null;               // remain in subphase='select'
            state.highlight   = canPlace ? [...movable, corner] : movable;
            render();
            return;
          }          
          state.tokenSelect = from; state.highlight = moves; state.subphase='target';
          setStatus('Token: choose a connected destination (pipes may traverse opponents).'); render(); return;
        }
        const corner = cornerFor(P.id);
        if(corner.x===x && corner.y===y){
          const cCell = state.board[corner.y][corner.x];
          const myCount = countTokens(P.id);
          // Safety: don’t let legacy snapshots over-place
          const reachedCount = P.reached ? (P.reached instanceof Set ? P.reached.size : new Set(P.reached).size) : 0;
          const effectiveRemoved = Math.max((P.tokensRemoved|0), reachedCount);
          const lifetimePlaced = Math.min(TOKENS_MAX, effectiveRemoved + myCount);

          if (lifetimePlaced >= TOKENS_MAX) {
            toast('You have already used all 3 tokens.');
            return;
          }
          if(!(cCell.track && (cCell.token==null))){ toast('Corner must have a track and be open.'); return; }
          pushHistory('Token: place');
          cCell.token = P.id; state.players[P.id].tokens = myCount+1;
          P.tokenUsed = true; tokenTag().textContent='Token: Used'; btn('tokenBtn').disabled = true;
          state.phase='idle'; state.subphase=null; state.highlight=[]; state.tokenSelect=null; setStatus('New token placed at your corner.'); render(); updateHUD();
          maybeAutoAdvance();
          return;
        }
        toast('Select your token to move, or your open corner to place a new one.');
      } else if(state.subphase==='target'){
        const legal = state.highlight.some(h=>h.x===x&&h.y===y);
        if(!legal){ toast('Pick a connected destination.'); return; }
        const from = state.tokenSelect;
        // Move / Score handling (fix: always remove moving token on scoring; never leave extra token on board)
        pushHistory('Token: move');
        // 1) Clear the moving token from its source cell (always)
        if (from && within(from.x, from.y) && state.board[from.y][from.x].token === P.id) {
          state.board[from.y][from.x].token = null;
        }
        const oppId = opponentCornerAt(x, y, P.id);
        const destHasOwner = (oppId != null && state.board[y][x].token === oppId);
        if (oppId != null) {
          // 2) Reached an opponent's corner → record score
          if (!P.reached) P.reached = new Set();
          const oppName = PLAYERS[oppId].name;
          P.reached.add(oppName);
          // 3) Do NOT leave our token on the destination (corner stays with its owner’s token if present)
          if (state.board[y][x].token === P.id) {
            state.board[y][x].token = null;
          }
          // 4) Count this token as removed from play
          P.tokensRemoved = Math.min(TOKENS_MAX, (P.tokensRemoved|0) + 1);
          setStatus(P.name + ' scored at ' + oppName + "'s corner!");
        } else {
          // Normal move to a non-scoring cell → place our token there
          state.board[y][x].token = P.id;
          setStatus('Token moved.');
        }
        // If that move completed 3/3 corners, auto-end the turn immediately.
        if (playerHasFinished(currentPlayer())) {
          const P = currentPlayer();
          P.tokenUsed = true;                // consume the action
          tokenTag().textContent='Token: Used';
          btn('tokenBtn').disabled = true;
          state.phase='idle'; state.subphase=null;
          state.highlight=[]; state.tokenSelect=null;
          render(); updateHUD();
          setStatus(P.name + ' completed all three corners — auto-advancing turn…');
          endTurn();
          return; // stop; we just advanced the turn
        }

        currentPlayer().tokenUsed = true; tokenTag().textContent='Token: Used'; btn('tokenBtn').disabled = true;
              state.phase='idle'; state.subphase=null; state.highlight=[]; state.tokenSelect=null; render(); updateHUD();
              maybeAutoAdvance();
              return;
      }
    }
  });

  // === ROTATE PREVIEW KEYS (anchor: RR_ROTATE_KEYS) ===
  window.addEventListener('keydown', (e)=>{
    if (state.phase !== 'place') return;
    const k = e.key.toLowerCase();
    if (k !== 'q' && k !== 'e') return;

    // Where is the mouse?
    const h = state.hover;
    const hoveringEmpty = !!(h && within(h.x, h.y) && (()=>{
      const c = state.board[h.y][h.x];
      return !c.track && c.token == null;
    })());

    // Allow rotation if:
    // 1) We are actively rotating an existing tile (RS/RE after click), OR
    // 2) We are hovering an EMPTY cell (previewing a new placement)
    if (!(state.subphase === 'rotateExisting' || hoveringEmpty)) {
      // Optional: UI nudge when RS/RE is drawn and you're over an occupied cell
      // const d = currentPlayer().drawn;
      // if (d===TrackCard.RStraight || d===TrackCard.RElbow) setStatus('Click a track to rotate');
      return;
    }

    const stepDeg = (k==='q' ? -90 : 90);      // Q=CCW, E=CW
    rotatePreview(stepDeg);
    const from = ghostAngle();                 // current animated angle (if mid-tween)
    const to   = mod360(from + stepDeg);
    state.previewRot   = to;                   // target angle
    state.ghostRotAnim = { from, to, t0: performance.now(), dur: PREVIEW_ROT_TWEEN_MS };
    ensureAnimLoop();
    render();                                  // draw first frame immediately    
  });  

  // Wire buttons
  btn('newGameBtn').addEventListener('click', newGame);
  document.getElementById('returnMenuBtn').addEventListener('click', ()=>{
    const ok = confirm('Return to Main Menu? Current game progress will be lost unless you saved.');
    if (!ok) return;
      window.location.href = 'MainMenu.html';
  });
  btn('drawBtn').addEventListener('click', drawCard);
  btn('placeBtn').addEventListener('click', placeMode);
  btn('bottomBtn').addEventListener('click', bottomCard);
  const endTurnBtn = document.getElementById('endTurnBtn');
  endTurnBtn.addEventListener('click', endTurn);
  const overrideBtn = document.getElementById('overrideBtn');
  overrideBtn.addEventListener('click', ()=>{
    state.forcePlace = false;
    endTurnBtn.disabled = false;
    overrideBtn.style.display = 'none';
    toast('Override used: End Turn enabled.');
  });
  btn('rotateCCWBtn').addEventListener('click', ()=>rotatePreview(-90));
  btn('rotateCWBtn').addEventListener('click',  ()=>rotatePreview(+90));
  btn('tokenBtn').addEventListener('click', tokenMode);
  btn('rollBtn').addEventListener('click', rollDie);
  btn('applyBtn').addEventListener('click', applyRotation);
  UI.vizEdges().addEventListener('change', render);

  btn('saveBtn').addEventListener('click', saveGame);
  btn('loadBtn').addEventListener('click', () => document.getElementById('loadFile').click());
  document.getElementById('loadFile').addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) loadFromFile(f);
    e.target.value = ''; // reset so the same file can be chosen again later
  });

  function rotatePreview(stepDeg){
    if (state.phase !== 'place') return;

    // Can rotate if: rotating an existing tile OR rotating a new placement focus
    const rotatingExisting = (state.subphase === 'rotateExisting' && state.rotateFocus);
    const rotatingNew      = (state.subphase === 'rotateNew'      && state.rotateFocus);

    if (!(rotatingExisting || rotatingNew)) return;

    const from = ghostAngle();               // current anim angle
    const to   = mod360(from + stepDeg);     // land on 90° grid
    state.previewRot   = to;
    state.ghostRotAnim = { from, to, t0: performance.now(), dur: PREVIEW_ROT_TWEEN_MS };
    ensureAnimLoop();
    render();
  }

  // Undo/Redo buttons
  document.getElementById('undoGlobalBtn').addEventListener('click', undoGlobal);
  document.getElementById('redoGlobalBtn').addEventListener('click', redoGlobal);
  document.getElementById('undoTurnBtn').addEventListener('click', undoTurn);
  document.getElementById('redoTurnBtn').addEventListener('click', redoTurn);

  function renderCornerScoreTable(){
    const tb = document.querySelector('#cornerScoreTable tbody');
    if (!tb || !state || !state.players) return;

    const N = state.N;

    // Map pocket -> text with coordinates based on current board size
    const quadText = (pocket) => {
      switch (pocket) {
        case 'NW': return 'NW (0,0)';
        case 'NE': return `NE (${N-1},0)`;
        case 'SE': return `SE (${N-1},${N-1})`;
        case 'SW': return `SW (0,${N-1})`;
        default:   return pocket || '—';
      }
    };

    for (const p of state.players) {
      const pid = p.id;
      const tr  = tb.querySelector(`tr[data-pid="${pid}"]`);
      if (tr) {
        tr.classList.toggle('inactiveRow', !p.active);
      }      
      // reached is stored as Set of player names (e.g., 'Red', 'Green')
      const reachedSet = p.reached
        ? (Array.isArray(p.reached) ? new Set(p.reached) : p.reached)
        : new Set();

      // Show same bracket letters as the top Score tag: [R, G, ...]
      const letters = reachedSet.size
        ? Array.from(reachedSet).map(n => String(n)[0]).join(', ')
        : '';

      const scoreStr = `${reachedSet.size}/3${letters ? ` [${letters}]` : ''}`;

      const qEl = document.getElementById(`quad-${pid}`);
      const sEl = document.getElementById(`score-${pid}`);
      if (qEl) qEl.textContent = quadText(p.pocket) + (p.active ? '' : ' (inactive)');
      if (sEl) sEl.textContent = p.active ? scoreStr : '—';
    }
  }

    // Start/stop a requestAnimationFrame loop that advances the global gear angle
  function startGearSpin(){
    if (!GEAR_SPIN_ENABLED) return;
    if (state._spinRAF) cancelAnimationFrame(state._spinRAF);
    state._lastSpinT = performance.now();

    const step = (t) => {
      const dt = t - state._lastSpinT;                // milliseconds
      state._lastSpinT = t;

      // degrees per millisecond = RPM * 360 / 60000
      const degPerMs = (GEAR_SPIN_RPM * 360) / 60000;
      state.gearSpinDeg = (state.gearSpinDeg + degPerMs * dt) % 360;

      // Repaint only if the image is ready (avoids useless work before onload)
      if (gearReady) render();

      state._spinRAF = requestAnimationFrame(step);
    };
    state._spinRAF = requestAnimationFrame(step);
  }

  function stopGearSpin(){
    if (state._spinRAF) cancelAnimationFrame(state._spinRAF);
    state._spinRAF = null;
  }

  function updateHUD(){
    (function(){
      const b = document.getElementById('placeBtn');
      if (!b) return;
      const confirming = (state.phase==='place' && state.subphase==='rotateNew' && !!state.rotateFocus);
      b.textContent = confirming ? 'Confirm' : 'Place';
    })();

    if (state.phase === 'gameOver') {
      const P = currentPlayer();
      turnTag().textContent  = 'Turn: —';
      phaseTag().textContent = 'Phase: gameOver';
      drawnTag().textContent = 'Card: —';
      drawTag().textContent  = 'Draw: —';
      dieTag().textContent   = 'Die: —';
      rollTag().textContent  = 'Roll: —';
      tokenTag().textContent = 'Token: —';
      // Disable all action buttons
      ['drawBtn','placeBtn','bottomBtn','tokenBtn','rollBtn','applyBtn','endTurnBtn','undoGlobalBtn','redoGlobalBtn','undoTurnBtn','redoTurnBtn']
        .forEach(id => { const b = document.getElementById(id); if (b) b.disabled = true; });
      renderCornerScoreTable();
      render();
      updateUndoButtons();
      return;
    }

    renderCornerScoreTable();

    const P=currentPlayer();

    if (state.phase === 'deadFix'){
      // Keep the messaging visible while the selection is up
      drawTag().textContent = (state.phase === 'deadFix')
        ? 'Draw: Locked (Dead-Straight Fix)'
        : (P.drawUsed
            ? 'Draw: Used'
            : (rotationsRemain ? 'Draw: Ready (Board Full: rotations available)'
                               : 'Draw: Locked (Board Full)'));
      // Keep Skipped tag accurate during deadFix (prevents stale "⚠" from older UI states)
      (function(){
        const el = document.getElementById('skippedTag');
        if(!el) return;
        const skipCount = (P && P.skipCount) ? P.skipCount : 0;
        el.textContent = 'Skipped: ' + skipCount + '/3';
        if (skipCount >= 3) {
          el.classList.add('warn');
          el.textContent += '  ⚠ Maximum skipped';
        } else {
          el.classList.remove('warn');
        }
      })();                               
      setStatus('Dead-Straight Fix: replace ONE highlighted Straight with a Cross (free).');
      render();
      updateUndoButtons();
      return; // ← prevent later HUD paths from overwriting this status
    }

    if (state.boardSaturated){
      const P = currentPlayer();
      const elbowForceNow =
        (state.forceElbowFor === P.id) &&
        (P.drawn === TrackCard.Elbow) &&
        canPlaceElbowNow(P.id);      
      const rotationsRemain = hasRotationInDeck(P);
      const holdingRotation = isRotationCard(P.drawn);

      // Tag
      drawTag().textContent = state.phase === 'deadFix'
        ? 'Draw: Locked (Dead-Straight Fix)'
        : (rotationsRemain ? 'Draw: Ready (Board Full: rotations available)' : 'Draw: Locked (Board Full)');

      // Basic tags that should still reflect current state
      turnTag().textContent  = 'Turn: ' + currentPlayer().name + ' (' + currentPlayer().pocket + ')';
      phaseTag().textContent = 'Phase: ' + state.phase;
      dieTag().textContent   = 'Die: ' + (state.die || '—');
      rollTag().textContent  = 'Roll: ' + (currentPlayer().rollUsed ? 'Used' : 'Ready');
      tokenTag().textContent = 'Token: ' + (currentPlayer().tokenUsed ? 'Used' : 'Ready');
      drawnTag().textContent = 'Card: ' + (P.drawn || '—');   // ← keep the Card tag in sync

      // Score tag MUST keep updating even when board is full
      (function(){
        const el = document.getElementById('scoreTag');
        if(!el) return;
        const P = currentPlayer();
        const reached = P.reached ? P.reached : new Set();
        const list = (reached && reached.size) ? Array.from(reached).map(n=>n[0]).join(', ') : '';
        el.textContent = 'Score: ' + (reached ? reached.size : 0) + '/3' + (list ? (' ['+list+']') : '');
      })();

      // Skipped tag MUST also refresh here (otherwise stale "⚠ Maximum skipped" can stick)
      (function(){
        const el = document.getElementById('skippedTag');
        if(!el) return;
        const skipCount = (P && P.skipCount) ? P.skipCount : 0;
        el.textContent = 'Skipped: ' + skipCount + '/3';
        if (skipCount >= 3) {
          el.classList.add('warn');
          el.textContent += '  ⚠ Maximum skipped';
        } else {
          el.classList.remove('warn');
        }
      })();

      // Elbows Skipped tag also refreshes here
      (function(){
        const el = document.getElementById('elbowSkippedTag');
        if(!el) return;
        const ecount = (P && P.elbowSkipCount) ? P.elbowSkipCount : 0;
        el.textContent = 'Elbows Skipped: ' + ecount + '/3';
        if (ecount >= 3) {
          el.classList.add('warn');
          el.textContent += elbowForceNow
            ? '  ⚠. This elbow must be now be placed'
            : '  ⚠ Next Elbow must be placed';
        } else {
          el.classList.remove('warn');
        }
      })();
      // Buttons: draw allowed only if rotations remain; place allowed only if holding RS/RE/RC
      const forcedOK = state.forcePlace && !P.drawn; // unchanged forced-draw semantics
      btn('drawBtn').disabled   = !!P.drawn || P.drawUsed || ((!rotationsRemain) && !forcedOK);
      btn('placeBtn').disabled  = !P.drawn || !holdingRotation;   // only RS/RE/RC can act on full board
      // Bottom blocked while elbow is being forced and placeable
      btn('bottomBtn').disabled = !P.drawn || state.forcePlace || elbowForceNow;
      // End Turn blocked while elbow is being forced and placeable
      endTurnBtn.disabled = !!elbowForceNow;
      overrideBtn.style.display = 'none';
      btn('tokenBtn').disabled = !!currentPlayer().tokenUsed;
      btn('rollBtn').disabled  = !!currentPlayer().rollUsed;
      btn('applyBtn').disabled = !(state.die && state.die!=='X');
      if (elbowForceNow) {
        setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
      }      

      render();
      updateUndoButtons();
      return;
    }

    // Corner Fix HUD lock: show a RED warning and disable all actions until the free Cross is applied
    if (state.phase === 'cornerFix'){
      // Make sure the tags reflect the current subphase
      turnTag().textContent='Turn: '+P.name+' ('+P.pocket+')';
      phaseTag().textContent='Phase: cornerFix';
      setStatus('<span class="warn">Your corner is sealed. Click on your corner track to replace it with a cross track.</span>');
      drawTag().textContent = 'Draw: Locked (Corner Fix)';
      btn('drawBtn').disabled   = true;
      btn('placeBtn').disabled  = true;
      btn('bottomBtn').disabled = true;
      btn('tokenBtn').disabled  = true;
      btn('rollBtn').disabled   = true;
      btn('applyBtn').disabled  = true;
      endTurnBtn.disabled = true;
      overrideBtn.style.display = 'none';

      render();
      updateUndoButtons();

      return;
    }

    if (P.drawn && (P.drawn===TrackCard.Straight || P.drawn===TrackCard.Elbow ||
        P.drawn===TrackCard.Cross || P.drawn===TrackCard.RStraight ||
        P.drawn===TrackCard.RElbow || P.drawn===TrackCard.RCross)) {
      setStatus(`Skipped: ${P.skipCount}/3`);
    }

    turnTag().textContent='Turn: '+P.name+' ('+P.pocket+')';
    phaseTag().textContent='Phase: '+state.phase;
    drawnTag().textContent='Card: '+(P.drawn || '—');
    dieTag().textContent='Die: '+(state.die || '—');
    drawTag().textContent = 'Draw: ' + (
      (state.forcePlace && !P.drawn) ? 'Ready (Forced)' :
      (P.drawLocked ? 'Locked' : (P.drawUsed ? 'Used' : 'Ready'))
    );    
    rollTag().textContent='Roll: '+(P.rollUsed ? 'Used' : 'Ready');
    // Deterministic draw gating; allow draw during forced-draw even if previously locked/used
    const _forcedDrawOK = state.forcePlace && !P.drawn;
    btn('drawBtn').disabled = !!P.drawn || ((P.drawLocked || P.drawUsed) && !_forcedDrawOK);    // Enable Place only when a track card is in hand
    btn('placeBtn').disabled = !P.drawn;    

    // Disable Bottom when there's nothing to bottom, or when maximum-skips forces a draw/place
    btn('bottomBtn').disabled = !P.drawn || state.forcePlace;    
    btn('applyBtn').disabled = !(state.die && state.die!=='X');
    btn('tokenBtn').disabled = !!P.tokenUsed;
    btn('rollBtn').disabled = !!P.rollUsed;

    // Arm elbow force here as well if threshold reached and a placeable Elbow is in hand.
    if ((P.elbowSkipCount|0) >= 3 && P.drawn === TrackCard.Elbow && canPlaceElbowNow(P.id)) {
      state.forceElbowFor = P.id;
    }    

    // Elbow force applies only when the forced player is current, holding an Elbow, and it can be placed.
    const elbowForceApplies =
      (state.forceElbowFor === P.id) &&
      (P.drawn === TrackCard.Elbow) &&
      canPlaceElbowNow(P.id);

    // Waive elbow force here too if it turns out impossible right now
    if (state.forceElbowFor === P.id && P.drawn === TrackCard.Elbow && !canPlaceElbowNow(P.id)) {
      state.forceElbowFor = null;
    }

    if (elbowForceApplies) {
      btn('bottomBtn').disabled = true;
      endTurnBtn.disabled = true;
      overrideBtn.style.display = 'none';
      setStatus('Elbows Skipped: 3/3 ⚠. This elbow must be now be placed');
    }

    tokenTag().textContent = 'Token: ' + (P.tokenUsed ? 'Used' : 'Ready');
    
    // --- TOKEN COUNT (show the *actual* count) ---
    (function(){
      const el = document.getElementById('tokenCount');
      if (!el) return;

      const onBoard = countTokens(P.id);
      const removed = (P.tokensRemoved|0);
      const actualPlaced = Math.min(TOKENS_MAX, removed + onBoard);

      // Show the ACTUAL number (no safety inflation)
      el.textContent = 'Token: ' + actualPlaced + '/' + TOKENS_MAX;

      // If there is a mismatch between scored corners and removed tokens, surface it (subtle warning).
      // This does NOT affect the displayed number.
      const reachedCount =
        P.reached ? (P.reached instanceof Set ? P.reached.size : new Set(P.reached).size) : 0;
      const expectedMin = Math.min(TOKENS_MAX, reachedCount + onBoard);

      if (actualPlaced < expectedMin) {
        // Mismatch: we've scored more corners than tokensRemoved reflects.
        el.textContent += ' ⚠';
        el.title = `Mismatch detected: reached=${reachedCount}, onBoard=${onBoard}, tokensRemoved=${removed}`;
        // Optional: tint the text to draw attention. Remove if you prefer no color change.
        el.style.color = '#ffb020';
        el.style.fontWeight = '600';
      } else {
        // Clear any prior styling/tooltips if mismatch resolved
        el.removeAttribute('title');
        el.style.color = '';
        el.style.fontWeight = '';
      }
    })();

    (function(){
      const el = document.getElementById('skippedTag');
      if(!el){ return; }
      const P = currentPlayer();
      const skipCount = (P && P.skipCount) ? P.skipCount : 0;
      el.textContent = 'Skipped: ' + skipCount + '/3';
      // Visual warning when max skips reached
      if (skipCount >= 3) {
        el.classList.add('warn');   // <- requires CSS for .warn
        el.textContent += '  ⚠ Maximum skipped';
      } else {
        el.classList.remove('warn');
      }
      // SAFETY: if force is active BUT the current card can’t be placed anywhere,
      // auto-waive to prevent deadlocks (Bottom/End Turn become available).
      if (state.forcePlace && P.drawn && !canPlaceDrawnNow(P.id)) {
        state.forcePlace = false;
      }
      if (state.forcePlace) {
        endTurnBtn.disabled = true;
        // overrideBtn.style.display = 'inline-block';
        // Only show Override if there IS a track in hand; otherwise force Draw first
        overrideBtn.style.display = P.drawn ? 'inline-block' : 'none';

        if (!P.drawn) {
          setStatus('Maximum track cards skipped — you must Draw and Place before ending your turn (or use Override).');
        } else {
          setStatus('Maximum track cards skipped — you must Place your drawn track (or use Override).');
        }
      } else {
        // Do NOT re-enable End Turn if a forced Elbow is in hand and placeable.
        if (!elbowForceApplies) {
          endTurnBtn.disabled = false;
        }
        overrideBtn.style.display = 'none';
      }
    })();

    (function(){
      const el = document.getElementById('elbowSkippedTag');
      if(!el){ return; }
      const P = currentPlayer();
      const ecount = (P && P.elbowSkipCount) ? P.elbowSkipCount : 0;
      el.textContent = 'Elbows Skipped: ' + ecount + '/3';
      if (ecount >= 3) {
        el.classList.add('warn');
        el.textContent += elbowForceApplies
          ? '  ⚠. This elbow must be now be placed'
          : '  ⚠ Next Elbow must be placed';
      } else {
        el.classList.remove('warn');
      }
    })();    

    (function(){
      const el = document.getElementById('scoreTag');
      if(!el){ return; }
      const reached = P.reached ? P.reached : new Set();
      const list = (reached && reached.size) ? Array.from(reached).map(n=>n[0]).join(', ') : '';
      el.textContent = 'Score: ' + (reached ? reached.size : 0) + '/3' + (list?(' ['+list+']'):'');
    })();
    render();
  }

  function render(){
    const N=state.N, cell=state.cell, pad=state.pad;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle=COLORS.bg; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.save(); ctx.translate(pad,pad);
    const size=cell*N;
    const now = performance.now();
    state._frameNow = now;  // unify timing across all per-frame animations
    // grid
    ctx.strokeStyle=COLORS.grid; ctx.lineWidth=1;
    ctx.strokeRect(0,0,size,size);
    for(let i=1;i<N;i++){ ctx.beginPath(); ctx.moveTo(i*cell,0); ctx.lineTo(i*cell,size); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,i*cell); ctx.lineTo(size,i*cell); ctx.stroke(); }
    // gears (background)
    for(let y=0;y<N;y++) for(let x=0;x<N;x++){ drawGear(x,y); }
    // corner color badges
    drawCornerBadges();

    // tracks (with rotation tween overlay)
    // prune finished tweens
    state.rotAnims = state.rotAnims.filter(a => (now - a.t0) <= (a.dur + 24));
    const rotMap = new Map();
    for(const a of state.rotAnims){
      const u = Math.min(1, (now - a.t0)/a.dur);
      const k = easeInOutQuad(u);
      const rot = a.from + shortestArc(a.from, a.to) * k;
      rotMap.set(a.x+','+a.y, rot);
    }
    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
        const c=state.board[y][x]; if(!c.track) continue;
        const key = x+','+y;
        if(rotMap.has(key)){
          drawTrack(c.track, ((rotMap.get(key)%360)+360)%360, x,y, 1);
        }else{
          drawTrack(c.track, c.rot, x,y, 1);
        }
      }
    }    

    // tokens
    for(let y=0;y<N;y++) for(let x=0;x<N;x++){ const c=state.board[y][x]; if(c.token!=null) drawToken(c.token,x,y); }
    // connection edges
    if(UI.vizEdges().checked){ drawEdges(); }
    // rotation hints
    if(state.die && state.die!=='X'){ drawRotationHints(); }
    // center marker
    const cc=Math.floor(N/2); const cx=cc*cell+cell/2, cy=cc*cell+cell/2;
    ctx.strokeStyle=COLORS.hilite; ctx.globalAlpha=0.5; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy, cell*0.42, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
    // turn corner highlight
    drawTurnCornerHighlight();
    // placement highlights
    ctx.strokeStyle=COLORS.hilite; ctx.lineWidth=3;
    state.highlight.forEach(p=>{ ctx.strokeRect(p.x*cell+3, p.y*cell+3, cell-6, cell-6); });
    // stronger "active" outline while rotating an existing tile with RS/RE
    if(state.phase==='place' && state.subphase==='rotateExisting' && state.rotateFocus){
      const rf = state.rotateFocus;
      ctx.save();
      ctx.lineWidth = 5;
      ctx.setLineDash([6,4]);
      ctx.strokeStyle = '#ffcc00';
      ctx.strokeRect(rf.x*cell+2, rf.y*cell+2, cell-4, cell-4);
      ctx.restore();
    }    
    // ghost
    const P=currentPlayer();
    if(state.phase==='place' && state.subphase==='rotateExisting' && state.rotateFocus) {
      const rf = state.rotateFocus; const c = state.board[rf.y][rf.x];
      drawTrack(c.track, ghostAngle(), rf.x, rf.y, 0.9);    
    }
    else if (state.phase==='place' && state.subphase==='rotateNew' && state.rotateFocus) {
      const rf = state.rotateFocus;
      const P  = currentPlayer();
      // Draw the to-be-placed piece at the focused cell, regardless of mouse hover
      drawTrack(baseDrawnType(P.drawn), ghostAngle(), rf.x, rf.y, 0.55);
    }
    else if(state.phase==='place' && state.hover && P.drawn){
      const {x,y}=state.hover;
      const legal = state.highlight.some(h=>h.x===x && h.y===y);
      // Follow-cursor ghost everywhere; greenish when legal, faint red tint when illegal
      drawTrack(baseDrawnType(P.drawn), ghostAngle(), x, y, legal ? 0.55 : 0.35);
      if(!legal){
        ctx.save();
        ctx.strokeStyle = '#e03';
        ctx.lineWidth = 3;
        ctx.setLineDash([6,4]);
        ctx.strokeRect(x*cell+4, y*cell+4, cell-8, cell-8);
        ctx.restore();
      }
    }
    // Token ghost (during Token actions) — same visual rules
    else if(state.phase==='token' && state.hover){
      const {x,y}=state.hover;
      let legal=false;
      if(state.subphase==='target'){
        legal = state.highlight.some(h=>h.x===x && h.y===y);
      }else if(state.subphase==='select'){
        const P=currentPlayer();
        const corner = cornerFor(P.id);
        const cCell  = state.board[corner.y][corner.x];
        const myCount = countTokens(P.id);
        legal = (x===corner.x && y===corner.y && myCount < TOKENS_MAX && cCell.track && cCell.token==null);
      }
      drawToken(currentPlayer().id, x, y, legal ? 0.55 : 0.35);
      if(!legal){
        ctx.save();
        ctx.strokeStyle = '#e03';
        ctx.lineWidth = 3;
        ctx.setLineDash([6,4]);
        ctx.strokeRect(x*cell+4, y*cell+4, cell-8, cell-8);
        ctx.restore();
      }
    }
    // --- end-of-frame cleanup for gear tween ---
    if (state.gearSpinAnim) {
      const a = state.gearSpinAnim;
      if ((performance.now() - a.t0) >= a.dur) {
        state.gearSpinAnim = null;
      }
    }
    // Outer restore for the whole frame   
    ctx.restore();
  }

  // === CORNER COLOR BADGES (anchor: RR_CORNER_BADGES) ===
  // Draw a small right-triangle in each player's corner using their color.
  function drawCornerBadges(){
    const cell = state.cell;
    const m = 3;                                // inset margin
    const t = Math.max(8, Math.floor(cell * 0.25)); // triangle leg length
    ctx.save();
    ctx.globalAlpha = 0.85;
    for (const P of PLAYERS){
      const live = state.players[P.id]?.active !== false;
      ctx.globalAlpha = live ? 0.85 : 0.25;
      const c = cornerFor(P.id);
      const px = c.x * cell, py = c.y * cell;
      ctx.beginPath();
      switch (P.pocket){
        case 'NW':
          ctx.moveTo(px + m,         py + m);
          ctx.lineTo(px + m + t,     py + m);
          ctx.lineTo(px + m,         py + m + t);
          break;
        case 'NE':
          ctx.moveTo(px + cell - m,      py + m);
          ctx.lineTo(px + cell - m - t,  py + m);
          ctx.lineTo(px + cell - m,      py + m + t);
          break;
        case 'SE':
          ctx.moveTo(px + cell - m,      py + cell - m);
          ctx.lineTo(px + cell - m - t,  py + cell - m);
          ctx.lineTo(px + cell - m,      py + cell - m - t);
          break;
        // 'SW'
        default:
          ctx.moveTo(px + m,         py + cell - m);
          ctx.lineTo(px + m + t,     py + cell - m);
          ctx.lineTo(px + m,         py + cell - m - t);
          break;
      }
      ctx.closePath();
      ctx.fillStyle = P.color;
      ctx.fill();
    }
    ctx.restore();
  }

  function drawTurnCornerHighlight(){
    const P=currentPlayer();
    if (!P.active) return; // should not happen, but guard the highlight
    const corner = cornerFor(P.id);
    const cell=state.cell;
    ctx.save();
    ctx.lineWidth = 4;
    ctx.strokeStyle = P.color;
    ctx.globalAlpha = 0.95;
    ctx.strokeRect(corner.x*cell+2, corner.y*cell+2, cell-4, cell-4);
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = P.color;
    ctx.fillRect(corner.x*cell+3, corner.y*cell+3, cell-6, cell-6);
    ctx.restore();
  }

  function drawEdges(){
    const cell=state.cell;
    ctx.save();
    ctx.strokeStyle=COLORS.edge;
    ctx.lineWidth=2;
    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
        const a=state.board[y][x];
        if(!a.track || a.track==='Block') continue;
        for(const [dx,dy] of rotatedOpenings(a)){
          const nx=x+dx, ny=y+dy; if(!within(nx,ny)) continue;
          const b=state.board[ny][nx];
          if(!b.track || b.track==='Block') continue;
          if(hasReciprocal(a,b,dx,dy)){
            const x1=(x+0.5)*cell, y1=(y+0.5)*cell;
            const x2=(nx+0.5)*cell, y2=(ny+0.5)*cell;
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
          }
        }
      }
    }
    ctx.restore();
  }

  // Draw a background gear from the external SVG.
  // Alternates orientation by cell parity: even -> 0°, odd -> 90°.
  function drawGear(x, y){
    const cell = state.cell;
    const cx   = x*cell + cell/2;
    const cy   = y*cell + cell/2;

    // Draw a faint cell border (keeps your existing grid vibe)
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth   = 1;
    ctx.strokeRect(x*cell, y*cell, cell, cell);

    // If the SVG isn’t ready, keep the old fallback so nothing looks broken
    if (!gearReady || !gearImg.naturalWidth || !gearImg.naturalHeight){
      ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(cx, cy, cell/2-4, 0, Math.PI*2); ctx.stroke();
      ctx.fillStyle = '#202a3d';
      ctx.beginPath(); ctx.arc(cx, cy, cell/2-7, 0, Math.PI*2); ctx.fill();
      return;
    }

    // Target outer diameter (so neighboring centers = outer diameter => visual meshing)
    const targetOuter = cell * GEAR_OUTER_FIT;

    // Scale uniformly based on the smaller natural dimension of the SVG
    const natW = gearImg.naturalWidth  || 512;
    const natH = gearImg.naturalHeight || 512;
    const natMin = Math.min(natW, natH);
    const k = targetOuter / natMin;

    // Base mesh orientation (0°/90°) + persistent per-cell offset + transient tween to it
    const baseDeg = ((x + y) % 2 === 0) ? 0 : 90;
    const offset  = (state.gearOffset && state.gearOffset[y] && state.gearOffset[y][x]) || 0;

    let animAdj = 0; // delta applied on top of the committed offset (old→new interpolation)
    const a = state.gearSpinAnim;
    if (a) {
      const now = state._frameNow || performance.now();
      const u   = Math.min(1, (now - a.t0) / a.dur);
      const k   = easeInOutQuad(u);            // same easing as tile tween
      const pending = ((x + y) % 2 === 0) ? (+a.base) : (-a.base); // signed per-cell delta
      // Show: newOffset - pending*(1-k)  →  starts at old, lands at new without snapping
      animAdj = -pending * (1 - k);
    }
    const rotDeg = baseDeg + offset + animAdj;

    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rotDeg * Math.PI / 180);
    ctx.globalAlpha = 1.0; // feel free to drop to ~0.9 if you want tracks to pop more

    // Render with uniform scale; keep the original aspect ratio
    const drawW = natW * k;
    const drawH = natH * k;
    ctx.drawImage(gearImg, -drawW/2, -drawH/2, drawW, drawH);
    ctx.restore();
  }

  function drawTrack(type, rot, x,y, alpha){
    const cell=state.cell; const cx=x*cell+cell/2, cy=y*cell+cell/2; const r=cell/2-8;
    ctx.save(); ctx.globalAlpha=alpha; ctx.translate(cx,cy); ctx.rotate(rot*Math.PI/180);
    if(type==='Block'){
      ctx.fillStyle='#434b63'; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=COLORS.grid; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();
    } else {
      ctx.fillStyle=COLORS.track; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=COLORS.slot; ctx.lineWidth=6;
      if(type==='Straight'){
        ctx.beginPath(); ctx.moveTo(-r*0.85,0); ctx.lineTo(r*0.85,0); ctx.stroke();
      }
      if(type==='Elbow'){
        ctx.beginPath(); ctx.moveTo(0,-r*0.85); ctx.lineTo(0,0); ctx.lineTo(r*0.85,0); ctx.stroke();
      }
      if(type==='Cross'){
        ctx.beginPath(); ctx.moveTo(-r*0.85,0); ctx.lineTo(r*0.85,0); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,-r*0.85); ctx.lineTo(0,r*0.85); ctx.stroke();
      }
      if(type==='T'){
        // Base orientation matches OPENINGS T: E, W, N (closed South). Rotation handles others.
        ctx.beginPath(); ctx.moveTo(-r*0.85,0); ctx.lineTo(r*0.85,0); ctx.stroke(); // horizontal bar
        ctx.beginPath(); ctx.moveTo(0,-r*0.85); ctx.lineTo(0,0); ctx.stroke();      // stem up
      }
    }
    ctx.restore();
  }

  // --- Rotation hints overlay (direction-correct; visible on all cells) ---
  function drawRotationHints(){
    const base = thetaFor(state.die);
    if(base===0) return;
    ctx.save();
    ctx.lineWidth = 3;

    for(let y=0;y<state.N;y++){
      for(let x=0;x<state.N;x++){
        const cellData = state.board[y][x];
        const sign = ((x + y) % 2 === 0) ? 1 : -1;
        const theta = sign * base;
        const cx = x*state.cell + state.cell/2;
        const cy = y*state.cell + state.cell/2;
        const r = state.cell*0.28;
        const sweep = Math.abs(theta) * Math.PI / 180;
        const cw = theta > 0;
        const isTrack = !!cellData.track && cellData.track!=='Block';
        ctx.globalAlpha = isTrack ? 0.58 : 0.22;
        ctx.strokeStyle = COLORS.hint;
        drawArrowArcDir(cx, cy, r, sweep, cw);
      }
    }
    ctx.restore();
  }

  function drawArrowArcDir(cx, cy, r, sweep, cw){
    const start = -Math.PI/2;
    const end = cw ? (start + sweep) : (start - sweep);
    const anticlockwise = !cw;
    ctx.beginPath();
    ctx.arc(cx, cy, r, start, end, anticlockwise);
    ctx.stroke();
    // Arrowhead at end
    const ax = cx + r*Math.cos(end);
    const ay = cy + r*Math.sin(end);
    const t = end + (cw ? Math.PI/2 : -Math.PI/2);
    const len = 8;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - len*Math.cos(t - 0.4), ay - len*Math.sin(t - 0.4));
    ctx.moveTo(ax, ay);
    ctx.lineTo(ax - len*Math.cos(t + 0.4), ay - len*Math.sin(t + 0.4));
    ctx.stroke();
  }

  function drawToken(pid,x,y, alphaOverride){
    const color = PLAYERS[pid].color; const cell=state.cell;
    const cx=x*cell+cell/2, cy=y*cell+cell/2; const r=cell/2-12;
    const a = (alphaOverride==null ? 0.75 : alphaOverride);
    ctx.fillStyle=color; ctx.globalAlpha=a; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1;
    ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.stroke();
  }

  function pulse(x,y){
    const cell=state.cell; const pad=state.pad; const cx=pad+(x+0.5)*cell, cy=pad+(y+0.5)*cell; const r0=6, r1=26;
    const start=performance.now();
    function step(t){
      const k=Math.min(1,(t-start)/280);
      ctx.save();
      ctx.strokeStyle=COLORS.hilite; ctx.lineWidth=3; ctx.globalAlpha=1-k;
      ctx.beginPath(); ctx.arc(cx, cy, r0 + (r1-r0)*k, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
      if(k<1){ requestAnimationFrame(step); } else { render(); }
    }
    requestAnimationFrame(step);
  }

  // initial
  resize();

  // ---- STARTUP ENTRY POINT (runs once the DOM is ready) ----
  document.addEventListener('DOMContentLoaded', function(){
    try {
      // Read menu setup (saved by MainMenu.html) into THIS IIFE's state
      if (typeof loadSetupFromStorage === 'function') {
        const s = loadSetupFromStorage();
        if (s) {
          state.setup = s;
          // keep sidebar Board Size dropdown visually in sync if it's on-screen
          const dd = document.getElementById('boardSize');
          if (dd) dd.value = String(s.boardSize);
        }
      }
      // Build board & start the game using state.setup (7x7/9x9, names, AI flags)
      newGame();
    } catch (e) {
      console.error(e);
    }
  });
})();</script>
</body>
</html>